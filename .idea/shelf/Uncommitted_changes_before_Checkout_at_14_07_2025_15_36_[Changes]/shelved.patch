Index: MainWindow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># cd C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\r\n# python MainWindow.py\r\n# sys.excepthook = excepthook #set the exception handler\r\n# pyinstaller  --noconfirm --noconsole --exclude-module tensorflow --exclude-module torch --exclude-module matlab --icon=\"interface/icons/hyperdoc_logo_transparente.ico\" --add-data \"interface/icons:Hypertool/interface/icons\" --add-data \"ground_truth/Materials labels and palette assignation - Materials_labels_palette.csv:ground_truth\"  --add-data \"data_vizualisation/Spatially registered minicubes equivalence.csv:data_vizualisation\"  MainWindow.py\r\n# C:\\Envs\\py37test\\Scripts\\activate\r\n\r\n\r\n# GUI Qt\r\nfrom PyQt5 import QtWidgets, QtCore\r\nfrom PyQt5.QtCore import QTimer,QSize, Qt\r\nfrom PyQt5.QtGui import QFont,QIcon, QPalette, QColor\r\nfrom PyQt5.QtWidgets import (QStyleFactory, QAction, QPushButton, QSizePolicy,\r\n                             QLabel, QVBoxLayout, QTextEdit,QMessageBox)\r\n\r\n\r\n## exception gestion\r\nimport traceback\r\nimport logging\r\n\r\n# projects import\r\nfrom hypercubes.hypercube import *\r\nfrom data_vizualisation.data_vizualisation_tool import Data_Viz_Window\r\nfrom registration.register_tool        import RegistrationApp\r\nfrom hypercubes.hypercube_manager import HypercubeManager\r\nfrom metadata.metadata_tool import MetadataTool\r\nfrom ground_truth.ground_truth_tool import GroundTruthWidget\r\n\r\n# grafics to control changes\r\nimport matplotlib.pyplot as plt\r\n\r\ndef apply_fusion_border_highlight(app,\r\n                                  border_color: str = \"#888888\",\r\n                                  title_bg:      str = \"#E0E0E0\",\r\n                                  separator_hover: str = \"#AAAAAA\",\r\n                                  window_bg:     str = \"#F5F5F5\",   # ← ton nouveau fond\r\n                                  base_bg:       str = \"#EFEFEF\"):  # ← pour QTextEdit, etc.\r\n    # 1) Fusion\r\n    app.setStyle(QStyleFactory.create(\"Fusion\"))\r\n\r\n    # 1b) palette customisée\r\n    pal = app.palette()\r\n    pal.setColor(QPalette.Window,        QColor(window_bg))\r\n    pal.setColor(QPalette.Base,          QColor(base_bg))\r\n    app.setPalette(pal)\r\n\r\n    # 2) ton QSS existant pour les bordures\r\n    app.setStyleSheet(f\"\"\"\r\n    QMainWindow, QWidget#centralwidget {{\r\n        background-color: {window_bg};\r\n    }}\r\n    QDockWidget {{\r\n        border: 1px solid {border_color};\r\n    }}\r\n    QDockWidget::title {{\r\n        background: {title_bg};\r\n        padding: 3px;\r\n        border-bottom: 1px solid {border_color};\r\n        color: black;\r\n        text-align: left;\r\n    }}\r\n    QMainWindow::separator {{\r\n        background-color: {border_color};\r\n        width: 2px; height: 2px; margin: 1px;\r\n    }}\r\n    QMainWindow::separator:hover {{\r\n        background-color: {separator_hover};\r\n    }}\r\n    QSplitter::handle {{\r\n        background-color: {border_color};\r\n    }}\r\n    QSplitter::handle:hover {{\r\n        background-color: {separator_hover};\r\n    }}\r\n    /* assure que les widgets enfants héritent bien de la couleur de fond */\r\n    QDockWidget > QWidget {{\r\n        background-color: {base_bg};\r\n    }}\r\n    \"\"\")\r\n\r\nclass CustomDockTitleBar(QtWidgets.QWidget):\r\n    def __init__(self, dock_widget, style=None):\r\n        super().__init__()\r\n        self.dock = dock_widget\r\n        self.style = style or {}\r\n        self.setObjectName(\"CustomDockTitleBar\")\r\n\r\n        layout = QtWidgets.QHBoxLayout(self)\r\n        layout.setContentsMargins(5, 0, 5, 0)\r\n\r\n        # Title label\r\n        self.title_label = QtWidgets.QLabel()\r\n        self.title_label.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)\r\n        layout.addWidget(self.title_label)\r\n\r\n        # Fullscreen button\r\n        self.fullscreen_button = QtWidgets.QPushButton(\"⛶\")\r\n        self.fullscreen_button.setFixedSize(20, 20)\r\n        self.fullscreen_button.setToolTip(\"Toggle fullscreen\")\r\n        self.fullscreen_button.clicked.connect(self.toggle_fullscreen)\r\n        layout.addWidget(self.fullscreen_button)\r\n\r\n        # Dock/undock button\r\n        self.dock_button = QtWidgets.QPushButton(\"\uD83D\uDDD7\")\r\n        self.dock_button.setFixedSize(20, 20)\r\n        self.dock_button.setToolTip(\"Dock / Undock\")\r\n        self.dock_button.clicked.connect(self.toggle_dock)\r\n        layout.addWidget(self.dock_button)\r\n\r\n        # Close button\r\n        self.close_button = QtWidgets.QPushButton(\"✕\")\r\n        self.close_button.setFixedSize(20, 20)\r\n        self.close_button.setToolTip(\"Close\")\r\n        self.close_button.clicked.connect(self.dock.close)\r\n        layout.addWidget(self.close_button)\r\n\r\n        self.setLayout(layout)\r\n        self.setAutoFillBackground(True)\r\n\r\n        # Disable double-click behavior\r\n        self.installEventFilter(self)\r\n        self.dock.topLevelChanged.connect(self.update_title)\r\n        self.dock.windowTitleChanged.connect(self.update_title)\r\n\r\n        self.update_title()\r\n        self.apply_style()\r\n\r\n    def toggle_fullscreen(self):\r\n        if not self.dock.isFloating():\r\n            return\r\n        window = self.dock.window()\r\n        if window.isMaximized():\r\n            window.showNormal()\r\n        else:\r\n            window.showMaximized()\r\n\r\n    def toggle_dock(self):\r\n        if self.dock.isFloating():\r\n            self.dock.setFloating(False)\r\n            self.dock.raise_()\r\n        else:\r\n            self.dock.setFloating(True)\r\n            screen = QtWidgets.QApplication.primaryScreen().availableGeometry()\r\n            center_x = screen.center().x() - self.dock.width() // 2\r\n            center_y = screen.center().y() - self.dock.height() // 2\r\n            self.dock.move(center_x, center_y)\r\n\r\n    def eventFilter(self, obj, event):\r\n        if event.type() == QtCore.QEvent.MouseButtonDblClick:\r\n            return True\r\n        return super().eventFilter(obj, event)\r\n\r\n    def resizeEvent(self, event):\r\n        super().resizeEvent(event)\r\n        self.update_title()\r\n\r\n    def update_title(self):\r\n        fm = self.fontMetrics()\r\n        available_width = max(40, self.width() - 90)\r\n        elided = fm.elidedText(self.dock.windowTitle(), Qt.ElideRight, available_width)\r\n        self.title_label.setText(elided)\r\n        self.title_label.setToolTip(self.dock.windowTitle())\r\n\r\n    def apply_style(self):\r\n        bg     = self.style.get(\"background\", \"#E0E0E0\")\r\n        border = self.style.get(\"border\", \"#888888\")\r\n        text   = self.style.get(\"text\", \"black\")\r\n        pad_top = self.style.get(\"padding_top\", 2)\r\n        pad_left = self.style.get(\"padding_left\", 4)\r\n\r\n        self.setStyleSheet(f\"\"\"\r\n            CustomDockTitleBar {{\r\n                background-color: {bg};\r\n                border-bottom: 1px solid {border};\r\n            }}\r\n            QLabel {{\r\n                color: {text};\r\n                padding-top: {pad_top}px;\r\n                padding-left: {pad_left}px;\r\n                background-color: transparent;\r\n            }}\r\n            QPushButton {{\r\n                background-color: transparent;\r\n                border: none;\r\n            }}\r\n            QPushButton:hover {{\r\n                background-color: {border};\r\n            }}\r\n        \"\"\")\r\n\r\nclass MainApp(QtWidgets.QMainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setWindowTitle(\"HyperdocApp\")\r\n        self.resize(1200, 800)\r\n        self.setCentralWidget(QtWidgets.QWidget())\r\n\r\n        # if getattr(sys, 'frozen', False): # pynstaller case\r\n        #     self.BASE_DIR = sys._MEIPASS\r\n        # else :\r\n        #     self.BASE_DIR = os.path.dirname(os.path.dirname(__file__))\r\n\r\n        if getattr(sys, 'frozen', False):\r\n            # Exécution depuis l’exécutable PyInstaller\r\n            self.BASE_DIR = sys._MEIPASS\r\n        else:\r\n            # Exécution en tant que script Python\r\n            CURRENT_FILE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n            self.BASE_DIR = os.path.abspath(os.path.join(CURRENT_FILE_DIR, \"..\"))\r\n\r\n        self.ICONS_DIR = os.path.join(self.BASE_DIR,\"Hypertool\",\"interface\", \"icons\")\r\n        # self.ICONS_DIR = os.path.join(self.BASE_DIR, \"Hypertool/interface/icons\")\r\n        icon_main= \"Hyperdoc_logo_transparente_CIMLab.png\"\r\n        self.setWindowIcon(QIcon(os.path.join(self.ICONS_DIR,icon_main)))\r\n\r\n        # perso style title bar\r\n        self.title_bar_style = {\r\n            \"background\": \"#E0E0E0\",  # slightly darker than window background\r\n            \"border\": \"#888888\",  # border color\r\n            \"text\": \"black\",  # text color\r\n            \"padding_top\": 2,\r\n            \"padding_left\": 4\r\n        }\r\n\r\n\r\n        # make left docks with meta and file browser\r\n        # self.file_browser_dock = self._add_file_browser_dock() # left dock with file browser\r\n        self.meta_dock=self._add_dock(\"Metadata\",   MetadataTool,     QtCore.Qt.LeftDockWidgetArea) # add meta to left dock\r\n        # self.tabifyDockWidget(self.file_browser_dock, self.meta_dock)\r\n        # self.meta_dock.raise_() # raise meta and \"hide in tab\" file browser\r\n        self.meta_dock.setVisible(False) # raise meta and \"hide in tab\" file browser\r\n\r\n\r\n        # make \"central\" dock with visuals tools\r\n        self.data_viz_dock =self._add_dock(\"Data Visualization\", Data_Viz_Window,  QtCore.Qt.RightDockWidgetArea)\r\n        self.reg_dock=self._add_dock(\"Registration\",   RegistrationApp,     QtCore.Qt.RightDockWidgetArea)\r\n        self.gt_dock=self._add_dock(\"Ground Truth\",   GroundTruthWidget,     QtCore.Qt.RightDockWidgetArea)\r\n        self.tabifyDockWidget(self.reg_dock, self.gt_dock)\r\n        self.tabifyDockWidget(self.reg_dock, self.data_viz_dock)\r\n        self.data_viz_dock.raise_()\r\n\r\n        # Tool menu\r\n        view = self.menuBar().addMenu(\"Tools\")\r\n        for dock in self.findChildren(QtWidgets.QDockWidget):\r\n            view.addAction(dock.toggleViewAction())\r\n\r\n        # ─── Toolbar “Quick Tools” ───────────────────────────────────────────\r\n        self.toolbar = self.addToolBar(\"Quick Tools\")\r\n        self.toolbar.setIconSize(QSize(48, 48))  # Taille des icônes\r\n        self.toolbar.setToolButtonStyle(Qt.ToolButtonIconOnly)  #ToolButtonIconOnly ou TextUnderIcon)\r\n\r\n        # act_file = self.onToolButtonPress(self.file_browser_dock,icon_name=\"file_browser_icon.png\",tooltip=\"File Browser\")\r\n        act_met = self.onToolButtonPress(self.meta_dock, \"metadata_icon.png\", \"Metadata\")\r\n        self.toolbar.addSeparator()\r\n        act_data = self.onToolButtonPress(self.data_viz_dock, \"icon_data_viz.svg\", \"Data Vizualisation\")\r\n        act_reg = self.onToolButtonPress(self.reg_dock, \"registration_icon.png\", \"Registration\")\r\n        act_gt =self.onToolButtonPress(self.gt_dock, \"GT_icon_1.png\", \"Ground Truth\")\r\n\r\n        self.toolbar.addSeparator()\r\n\r\n        # Cubes \"list\"\r\n        self.cubeBtn = QtWidgets.QToolButton(self)\r\n        self.cubeBtn.setText(\"Cubes list   \")\r\n        self.cubeBtn.setPopupMode(QtWidgets.QToolButton.InstantPopup)\r\n        # self.cubeBtn.setStyleSheet(\"QToolButton::menu-indicator { image: none; }\")\r\n        self.toolbar.addWidget(self.cubeBtn)\r\n\r\n        # Création du menu hiérarchique\r\n        self.cubeMenu = QtWidgets.QMenu(self)\r\n        self.cubeBtn.setMenu(self.cubeMenu)\r\n\r\n        # Hypercube Manager\r\n        self.hypercube_manager = HypercubeManager()\r\n        reg_widget = self.reg_dock.widget()\r\n        reg_widget.alignedCubeReady.connect(self.hypercube_manager.addCube)  # get signal from register tool\r\n\r\n        # Action Add File in list of cubes\r\n        act_add = QAction(\"Open new cube(s)\", self)\r\n        act_add.triggered.connect(self._on_add_cube)\r\n        self.toolbar.addAction(act_add)\r\n\r\n        # Mise à jour du menu à chaque modification\r\n        self.hypercube_manager.cubesChanged.connect(self._update_cube_menu)\r\n        self._update_cube_menu(self.hypercube_manager.paths)\r\n\r\n        # act_save = QAction(\"Save Cube to Disc\", self)\r\n        # act_save.setToolTip(\"Save cube from loaded cubes\")\r\n        # act_save.triggered.connect(self.save_cube)\r\n        # self.toolbar.addAction(act_save)\r\n\r\n        # Save with menu\r\n        self.saveBtn = QtWidgets.QToolButton(self)\r\n        self.saveBtn.setText(\"Save Cube\")\r\n        # self.saveBtn.setIcon(QIcon(os.path.join(self.ICONS_DIR, \"save_icon.png\")))\r\n        # todo : add icon for save cube\r\n        self.saveBtn.setPopupMode(QtWidgets.QToolButton.InstantPopup)\r\n        self.saveMenu = QtWidgets.QMenu(self)\r\n        self.saveBtn.setMenu(self.saveMenu)\r\n        self.toolbar.addWidget(self.saveBtn)\r\n\r\n        # update if list modified\r\n        self.hypercube_manager.cubesChanged.connect(self._update_save_menu)\r\n        self._update_save_menu(self.hypercube_manager.paths)\r\n\r\n        spacer = QWidget()\r\n        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\r\n        self.toolbar.addWidget(spacer)\r\n\r\n        act_suggestion = QAction(\"SUGGESTIONS\", self)\r\n        act_suggestion.setToolTip(\"Add a suggestion for the developper\")\r\n        act_suggestion.triggered.connect(self.open_suggestion_box)\r\n        self.toolbar.addAction(act_suggestion)\r\n\r\n        #### connect tools with hypercube manager for managing changes in cubeInfoTemp\r\n        self.meta_dock.widget().metadataChanged.connect(self.hypercube_manager.updateMetadata)\r\n\r\n        self.reg_dock.widget().cube_saved.connect(self.hypercube_manager.add_or_update_cube)\r\n        self.gt_dock.widget().cube_saved.connect(self.hypercube_manager.add_or_update_cube)\r\n\r\n        self.hypercube_manager.metadataUpdated.connect(self.meta_dock.widget().on_metadata_updated)\r\n        self.hypercube_manager.metadataUpdated.connect(self.reg_dock.widget().load_cube_info)\r\n        self.hypercube_manager.metadataUpdated.connect(self.gt_dock.widget().load_cube_info)\r\n        # self.hypercube_manager.metadataUpdated.connect(self.data_viz_dock.widget().load_cube_info)\r\n\r\n        self.reg_dock.widget().cubeLoaded.connect(lambda fp: self._on_tool_loaded_cube(fp, self.reg_dock.widget()))\r\n        self.meta_dock.widget().cubeLoaded.connect(lambda fp: self._on_tool_loaded_cube(fp, self.meta_dock.widget()))\r\n        # self.data_viz_dock.widget().cubeLoaded.connect(lambda fp: self._on_tool_loaded_cube(fp, self.data_viz_dock.widget()))\r\n        self.gt_dock.widget().cubeLoaded.connect(lambda fp: self._on_tool_loaded_cube(fp, self.gt_dock.widget()))\r\n\r\n        # visible docks of rightDock take all space possible\r\n\r\n        self.centralWidget().hide()\r\n        # self.showMaximized()\r\n\r\n\r\n    def open_suggestion_box(self):\r\n        self.suggestion_window = SuggestionWidget()\r\n        self.suggestion_window.show()\r\n\r\n    def addOrSyncCube(self, filepath: str) -> CubeInfoTemp:\r\n        \"\"\"\r\n        Check if the cube is already in the manager.\r\n        If so, return the existing CubeInfoTemp.\r\n        Otherwise, load it from disk, add it to the list, and return it.\r\n        \"\"\"\r\n        index = self.getIndexFromPath(filepath)\r\n        if index != -1:\r\n            return self._cubes[index]\r\n\r\n        # Cube is not in the list → load and add it\r\n        ci = CubeInfoTemp(filepath=filepath)\r\n        hc = Hypercube(filepath=filepath, cube_info=ci, load_init=True)\r\n        ci = hc.cube_info\r\n        self._cubes.append(ci)\r\n        self.cubesChanged.emit(self.paths)\r\n        return ci\r\n\r\n    def onToolButtonPress(self, dock, icon_name, tooltip):\r\n        # act = dock.toggleViewAction()\r\n        # act.setIcon(QIcon(os.path.join(self.ICONS_DIR, icon_name)))\r\n\r\n        print(os.path.join(self.ICONS_DIR, icon_name))\r\n        act = QAction(QIcon(os.path.join(self.ICONS_DIR, icon_name)), tooltip, self)\r\n        act.setToolTip(tooltip)\r\n        act.setCheckable(False)\r\n        act.triggered.connect(lambda checked, d=dock: (d.show(), d.raise_()))\r\n        # act.toggled.connect(\r\n        #     lambda visible, d=dock: QTimer.singleShot(0, d.raise_) if visible else None\r\n        # )\r\n        self.toolbar.addAction(act)\r\n        return act\r\n\r\n    def _on_file_browser_accepted(self, updated_ci: CubeInfoTemp):\r\n        '''\r\n        get OK pressed button of browser with\r\n        '''\r\n        self.hypercube_manager.cubesChanged.emit(self.hypercube_manager.paths)\r\n\r\n    def _open_file_browser_for_index(self, index: int):\r\n        \"\"\"\r\n        Injecte le CubeInfoTemp existant dans le widget,\r\n        pré-remplit les champs, recharge l'arbre et l'affiche.\r\n        \"\"\"\r\n        ci     = self.hypercube_manager.getCubeInfo(index)\r\n        widget = self.file_browser_dock.widget()\r\n\r\n        # 1) Ré-associe l'objet métier et le filepath\r\n        widget.cube_info = ci\r\n        widget.filepath  = ci.filepath\r\n\r\n        # 2) Pré-remplissage des QLineEdit\r\n        widget.le_cube.setText       (ci.data_path       or \"\")\r\n        widget.le_wl.setText         (ci.wl_path         or \"\")\r\n        widget.le_meta.setText       (ci.metadata_path   or \"\")\r\n        # comboBox_channel_wl : 0 = First, 1 = Other (à ajuster)\r\n        widget.comboBox_channel_wl.setCurrentIndex(0 if ci.wl_trans else 1)\r\n\r\n        # 3) Rebuild de l'arbre HDF5/MAT\r\n        widget._load_file()\r\n\r\n        # 4) Affichage du dock\r\n        self.file_browser_dock.show()\r\n        widget.show()\r\n\r\n    def _add_dock(self, title, WidgetClass, area):\r\n        widget = WidgetClass(parent=self)\r\n        dock   =  QtWidgets.QDockWidget(title, self)\r\n        # dock.setTitleBarWidget(CustomDockTitleBar(dock))\r\n        dock.setTitleBarWidget(CustomDockTitleBar(dock, style=self.title_bar_style))\r\n        dock.setWidget(widget)\r\n        self.addDockWidget(area, dock)\r\n        return dock\r\n\r\n    def _add_file_browser_dock(self) -> QtWidgets.QDockWidget:\r\n        \"\"\"\r\n        Initialise le File Browser avec un CubeInfoTemp vide,\r\n        connecte son signal accepted, puis l'ajoute en dock.\r\n        \"\"\"\r\n        # 1) crée un CubeInfoTemp vierge\r\n        ci = CubeInfoTemp(filepath=None)\r\n\r\n        # 2) instancie le widget\r\n        widget = HDF5BrowserWidget(\r\n            cube_info=ci,\r\n            filepath=None,\r\n            parent=self,\r\n            closable=True\r\n        )\r\n        # 3) connecte le signal accepted\r\n        widget.accepted.connect(self._on_file_browser_accepted)\r\n        widget.rejected.connect(lambda: None)  # si tu veux réagir à l'annulation\r\n\r\n        # 4) création du dock\r\n        dock = QtWidgets.QDockWidget(\"File Browser\", self)\r\n        dock.setWidget(widget)\r\n        dock.setTitleBarWidget(CustomDockTitleBar(dock, style=self.title_bar_style))\r\n        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, dock)\r\n        return dock\r\n\r\n    def _update_save_menu(self, paths):\r\n        \"\"\"Met à jour le menu déroulant du bouton Save Cube avec tous les cubes chargés.\"\"\"\r\n        self.saveMenu.clear()\r\n        for idx, path in enumerate(paths):\r\n            action = QtWidgets.QAction(os.path.basename(path), self)\r\n            action.triggered.connect(lambda checked, i=idx: self.save_cube(i))\r\n            self.saveMenu.addAction(action)\r\n\r\n    def save_cube(self,index=None):\r\n        ci     = self.hypercube_manager.getCubeInfo(index)\r\n\r\n        ans=QMessageBox.question(self,'Save modification',f\"Sure to save modification on disc for the cube :\\n{ci.filepath}\", QMessageBox.Yes | QMessageBox.Cancel)\r\n        if ans==QMessageBox.Cancel:\r\n            return\r\n\r\n        cube=Hypercube(filepath=ci.filepath,metadata=ci.metadata_temp)\r\n        cube.save(filepath=ci.filepath)\r\n        print(f\"cube saves as {ci.filepath}\")\r\n\r\n    def _on_add_cube(self,paths=None):\r\n        if not isinstance(paths, (list, tuple)) or len(paths) == 0:\r\n            paths, _ = QtWidgets.QFileDialog.getOpenFileNames(\r\n                self,\r\n                \"Select Hypercubes\",\r\n                \"\",\r\n                \"All files (*.*)\"\r\n            )\r\n\r\n        if not paths:\r\n            return\r\n\r\n        for path in paths:\r\n            ci=CubeInfoTemp(filepath=path)\r\n            self.hypercube_manager.addCube(ci)\r\n\r\n        if len(paths)==1:\r\n            qm = QMessageBox()\r\n            ans = qm.question(self, 'Cube loaded',\r\n                              \"Do you want to send the loaded cube to the tools ?\",\r\n                              qm.Yes | qm.No)\r\n            if ans==qm.Yes:\r\n                try:\r\n                    index = self.hypercube_manager.getIndexFromPath(paths[0])\r\n                    if index != -1:\r\n                        self._send_to_all(index)\r\n                except:\r\n                    QMessageBox.warning(self,'Cube not loaded',\r\n                              \"Cube not loaded. Check format.\")\r\n\r\n    def _on_get_cube_info(self, insert_index):\r\n        # 1) Récupère le CubeInfoTemp déjà présent\r\n        ci = self.hypercube_manager._cubes[insert_index]\r\n        filepath = ci.filepath\r\n        if not filepath:\r\n            return\r\n\r\n        # 2) Recharge les infos via Hypercube en mode init\r\n        hc = Hypercube(filepath=filepath, cube_info=ci, load_init=True)\r\n        # Optionnel : mettre à jour la forme des données pour affichage\r\n        ci.data_shape = getattr(hc.data, 'shape', None)\r\n\r\n        # 3) Nettoie l’objet lourd pour ne pas garder de data en mémoire\r\n        hc.reinit_cube()\r\n        del hc\r\n\r\n        # 4) Notifie la mise à jour du manager/UI\r\n        self.hypercube_manager.cubesChanged.emit(self.hypercube_manager.paths)\r\n\r\n    def _send_to_metadata(self,index):\r\n        widget = self.meta_dock.widget()\r\n        ci     = self.hypercube_manager.getCubeInfo(index)\r\n        widget.set_cube_info(ci)\r\n        widget.update_combo_meta(init=True)\r\n\r\n    def _send_to_gt(self,index):\r\n        widget = self.gt_dock.widget()\r\n        ci = self.hypercube_manager.getCubeInfo(index)\r\n        widget.load_cube(cube_info=ci)\r\n\r\n    def _send_to_data_viz(self,index):\r\n        widget = self.data_viz_dock.widget()\r\n        ci = self.hypercube_manager.getCubeInfo(index)\r\n        print(ci.filepath)\r\n        widget.open_hypercubes_and_GT(filepath=ci.filepath)\r\n\r\n    def _send_to_all(self,index):\r\n        self._send_to_data_viz(index)\r\n        self._send_to_gt(index)\r\n        self._send_to_metadata(index)\r\n        self.reg_dock.widget().load_cube(1, self.hypercube_manager.paths[index])\r\n\r\n    def _on_tool_loaded_cube(self, filepath, widget):\r\n        index = self.hypercube_manager.getIndexFromPath(filepath)\r\n        if index != -1:\r\n            ci = self.hypercube_manager.getCubeInfo(index)\r\n            widget.load_cube_info(ci)\r\n        else:\r\n            ci=Hypercube(filepath,load_init=True).cube_info\r\n            self.hypercube_manager.addCube(ci)\r\n\r\n    def _update_cube_menu(self, paths):\r\n        \"\"\"Met à jour le menu de cubes avec sous-menus et actions fonctionnelles.\"\"\"\r\n        self.cubeMenu.clear()\r\n        for idx, path in enumerate(paths):\r\n            # Sous-menu pour chaque cube\r\n            sub = QtWidgets.QMenu(path, self)\r\n            # Envoyer dant tous les docs\r\n            act_all = QtWidgets.QAction(\"Send to All tools\", self)\r\n            act_all.triggered.connect(lambda checked, i=idx: self._send_to_all(i))\r\n            sub.addAction(act_all)\r\n\r\n            # Séparateur\r\n            sub.addSeparator()\r\n\r\n            # Envoyer au dock viz\r\n            act_viz = QtWidgets.QAction(\"Send to Vizualisation tool\", self)\r\n            act_viz.triggered.connect(lambda checked, i=idx: self._send_to_data_viz(i))\r\n            sub.addAction(act_viz)\r\n            # Envoyer au dock reg\r\n            menu_load_reg=QtWidgets.QMenu(\"Send to Register Tool\", sub)\r\n            act_fix = QtWidgets.QAction(\"Fixed Cube\", self)\r\n            act_fix.triggered.connect(\r\n                lambda _, i=idx: self.reg_dock.widget().load_cube(0,self.hypercube_manager.paths[i])\r\n            )\r\n            menu_load_reg.addAction(act_fix)\r\n            # Action Moving\r\n            act_mov = QtWidgets.QAction(\"Moving Cube\", self)\r\n            act_mov.triggered.connect(\r\n                lambda _, i=idx: self.reg_dock.widget().load_cube(1,self.hypercube_manager.paths[i])\r\n            )\r\n            menu_load_reg.addAction(act_mov)\r\n            sub.addMenu(menu_load_reg)\r\n            # Envoyer au dock file browser\r\n            # act_browser = QtWidgets.QAction(\"Send to File Browser\", self)\r\n            # act_browser.triggered.connect(lambda checked, i=idx: self._open_file_browser_for_index(i))\r\n            # sub.addAction(act_browser)\r\n\r\n            # Envoyer au dock metadata\r\n            act_meta = QtWidgets.QAction(\"Send to Metadata\", self)\r\n            act_meta.triggered.connect(lambda checked, i=idx: self._send_to_metadata(i))\r\n            sub.addAction(act_meta)\r\n\r\n            # Envoyer au dock gt\r\n            act_gt = QtWidgets.QAction(\"Send to GT\", self)\r\n            act_gt.triggered.connect(lambda checked, i=idx: self._send_to_gt(i))\r\n            sub.addAction(act_gt)\r\n\r\n            # Séparateur\r\n            sub.addSeparator()\r\n\r\n            # Get Cube Info from File”\r\n            # act_get_info = QtWidgets.QAction(\"Get cube_info from file…\", self)\r\n            # act_get_info.triggered.connect(lambda _, i=idx: self._on_get_cube_info(i))\r\n            # sub.addAction(act_get_info)\r\n\r\n            # Save Cube\r\n            act_save = QtWidgets.QAction(\"Save modification to disc\", self)\r\n            act_save.triggered.connect(lambda checked, i=idx: self.save_cube(i))\r\n            sub.addAction(act_save)\r\n\r\n            # Séparateur\r\n            sub.addSeparator()\r\n            # Supprimer de la liste\r\n            act_rm = QtWidgets.QAction(\"Remove from list\", self)\r\n            act_rm.triggered.connect(lambda checked, i=idx: self.hypercube_manager.removeCube(i))\r\n            sub.addAction(act_rm)\r\n            # Ajouter sous-menu au menu principal\r\n            self.cubeMenu.addMenu(sub)\r\n\r\n# Configure error logging\r\n# Get absolute path of log folder (support PyInstaller frozen mode)\r\nif getattr(sys, 'frozen', False):\r\n    base_path = sys._MEIPASS\r\n    exe_dir = os.path.dirname(sys.executable)\r\nelse:\r\n    base_path = os.path.dirname(__file__)\r\n    exe_dir = base_path\r\n\r\nlog_dir = os.path.join(exe_dir, \"log\")\r\nos.makedirs(log_dir, exist_ok=True)  # ← crée le dossier s’il n’existe pas\r\n\r\nlogging.basicConfig(\r\n    filename=os.path.join(log_dir, \"error.log\"),\r\n    level=logging.ERROR,\r\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"\r\n)\r\n\r\nsuggestion_logger = logging.getLogger(\"suggestion_logger\")\r\nsuggestion_handler = logging.FileHandler(os.path.join(log_dir, \"suggestions.log\"))\r\nsuggestion_handler.setFormatter(logging.Formatter(\"%(asctime)s - %(message)s\"))\r\nsuggestion_logger.addHandler(suggestion_handler)\r\nsuggestion_logger.setLevel(logging.INFO)\r\n\r\nclass SuggestionWidget(QWidget):\r\n    \"\"\" Window to get suggestion of users \"\"\"\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setWindowTitle(\"Suggestion Box\")\r\n        self.setMinimumWidth(300)\r\n\r\n        layout = QVBoxLayout()\r\n\r\n        layout.addWidget(QLabel(\"Write your suggestion or feedback below:\"))\r\n        self.text_edit = QTextEdit()\r\n        layout.addWidget(self.text_edit)\r\n\r\n        self.submit_button = QPushButton(\"Submit\")\r\n        self.submit_button.clicked.connect(self.submit_suggestion)\r\n        layout.addWidget(self.submit_button)\r\n\r\n        self.setLayout(layout)\r\n\r\n    def submit_suggestion(self):\r\n        text = self.text_edit.toPlainText().strip()\r\n        if text:\r\n            suggestion_logger.info(text)\r\n            self.close()\r\n            QMessageBox.information(None, \"Thank you\",\r\n                                    \"Suggestion has been logged in 'suggestions.log'.\")  # show to user that comment has been taken into account\r\n        else:\r\n            self.submit_button.setText(\"Please write something!\")\r\n\r\nclass ErrorDialog(QDialog):\r\n    \"\"\" Window to open in development phase to describe exception seen\"\"\"\r\n    def __init__(self, error_text):\r\n        super().__init__()\r\n        self.setWindowTitle(\"Unexpected Error\")\r\n        self.setMinimumWidth(400)\r\n\r\n        layout = QVBoxLayout()\r\n\r\n        layout.addWidget(QLabel(\"An unexpected error occurred:\"))\r\n        layout.addWidget(QLabel(error_text))\r\n\r\n        layout.addWidget(QLabel(\"If you wish, describe what you were doing before the error:\"))\r\n        self.user_input = QTextEdit()\r\n        layout.addWidget(self.user_input)\r\n\r\n        self.btn_send = QPushButton(\"OK\")\r\n        self.btn_send.clicked.connect(self.accept)\r\n        layout.addWidget(self.btn_send)\r\n\r\n        self.setLayout(layout)\r\n\r\n    def get_user_comment(self):\r\n        return self.user_input.toPlainText()\r\n\r\ndef excepthook(exc_type, exc_value, exc_traceback):\r\n    \"\"\"Capture exception and send it to log file, and show warning message\"\"\"\r\n    error_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))\r\n\r\n    logging.error(\"Uncaught exception:\\n%s\", error_msg) # log error\r\n\r\n    # Show dialog debug to the user\r\n    dlg = ErrorDialog(str(exc_value))\r\n    dlg.exec_()\r\n\r\n    user_comment = dlg.get_user_comment()\r\n\r\n    if user_comment.strip():\r\n        logging.error(\"User comment: %s\", user_comment)\r\n\r\n    QMessageBox.information(None, \"Log Saved\", \"Error has been logged in 'error.log'.\") # show to user that comment has been taken into account\r\n\r\ndef update_font(_app,width=None,_font=\"Segoe UI\",):\r\n    global main\r\n\r\n    if not width:\r\n        screen = _app.primaryScreen()\r\n        screen_size = screen.size()\r\n        screen_width = screen_size.width()\r\n\r\n    else:\r\n        screen_width=width\r\n\r\n    if screen_width < 1280:\r\n        font_size = 7\r\n    elif screen_width < 1920:\r\n        font_size = 8\r\n    else:\r\n        font_size = 9\r\n\r\n    _app.setFont(QFont(_font, font_size))\r\n    plt.rcParams.update({\"font.size\": font_size + 3, \"font.family\": _font})\r\n\r\ndef check_resolution_change():\r\n    \"\"\" Check if resolution change to adapt font size \"\"\"\r\n    global last_width  # On garde la dernière largeur connue\r\n    center_point = main.geometry().center()\r\n    screen = app.screenAt(center_point)\r\n\r\n    if screen is not None:\r\n        current_width = screen.size().width()\r\n        if current_width != last_width:\r\n            update_font(app, current_width)\r\n            last_width = current_width\r\n    else:\r\n        print(\"[⚠\uFE0F] Fenêtre en dehors de tout écran détecté. Résolution inchangée.\")\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    sys.excepthook = excepthook #set the exception handler\r\n\r\n    app = QtWidgets.QApplication(sys.argv)\r\n\r\n    update_font(app)\r\n    apply_fusion_border_highlight(app)\r\n\r\n    main = MainApp()\r\n    main.show()\r\n\r\n    try:\r\n        import matlab.engine\r\n\r\n        print(\" [ :-) ] matlab.engine loaded with success\")\r\n    except Exception as e:\r\n        print(f\" [ !!! ] Failed to load matlab.engine: {e}\")\r\n\r\n    # Timer for screen resolution check\r\n    last_width = app.primaryScreen().size().width()\r\n    timer = QTimer()\r\n    timer.timeout.connect(check_resolution_change)\r\n    timer.start(500)  # Vérifie toutes les 500 ms\r\n    sys.exit(app.exec_())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MainWindow.py b/MainWindow.py
--- a/MainWindow.py	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/MainWindow.py	(date 1752499916183)
@@ -4,7 +4,6 @@
 # pyinstaller  --noconfirm --noconsole --exclude-module tensorflow --exclude-module torch --exclude-module matlab --icon="interface/icons/hyperdoc_logo_transparente.ico" --add-data "interface/icons:Hypertool/interface/icons" --add-data "ground_truth/Materials labels and palette assignation - Materials_labels_palette.csv:ground_truth"  --add-data "data_vizualisation/Spatially registered minicubes equivalence.csv:data_vizualisation"  MainWindow.py
 # C:\Envs\py37test\Scripts\activate
 
-
 # GUI Qt
 from PyQt5 import QtWidgets, QtCore
 from PyQt5.QtCore import QTimer,QSize, Qt
@@ -194,11 +193,6 @@
         self.resize(1200, 800)
         self.setCentralWidget(QtWidgets.QWidget())
 
-        # if getattr(sys, 'frozen', False): # pynstaller case
-        #     self.BASE_DIR = sys._MEIPASS
-        # else :
-        #     self.BASE_DIR = os.path.dirname(os.path.dirname(__file__))
-
         if getattr(sys, 'frozen', False):
             # Exécution depuis l’exécutable PyInstaller
             self.BASE_DIR = sys._MEIPASS
@@ -221,7 +215,6 @@
             "padding_left": 4
         }
 
-
         # make left docks with meta and file browser
         # self.file_browser_dock = self._add_file_browser_dock() # left dock with file browser
         self.meta_dock=self._add_dock("Metadata",   MetadataTool,     QtCore.Qt.LeftDockWidgetArea) # add meta to left dock
@@ -737,7 +730,7 @@
 
 if __name__ == "__main__":
 
-    sys.excepthook = excepthook #set the exception handler
+    # sys.excepthook = excepthook #set the exception handler
 
     app = QtWidgets.QApplication(sys.argv)
 
Index: ground_truth/ground_truth_tool.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># cd C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\r\n# python -m PyQt5.uic.pyuic -o registration_window.py registration_window.ui\r\n# pyinstaller  --exclude-module tensorflow --exclude-module torch --icon=\"GT_icon.ico\" --add-data \"ground_truth/Materials labels and palette assignation - Materials_labels_palette.csv;ground_truth\"  ground_truth_tool.py\r\n# opts   --noconsole --onefile\r\n\r\n# Gnl\r\nimport os\r\nimport sys\r\n\r\n## GUI\r\nfrom PyQt5 import QtCore\r\nfrom PyQt5.QtGui    import QPixmap, QPainter, QColor, QPen\r\nfrom PyQt5.QtWidgets import ( QSplitter,\r\n    QApplication,QSizePolicy, QGraphicsScene, QGraphicsPixmapItem,QRubberBand,QWidget, QFileDialog, QMessageBox,QInputDialog , QSplitter,QGraphicsView,QLabel,\r\n)\r\nfrom PyQt5.QtCore import Qt, QEvent, QRect, QRectF, QPoint, QSize\r\n\r\n# Graphs\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.widgets import SpanSelector\r\nfrom matplotlib import colormaps\r\nfrom matplotlib.path import Path\r\n\r\n# Maths\r\nimport numpy as np\r\nimport cv2\r\nfrom scipy.spatial import distance as spdist\r\n\r\n# Intern\r\nfrom hypercubes.hypercube import Hypercube,CubeInfoTemp\r\nfrom ground_truth.GT_table_viz import LabelWidget\r\nfrom ground_truth.ground_truth_window import Ui_GroundTruthWidget\r\nfrom interface.some_widget_for_interface import LoadingDialog\r\n\r\n\r\n# todo : give GT labels names and number for RGB code ? -> save GT in new dataset of file + png\r\n# todo : link to cube_info (read and fill)\r\n# todo : actualize GT_cmp if label added OR load from default GT_table\r\n# todo : check if cube already hace a GT map done (looking at GT labels for example)\r\n# todo : upload GT_cmap from csv ?\r\n\r\n## GT colors\r\nGT_cmap=np.array([[0.        , 1.        , 0.24313725, 0.22745098, 0.37254902,\r\n        0.26666667, 0.05882353, 0.31764706, 0.36078431, 0.34509804,\r\n        0.5372549 , 0.93333333, 0.9254902 , 0.90196078, 0.74901961,\r\n        0.7372549 , 0.6745098 , 1.        , 0.88627451, 0.14901961,\r\n        0.11764706, 0.2745098 , 0.        , 0.34901961, 0.03529412,\r\n        0.2       , 0.46666667, 1.        , 0.50196078, 0.14117647,\r\n        0.        , 0.07843137, 0.50588235, 0.71372549, 0.83921569,\r\n        0.14509804, 0.        , 0.77647059, 0.99215686, 0.99215686,\r\n        0.16078431, 0.83137255, 0.70588235, 0.63137255, 0.9254902 ,\r\n        0.98431373, 0.90196078, 0.63137255, 0.61568627, 0.31764706,\r\n        0.92156863, 0.90980392, 0.97254902, 0.96470588, 0.83529412,\r\n        0.79215686, 0.43529412, 0.79607843, 0.70588235, 0.76078431,\r\n        0.94117647, 0.23529412, 0.        , 0.20784314, 0.92156863,\r\n        0.69411765, 0.6745098 , 0.63529412, 0.92156863, 0.83137255,\r\n        0.68627451, 0.60784314, 0.6745098 , 0.52941176, 0.45098039,\r\n        0.29411765, 0.31372549, 0.78431373, 0.76470588, 0.83137255,\r\n        0.83137255, 0.45098039, 1.        , 0.29411765, 0.1372549 ,\r\n        0.07843137, 0.12941176, 0.88235294, 0.77254902, 0.74901961,\r\n        0.71372549, 0.88235294, 0.70980392, 0.6       , 0.6745098 ,\r\n        0.47843137, 0.25490196, 0.54901961, 0.35294118, 0.29411765,\r\n        0.75686275, 0.83137255, 0.63529412, 0.90588235, 0.50980392,\r\n        0.71764706, 0.90588235, 0.68627451, 0.60784314, 0.92156863,\r\n        0.97647059, 0.86666667, 0.33333333, 0.84313725, 0.14509804,\r\n        0.06666667, 0.2627451 , 0.98431373, 0.90588235, 0.61568627,\r\n        0.15686275, 0.45098039, 0.1372549 , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.49019608, 0.09803922,\r\n        0.8627451 , 0.74509804, 0.58823529, 0.39215686, 0.19607843],\r\n       [0.        , 1.        , 0.14901961, 0.1254902 , 0.24705882,\r\n        0.16470588, 0.05882353, 0.14509804, 0.24705882, 0.2745098 ,\r\n        0.54901961, 0.85098039, 0.83921569, 0.9372549 , 0.85882353,\r\n        0.74509804, 0.78823529, 0.83921569, 0.8       , 0.21176471,\r\n        0.1372549 , 0.11764706, 0.25490196, 0.4745098 , 0.54117647,\r\n        0.39607843, 0.29411765, 0.56078431, 0.10196078, 0.58431373,\r\n        0.40392157, 0.21176471, 0.77647059, 0.32941176, 0.4745098 ,\r\n        0.17647059, 0.34901961, 0.17254902, 0.50980392, 0.49411765,\r\n        0.70196078, 0.80392157, 0.75686275, 0.20392157, 0.74117647,\r\n        0.85098039, 0.8745098 , 0.38823529, 0.44313725, 0.36078431,\r\n        0.16470588, 0.84705882, 0.70588235, 0.76470588, 0.70196078,\r\n        0.7372549 , 0.21176471, 0.70196078, 0.54509804, 0.64705882,\r\n        0.94117647, 0.78431373, 0.2745098 , 0.09411765, 0.92156863,\r\n        0.64705882, 0.25490196, 0.29411765, 0.56078431, 0.71764706,\r\n        0.60784314, 0.67843137, 0.75686275, 0.49803922, 0.41176471,\r\n        0.34117647, 0.8627451 , 0.7254902 , 0.83529412, 0.95294118,\r\n        0.41176471, 0.5372549 , 0.71764706, 0.7254902 , 0.62745098,\r\n        0.35294118, 0.17254902, 0.96078431, 0.68627451, 0.16470588,\r\n        0.21568627, 0.63921569, 0.55294118, 0.52156863, 0.75294118,\r\n        0.64705882, 0.29411765, 0.41176471, 0.21568627, 0.78431373,\r\n        0.67843137, 0.90980392, 0.80392157, 0.32156863, 0.37254902,\r\n        0.52156863, 0.7254902 , 0.25490196, 0.68627451, 0.84313725,\r\n        0.85098039, 0.45098039, 0.82352941, 0.41176471, 0.38823529,\r\n        0.54509804, 0.78039216, 0.77254902, 0.69411765, 0.43921569,\r\n        0.30980392, 0.66666667, 0.22352941, 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.49019608, 0.09803922,\r\n        0.8627451 , 0.74509804, 0.58823529, 0.39215686, 0.19607843],\r\n       [0.        , 1.        , 0.25490196, 0.14509804, 0.14117647,\r\n        0.11764706, 0.05882353, 0.12941176, 0.25882353, 0.14509804,\r\n        0.56470588, 0.78039216, 0.7254902 , 0.80392157, 0.78039216,\r\n        0.56862745, 0.80392157, 0.79215686, 0.81960784, 0.15686275,\r\n        0.15686275, 0.2       , 0.54901961, 0.63921569, 0.79607843,\r\n        0.56862745, 0.26666667, 0.49019608, 0.25098039, 0.74509804,\r\n        0.6       , 0.28627451, 0.88235294, 0.14117647, 0.32156863,\r\n        0.48627451, 0.25098039, 0.1254902 , 0.21176471, 0.        ,\r\n        0.82352941, 0.8       , 0.        , 0.19607843, 0.        ,\r\n        0.38431373, 0.78823529, 0.37254902, 0.1254902 , 0.58039216,\r\n        0.07843137, 0.70980392, 0.        , 0.34117647, 0.45098039,\r\n        0.62352941, 0.1372549 , 0.44705882, 0.56470588, 0.80784314,\r\n        0.78431373, 0.82352941, 0.39215686, 0.64705882, 0.82352941,\r\n        0.60784314, 0.22352941, 0.26666667, 0.07843137, 0.55294118,\r\n        0.05882353, 0.1372549 , 0.17647059, 0.02745098, 0.        ,\r\n        0.29411765, 0.90196078, 0.25490196, 0.29411765, 0.33333333,\r\n        0.41960784, 0.45098039, 0.23529412, 0.74117647, 0.66666667,\r\n        0.50980392, 0.73333333, 0.7254902 , 0.49019608, 0.26666667,\r\n        0.16862745, 0.19607843, 0.39215686, 0.16862745, 0.19607843,\r\n        0.09411765, 0.11764706, 0.16862745, 0.21568627, 0.82352941,\r\n        0.3254902 , 0.35294118, 0.25098039, 0.42352941, 0.37254902,\r\n        0.35294118, 0.50980392, 0.34117647, 0.16470588, 0.11372549,\r\n        0.25490196, 0.19607843, 0.14509804, 0.49803922, 0.20784314,\r\n        0.3372549 , 0.18039216, 0.01960784, 0.09803922, 0.17647059,\r\n        0.06666667, 0.06666667, 0.35686275, 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.        , 0.        ,\r\n        0.        , 0.        , 0.        , 0.49019608, 0.09803922,\r\n        0.8627451 , 0.74509804, 0.58823529, 0.39215686, 0.19607843]])\r\n\r\nclass ZoomableGraphicsView(QGraphicsView):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setScene(QGraphicsScene())\r\n        self.setDragMode(QGraphicsView.ScrollHandDrag)\r\n        self.setCursor(Qt.OpenHandCursor)\r\n        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\r\n        self.pixmap_item = None  # check if image loaded\r\n\r\n    def setImage(self, pixmap):\r\n        self.scene().clear()\r\n        self.pixmap_item = QGraphicsPixmapItem(pixmap)\r\n        self.scene().addItem(self.pixmap_item)\r\n        self.setSceneRect(QRectF(pixmap.rect()))\r\n\r\n    def wheelEvent(self, event):\r\n        zoom_in_factor = 1.25\r\n        zoom_out_factor = 1 / zoom_in_factor\r\n        zoom = zoom_in_factor if event.angleDelta().y() > 0 else zoom_out_factor\r\n        self.scale(zoom, zoom)\r\n\r\nclass GroundTruthWidget(QWidget, Ui_GroundTruthWidget):\r\n    cubeLoaded = QtCore.pyqtSignal(str)\r\n    cube_saved = QtCore.pyqtSignal(CubeInfoTemp)\r\n\r\n    def __init__(self, parent=None,cubeInfo=None):\r\n        super().__init__(parent)\r\n        # Set up UI from compiled .py\r\n        self.setupUi(self)\r\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding) ##all creen of possible\r\n\r\n        self.selecting_pixels = False # mode selection ref activated\r\n        self._pixel_selecting = False  # for manual pixel selection for dragging mode\r\n        self.erase_selection = False # erase mode on or off\r\n        self._pixel_coords = []  # collected  (x,y) during dragging\r\n        self._preview_mask = None # temp mask during dragging pixel selection\r\n        self.class_info = {}         #dictionnary of lists :  {key:[label GT, name GT,(R,G,B)]}\r\n        self.class_colors ={}  # color of each class\r\n        n0 = self.nclass_box.value()\r\n\r\n        # Replace placeholders with custom widgets\r\n        self._replace_placeholder('viewer_left', ZoomableGraphicsView)\r\n        self._replace_placeholder('viewer_right', ZoomableGraphicsView)\r\n        self._promote_canvas('spec_canvas', FigureCanvas)\r\n\r\n        self.viewer_left.viewport().installEventFilter(self)\r\n        self.viewer_right.viewport().installEventFilter(self)\r\n\r\n        # Enable live spectrum tracking\r\n        self.viewer_left.viewport().setCursor(Qt.CrossCursor) # curseur croix\r\n        self.viewer_left.viewport().setMouseTracking(True)\r\n        self.viewer_left.setDragMode(QGraphicsView.ScrollHandDrag)\r\n\r\n        # Promote spec_canvas placeholder to FigureCanvas\r\n        self.spec_canvas_layout = self.spec_canvas.layout() if hasattr(self.spec_canvas, 'layout') else None\r\n        self.init_spectrum_canvas()\r\n        self.spec_canvas.setVisible(True)\r\n        self.show_selection=True\r\n        self.live_spectra_update=True\r\n\r\n        # State variables\r\n        self.cube = None\r\n        self.data = None\r\n        self.wl= None\r\n        self.current_cube_info=None\r\n        self.cls_map = None\r\n        self.samples = {} # to save pixels spectra samples for GT\r\n        self.sample_coords = {c: set() for c in self.samples.keys()} # to remember coord of pixel samples\r\n        self.alpha = self.horizontalSlider_transparency_GT.value() / 100.0\r\n        self.mode = self.comboBox_ClassifMode.currentText()\r\n        self.hyps_rgb_chan_DEFAULT=[0,0,0] #default rgb channels (in int nm)\r\n        self.hyps_rgb_chan=[0,0,0] #current rgb (in int nm)\r\n        self.class_means = {} #for spectra of classe\r\n        self.class_ncount={} #for npixels classified\r\n        self.selected_bands=[]\r\n        self.selected_span_patch=[]\r\n\r\n        # Connect widget signals\r\n        self.load_btn.clicked.connect(self.load_cube)\r\n        self.run_btn.clicked.connect(self.run)\r\n        self.comboBox_ClassifMode.currentIndexChanged.connect(self.set_mode)\r\n        self.pushButton_class_selection.toggled.connect(self.on_toggle_selection)\r\n        self.pushButton_erase_selected_pix.toggled.connect(self.on_toggle_erase)\r\n        self.checkBox_see_selection_overlay.toggled.connect(self.toggle_show_selection)\r\n        self.pushButton_merge.clicked.connect(self.merge_selec_GT)\r\n        self.pushButton_class_name_assign.clicked.connect(self.open_label_table)\r\n        self.pushButton_band_selection.toggled.connect(self.band_selection)\r\n        self.pushButton_keep_GT.clicked.connect(self.keep_GT)\r\n        self.pushButton_reset.clicked.connect(self.reset_all)\r\n\r\n        # RGB sliders <-> spinboxes\r\n        self.sliders_rgb = [self.horizontalSlider_red_channel, self.horizontalSlider_green_channel,\r\n                            self.horizontalSlider_blue_channel]\r\n        self.spinBox_rgb = [self.spinBox_red_channel, self.spinBox_green_channel, self.spinBox_blue_channel]\r\n\r\n        for sl, sp in zip(self.sliders_rgb,  self.spinBox_rgb):\r\n            sl.valueChanged.connect(sp.setValue)\r\n            sp.valueChanged.connect(sl.setValue)\r\n            sl.valueChanged.connect(self.show_image)\r\n\r\n        self.radioButton_rgb_user.toggled.connect(self.modif_sliders)\r\n        self.radioButton_rgb_default.toggled.connect(self.modif_sliders)\r\n        self.radioButton_grayscale.toggled.connect(self.modif_sliders)\r\n\r\n        # Transparency slider\r\n        self.horizontalSlider_transparency_GT.valueChanged.connect(self.on_alpha_change)\r\n\r\n        # Live spectrum checkbox\r\n        self.live_cb.stateChanged.connect(self.toggle_live)\r\n\r\n        self.distance_funcs = {\r\n            'sqeuclidean': spdist.sqeuclidean,\r\n            'cosine': spdist.cosine,\r\n            'correlation': spdist.correlation,\r\n            'canberra': spdist.canberra,\r\n        }\r\n\r\n        # init stretch of each layout in QSplitters\r\n        self.splitter.setStretchFactor(0, 1) #init stretch of images and spectra\r\n        self.splitter.setStretchFactor(1, 1)\r\n        self.splitter.setSizes([600, 600])\r\n        self.splitter.setHandleWidth(2)\r\n\r\n        self.splitter_2.setStretchFactor(0,4) #init stretch of image hyp and GT\r\n        self.splitter_2.setStretchFactor(1, 1)\r\n\r\n        # style poignée QSplitter\r\n        self.splitter.setHandleWidth(2)\r\n        self.splitter_2.setHandleWidth(4)\r\n        self.splitter.setStyleSheet(\"\"\"QSplitter::handle {background-color: darkgray;}\"\"\")\r\n        self.splitter_2.setStyleSheet(\"\"\"QSplitter::handle {background-color: darkgray;}\"\"\")\r\n\r\n        self.set_mode()\r\n\r\n    def eventFilter(self, source, event):\r\n        mode = self.comboBox_pixel_selection_mode.currentText()\r\n\r\n        if event.type() == QEvent.MouseButtonPress and event.button() == Qt.LeftButton:\r\n            return False      ## to dont block drag\r\n\r\n        if event.type() == QEvent.MouseButtonPress and event.button() == Qt.RightButton and (self.selecting_pixels or self.erase_selection):\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            print('Clicked OK')\r\n            pos = self.viewer_left.mapToScene(event.pos())\r\n            x0, y0 = int(pos.x()), int(pos.y())\r\n            if mode == 'pixel':\r\n                # on commence la collecte\r\n                self._pixel_selecting = True\r\n                self._pixel_coords = [(x0, y0)]\r\n                return True\r\n            elif mode == 'rectangle':\r\n                # début du drag\r\n                from PyQt5.QtWidgets import QRubberBand\r\n                self.origin = event.pos()\r\n                self.rubberBand = QRubberBand(QRubberBand.Rectangle,\r\n                                              self.viewer_left.viewport())\r\n                self.rubberBand.setGeometry(self.origin.x(),\r\n                                            self.origin.y(), 1, 1)\r\n                self.rubberBand.show()\r\n                return True\r\n            elif mode == 'ellipse':\r\n                from PyQt5.QtWidgets import QGraphicsEllipseItem\r\n                from PyQt5.QtGui import QPen\r\n\r\n                self.origin = event.pos()\r\n                pen = QPen(Qt.red)\r\n                pen.setStyle(Qt.DashLine)\r\n                self.ellipse_item = QGraphicsEllipseItem()\r\n                self.ellipse_item.setPen(pen)\r\n                self.ellipse_item.setBrush(Qt.transparent)\r\n                self.viewer_left.scene().addItem(self.ellipse_item)\r\n                return True\r\n\r\n        if event.type() == QEvent.MouseButtonPress and event.button() == Qt.MiddleButton:\r\n            if not self.selecting_pixels:\r\n                self.live_spectra_update=not self.live_spectra_update\r\n\r\n        # 2) Mouvement souris → mise à jour de la selection en cours\r\n        if event.type() == QEvent.MouseMove and self._pixel_selecting and mode == 'pixel':\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            pos = self.viewer_left.mapToScene(event.pos())\r\n            x, y = int(pos.x()), int(pos.y())\r\n\r\n            if (x, y) not in self._pixel_coords:\r\n                self._pixel_coords.append((x, y))\r\n            if self._preview_mask is None:\r\n                H, W = self.data.shape[:2]\r\n                self._preview_mask = np.zeros((H, W), dtype=bool)\r\n\r\n            self._preview_mask[y, x] = True\r\n            self.show_image(preview=True)\r\n\r\n            return True\r\n\r\n        if event.type() == QEvent.MouseMove and hasattr(self, 'rubberBand'):\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            self.rubberBand.setGeometry(\r\n                QRect(self.origin, event.pos()).normalized()\r\n            )\r\n            return True\r\n\r\n        if event.type() == QEvent.MouseMove and mode == 'ellipse' and hasattr(self, 'ellipse_item'):\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            sc_orig = self.viewer_left.mapToScene(self.origin)\r\n            sc_now = self.viewer_left.mapToScene(event.pos())\r\n            x0, y0 = sc_orig.x(), sc_orig.y()\r\n            x1, y1 = sc_now.x(), sc_now.y()\r\n            rect = QRectF(min(x0, x1), min(y0, y1), abs(x1 - x0), abs(y1 - y0))\r\n            self.ellipse_item.setRect(rect)\r\n            return True\r\n\r\n        # 3) Relâchement souris → calcul de la sélection\r\n\r\n        if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton and mode == 'pixel' and self._pixel_selecting :\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            print('realeased OK')\r\n            # get pixels\r\n            coords = self._pixel_coords.copy()\r\n            #  Si au moins 3 points, propose de fermer le cheminif min 3 points, propose contour\r\n            if len(coords) >= 3:\r\n                reply = QMessageBox.question(\r\n                    self, \"Close Path?\",\r\n                    \"You have selected multiple pixels.\\n\"\r\n                    \"Do you want to close the path and include all pixels inside the contour?\",\r\n                    QMessageBox.Yes | QMessageBox.No\r\n                )\r\n                if reply == QMessageBox.Yes:\r\n                    pts = np.array(coords)\r\n                    poly = Path(pts)\r\n                    x0, y0 = pts[:, 0].min().astype(int), pts[:, 1].min().astype(int)\r\n                    x1, y1 = pts[:, 0].max().astype(int), pts[:, 1].max().astype(int)\r\n                    filled = list(coords)\r\n                    for yy in range(y0, y1 + 1):\r\n                        for xx in range(x0, x1 + 1):\r\n                            if poly.contains_point((xx, yy)):\r\n                                filled.append((xx, yy))\r\n\r\n                    # to avoid dobbles\r\n                    seen = set()\r\n                    coords = []\r\n                    for p in filled:\r\n                        if p not in seen:\r\n                            seen.add(p)\r\n                            coords.append(p)\r\n\r\n            if self.erase_selection:\r\n                self._handle_erasure(coords)\r\n            else :\r\n                self._handle_selection(coords) # close selection\r\n\r\n            # ready to new selection\r\n            self._pixel_selecting = False\r\n            self._erase_selecting = False\r\n            self._preview_mask = None\r\n            return True\r\n\r\n        if event.type() == QEvent.MouseButtonRelease and hasattr(self, 'rubberBand'):\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            rect = self.rubberBand.geometry()\r\n            self.rubberBand.hide()\r\n            # coins en coordonnées image\r\n            tl = self.viewer_left.mapToScene(rect.topLeft())\r\n            br = self.viewer_left.mapToScene(rect.bottomRight())\r\n            x0, y0 = int(tl.x()), int(tl.y())\r\n            x1, y1 = int(br.x()), int(br.y())\r\n            # liste de tous les pixels dans le rectangle\r\n            coords = [\r\n                (xx, yy)\r\n                for yy in range(max(0, min(y0, y1)), min(self.data.shape[0], max(y0, y1) + 1))\r\n                for xx in range(max(0, min(x0, x1)), min(self.data.shape[1], max(x0, x1) + 1))\r\n            ]\r\n\r\n            if self.erase_selection:\r\n                self._handle_erasure(coords)\r\n            else:\r\n                self._handle_selection(coords)  # close selection\r\n\r\n            del self.rubberBand\r\n            return True\r\n\r\n        if event.type() == QEvent.MouseButtonRelease and hasattr(self, 'ellipse_item'):\r\n            if not (self.selecting_pixels or self.erase_selection):\r\n                return False\r\n            rect = self.ellipse_item.rect()\r\n            self.viewer_left.scene().removeItem(self.ellipse_item)\r\n            del self.ellipse_item\r\n\r\n            cx, cy = rect.center().x(), rect.center().y()\r\n            rx, ry = rect.width() / 2, rect.height() / 2\r\n            x0, x1 = int(rect.left()), int(rect.right())\r\n            y0, y1 = int(rect.top()), int(rect.bottom())\r\n\r\n            coords = []\r\n            for yy in range(max(0, y0), min(self.data.shape[0], y1 + 1)):\r\n                for xx in range(max(0, x0), min(self.data.shape[1], x1 + 1)):\r\n                    if ((xx - cx) ** 2 / rx ** 2 + (yy - cy) ** 2 / ry ** 2) <= 1:\r\n                        coords.append((xx, yy))\r\n\r\n            if self.erase_selection:\r\n                self._handle_erasure(coords)\r\n            else:\r\n                self._handle_selection(coords)  # close selection\r\n            return True\r\n\r\n        # 4) Mouvement souris pour le live spectrum\r\n        if source is self.viewer_left.viewport() and event.type() == QEvent.MouseMove and self.live_spectra_update:\r\n            if self.live_cb.isChecked() and self.data is not None:\r\n                pos = self.viewer_left.mapToScene(event.pos())\r\n                x,y=int(pos.x()),int(pos.y())\r\n                H, W = self.data.shape[0], self.data.shape[1]\r\n                if 0 <= x < W and 0 <= y < H:\r\n                    self.update_spectra(x, y)\r\n\r\n            return True\r\n\r\n        # return super().eventFilter(source, event)\r\n        return False\r\n\r\n    def keep_GT(self):\r\n        # On envoie dans metadata : map de GT, class_counts (pixels_averaged), 'GT_cmap','spectra_mean','spectra_std'\r\n\r\n        if self.cls_map is None:\r\n            QMessageBox.warning(self, \"Warning\", \"Nothig to keep. Launch segmentation first\")\r\n            return\r\n\r\n        self.cube.cube_info.metadata_temp['pixels_averaged']=list(self.class_ncount.values())\r\n        GT_name=[]\r\n        GT_num=[]\r\n        for key in self.class_info:\r\n            GT_num.append(str(self.class_info[key][0]))\r\n            GT_name.append(self.class_info[key][1])\r\n\r\n        self.cube.cube_info.metadata_temp['GTLabels']=[GT_num,GT_name]\r\n        self.cube.cube_info.metadata_temp['GT_cmap']=GT_cmap\r\n\r\n        self.cube.cube_info.metadata_temp['spectra_mean']=list(self.class_means.values())\r\n        self.cube.cube_info.metadata_temp['spectra_std']=list(self.class_stds.values())\r\n\r\n        if  hasattr(self, 'GT_image'):\r\n            path, _ = QFileDialog.getSaveFileName(\r\n                self,\r\n                \"Save segmentation image\",\r\n                \"\",\r\n                \"PNG (*.png)\"\r\n            )\r\n            if not path:\r\n                return\r\n\r\n            cv2.imwrite(path, self.GT_image)\r\n\r\n            reply = QMessageBox.question(\r\n                self, \"Erase selection?\",\r\n                \"Ground truth image saved in :\\n{path} \\n \\n Do you also want to save updates metadata of the cube ?\",\r\n\r\n                QMessageBox.Yes | QMessageBox.No\r\n            )\r\n            if reply == QMessageBox.Yes:\r\n                self.cube.metadata=self.cube.cube_info.metadata_temp\r\n                filepath=self.cube.cube_info.filepath\r\n                ext = os.path.splitext(filepath)[1].lower()\r\n\r\n                if ext ==  \".mat\":\r\n                    fmt='MATLAB'\r\n                elif ext == \".h5\":\r\n                    fmt='HDF5'\r\n                elif ext == \".hdf5\":\r\n                    fmt = 'HDF5'\r\n                elif ext == '.hdr':\r\n                    fmt='ENVI'\r\n                else :\r\n                    fmt = 'HDF5'\r\n\r\n                self.cube.save(filepath,fmt=fmt)\r\n                self.cube_saved.emit(self.cube.cube_info)\r\n\r\n        else :\r\n            print('No Overlay')\r\n\r\n    def open_label_table(self):\r\n\r\n        if getattr(sys, 'frozen', False): # pynstaller case\r\n            BASE_DIR = sys._MEIPASS\r\n        else :\r\n            BASE_DIR = os.path.dirname(os.path.dirname(__file__))\r\n\r\n        csv_path = os.path.join(BASE_DIR, \"ground_truth/Materials labels and palette assignation - Materials_labels_palette.csv\")\r\n        # csv_path = 'Materials labels and palette assignation - Materials_labels_palette.csv'\r\n        self.class_win = LabelWidget(csv_path,self.class_info)\r\n        self.class_win.resize(1000, 600)\r\n        self.class_win.class_info_updated.connect(self.on_class_info_updated) # connect to signal from LabelWidget\r\n        self.class_win.show()\r\n\r\n    def on_class_info_updated(self, class_info):\r\n\r\n        self.class_info=class_info\r\n\r\n        for c, info in class_info.items():\r\n            if c in self.class_colors:\r\n                self.class_colors[c] = (info[2][2],info[2][1],info[2][0])\r\n\r\n        self.show_image()\r\n        self.update_legend()\r\n\r\n    def start_pixel_selection(self):\r\n\r\n        self.show_selection=True\r\n        self.pushButton_class_selection.setText(\"Stop Selection\")\r\n        self.pushButton_erase_selected_pix.setChecked(False)\r\n        self.live_spectra_update=False # to bloc tracking\r\n\r\n        if len(self.samples)>0 :\r\n            reply = QMessageBox.question(\r\n                self, \"Erase selection?\",\r\n                \"Do you want to erase previous selection?\",\r\n                QMessageBox.Yes | QMessageBox.No\r\n            )\r\n            if reply == QMessageBox.Yes:\r\n                H, W = self.selection_mask_map.shape\r\n                # Réinitialise à -1 (aucune classe)\r\n                self.selection_mask_map[:] = -1\r\n                self.samples.clear()\r\n\r\n        self.selecting_pixels = True\r\n        # self.viewer_left.setDragMode(QGraphicsView.NoDrag)\r\n        self.viewer_left.setCursor(Qt.CrossCursor)\r\n        self.viewer_left.viewport().setCursor(Qt.CrossCursor)\r\n        self.show_image()\r\n\r\n    def toggle_show_selection(self):\r\n\r\n        self.show_selection = self.checkBox_see_selection_overlay.isChecked()\r\n        self.show_image()\r\n\r\n    def stop_pixel_selection(self):\r\n\r\n        self.selecting_pixels = False\r\n\r\n        # ready to select\r\n        self.viewer_left.setDragMode(QGraphicsView.ScrollHandDrag)\r\n        self.viewer_left.setCursor(Qt.ArrowCursor)\r\n        self.viewer_left.viewport().setCursor(Qt.ArrowCursor)\r\n\r\n        # remet le bouton à l'état initial\r\n        self.pushButton_class_selection.setText(\"Start Selection\")\r\n        self.pushButton_class_selection.setChecked(False)\r\n\r\n        # efface tout preview en cours\r\n        self.selecting_pixels = False\r\n\r\n        # enfin, on affiche l'image normale (sans preview ni sélection en cours)\r\n        self.show_image()\r\n\r\n    def on_toggle_erase(self, checked):\r\n        self.erase_selection = checked\r\n\r\n        if checked:\r\n            self._pixel_selecting=False\r\n            self.stop_pixel_selection()\r\n\r\n            self.show_selection = True\r\n\r\n            self.pushButton_erase_selected_pix.setText(\"Stop Erasing\")\r\n            self.pushButton_class_selection.setChecked(False)\r\n            # self.viewer_left.setDragMode(QGraphicsView.NoDrag)\r\n            self.viewer_left.setCursor(Qt.CrossCursor)\r\n\r\n        else:\r\n            self.pushButton_erase_selected_pix.setText(\"Erase Pixels\")\r\n            self.viewer_left.setDragMode(QGraphicsView.ScrollHandDrag)\r\n            self.viewer_left.unsetCursor()\r\n\r\n    def on_toggle_selection(self, checked: bool):\r\n\r\n        if checked:\r\n            self.erase_selection=False\r\n            self.start_pixel_selection()\r\n            self.update_legend()\r\n\r\n        else:\r\n            # fin du mode sélection\r\n            self.stop_pixel_selection()\r\n\r\n    def merge_selec_GT(self):\r\n        \"\"\"\r\n        Fusionne les annotations manuelles (selection_mask_map)\r\n        dans la carte de segmentation algorithmique (cls_map),\r\n        puis met à jour les prototypes (moyennes et écart-types).\r\n        \"\"\"\r\n\r\n        if self.cls_map is None:\r\n            QMessageBox.warning(\r\n                self, \"Warning\",\r\n                \"No segmentation done : Perform a segmentation and try again if needed.\"\r\n            )\r\n            return\r\n\r\n\r\n        mask = (self.selection_mask_map >= 0) ##mask of manual selected\r\n\r\n        if not mask.any():\r\n            QMessageBox.information(\r\n                self, \"Info\",\r\n                \"Not selected pixel to mergi with segmented result\"\r\n            )\r\n            return\r\n\r\n        self.checkBox_enable_segment.setChecked(False) # secure selection by disabled segmentation\r\n\r\n        self.cls_map[mask] = self.selection_mask_map[mask] # assign manual selecte class in segmented image\r\n\r\n        # update class prototypes\r\n        unique_labels = np.unique(self.cls_map)\r\n        new_means = {}\r\n        new_stds = {}\r\n        for c in unique_labels:\r\n            # collecte les coordonnées dont cls_map == c\r\n            ys, xs = np.where(self.cls_map == c)\r\n            # construit un tableau (N_c x B) de leurs spectres\r\n            spectra = np.stack([self.data[y, x, :] for x, y in zip(xs, ys)], axis=0)\r\n            # moyenne et écart-type\r\n            new_means[c] = np.mean(spectra, axis=0)\r\n            new_stds[c] = np.std(spectra, axis=0)\r\n\r\n        self.class_means = new_means\r\n        self.class_stds = new_stds\r\n\r\n        n = len(unique_labels)\r\n\r\n        self.prune_unused_classes()\r\n        self.show_image()\r\n        self.update_counts()\r\n        self.update_legend()\r\n\r\n    def modif_sliders(self):\r\n        max_wl = int(self.wl[-1])\r\n        min_wl = int(self.wl[0])\r\n        wl_step = int(self.wl[1] - self.wl[0])\r\n\r\n        default=self.radioButton_rgb_default.isChecked()\r\n\r\n        if self.radioButton_grayscale.isChecked():\r\n            self.label_red_channel.setText('')\r\n            self.label_green_channel.setText('')\r\n            self.label_blue_channel.setText('Gray')\r\n        else:\r\n            self.label_red_channel.setText('Red')\r\n            self.label_green_channel.setText('Green')\r\n            self.label_blue_channel.setText('Blue')\r\n\r\n        for i, element in enumerate(self.sliders_rgb):\r\n            element.setMinimum(min_wl)\r\n            element.setMaximum(max_wl)\r\n            element.setSingleStep(wl_step)\r\n            if default:\r\n                element.setValue(self.hyps_rgb_chan_DEFAULT[i])\r\n            else:\r\n                element.setValue(self.hyps_rgb_chan[i])\r\n            if self.radioButton_rgb_default.isChecked():\r\n                element.setEnabled(False)\r\n            elif self.radioButton_grayscale.isChecked():\r\n                if i == 2:\r\n                    element.setEnabled(True)\r\n                else:\r\n                    element.setEnabled(False)\r\n            else:\r\n                element.setEnabled(True)\r\n\r\n        for i, element in enumerate(self.spinBox_rgb):\r\n            element.setMinimum(min_wl)\r\n            element.setMaximum(max_wl)\r\n            element.setSingleStep(wl_step)\r\n            if default:\r\n                element.setValue(self.hyps_rgb_chan_DEFAULT[i])\r\n            else:\r\n                element.setValue(self.hyps_rgb_chan[i])\r\n            if self.radioButton_rgb_default.isChecked():\r\n                element.setEnabled(False)\r\n            elif self.radioButton_grayscale.isChecked():\r\n                if i == 2:\r\n                    element.setEnabled(True)\r\n                else:\r\n                    element.setEnabled(False)\r\n            else:\r\n                element.setEnabled(True)\r\n\r\n        self.show_image()\r\n\r\n    def init_spectrum_canvas(self):\r\n        placeholder = getattr(self, 'spec_canvas')\r\n        parent = placeholder.parent()\r\n\r\n        # Crée le canvas\r\n        self.spec_fig = Figure(facecolor=(1, 1, 1, 0.1))\r\n        self.spec_canvas = FigureCanvas(self.spec_fig)\r\n        self.spec_ax = self.spec_fig.add_subplot(111)\r\n        self.spec_ax.set_facecolor((0.7,0.7,0.7,1))\r\n        self.spec_ax.set_title('Spectra')\r\n        self.spec_ax.grid()\r\n\r\n\r\n        self.span_selector = SpanSelector(\r\n            ax=self.spec_ax,  # votre axe “Spectrum”\r\n            onselect=self._on_bandselect,  # callback\r\n            direction=\"horizontal\",  # sélection horizontale\r\n            useblit=True,  # activer le “blitting”\r\n            minspan=1.0,  # au moins 1 unité sur l’axe λ\r\n            props=dict(alpha=0.3, facecolor='tab:blue')\r\n        )\r\n\r\n        self.span_selector.set_active(False)\r\n\r\n        # Remplace dans le splitter ou dans le layout\r\n        if isinstance(parent, QSplitter):\r\n            idx = parent.indexOf(placeholder)\r\n            placeholder.deleteLater()\r\n            parent.insertWidget(idx, self.spec_canvas)\r\n        elif parent.layout() is not None:\r\n            layout = parent.layout()\r\n            idx = layout.indexOf(placeholder)\r\n            layout.removeWidget(placeholder)\r\n            placeholder.deleteLater()\r\n            layout.insertWidget(idx, self.spec_canvas)\r\n        else:\r\n            placeholder.deleteLater()\r\n            self.verticalLayout.addWidget(self.spec_canvas)\r\n\r\n        self.spec_canvas.setVisible(True)\r\n\r\n    def _on_bandselect(self, lambda_min, lambda_max):\r\n        \"\"\"\r\n        Callback  SpanSelector\r\n        \"\"\"\r\n\r\n        if self._band_action is None:\r\n            return\r\n\r\n        # 1) S’assurer que lambda_min < lambda_max\r\n        if lambda_min > lambda_max:\r\n            lambda_min, lambda_max = lambda_max, lambda_min\r\n\r\n        # 2) Conversion en indices d’onde\r\n        idx_min = int(np.argmin(np.abs(self.wl - lambda_min)))\r\n        idx_max = int(np.argmin(np.abs(self.wl - lambda_max)))\r\n\r\n        # 3) update self.selected_bands\r\n        if self._band_action == 'add':\r\n            for idx in range(idx_min,idx_max+1):\r\n                if idx not in self.selected_bands:\r\n                    self.selected_bands.append(idx)\r\n\r\n            print(f\"Selected band : [{idx_min} → {idx_max}] \"\r\n                  f\"({self.wl[idx_min]:.1f} → {self.wl[idx_max]:.1f} nm)\")\r\n\r\n            patch=self.spec_ax.axvspan(\r\n                lambda_min, lambda_max,\r\n                alpha=0.2, color='tab:blue'\r\n            )\r\n\r\n            self.selected_span_patch.append(patch)\r\n\r\n        elif self._band_action == 'del':\r\n\r\n            for idx in range(idx_min,idx_max+1):\r\n                if idx in self.selected_bands:\r\n                    self.selected_bands.remove(idx)\r\n\r\n            self.selected_bands=sorted(self.selected_bands)\r\n\r\n            for patch in self.selected_span_patch:  # reset all patch\r\n                patch.remove()\r\n                self.selected_span_patch = []\r\n\r\n            bands={}\r\n            i_band=0\r\n            for i in range(len(self.selected_bands)-1): # get bands from index\r\n                if (self.selected_bands[i+1] -self.selected_bands[i]) ==1:\r\n                    try:\r\n                        bands[i_band].append(self.selected_bands[i])\r\n                    except:\r\n                        bands[i_band]=[self.selected_bands[i]]\r\n                else:\r\n                    try:\r\n                        bands[i_band].append(self.selected_bands[i])\r\n                    except:\r\n                        bands[i_band]=[self.selected_bands[i]]\r\n\r\n                    i_band+=1\r\n\r\n\r\n            # recreate patches\r\n            for i_band in bands:\r\n                lambda_min, lambda_max=self.wl[bands[i_band][0]],self.wl[bands[i_band][-1]]\r\n\r\n                patch = self.spec_ax.axvspan(\r\n                    lambda_min, lambda_max,\r\n                    alpha=0.2, color='tab:blue'\r\n                )\r\n\r\n                self.selected_span_patch.append(patch)\r\n\r\n        self.spec_canvas.draw_idle()\r\n\r\n    def _handle_selection(self, coords):\r\n        \"\"\"Prompt for class and store spectra of the given coordinates.\"\"\"\r\n        max_cls = self.nclass_box.value() - 1\r\n        labels = [str(i) for i in range(max_cls + 1)]\r\n\r\n        # 2) Ouvrir un QInputDialog.getItem() au lieu de getInt()\r\n        #    - on force l’édition à se faire via la liste déroulante\r\n        cls_str, ok = QInputDialog.getItem(\r\n            self,\r\n            \"Class\",\r\n            \"Choose class label:\",\r\n            labels,\r\n            0,  # index initial (par défaut on sélectionne “0”)\r\n            False  # False = l’utilisateur ne peut pas taper autre chose que la liste\r\n        )\r\n\r\n        if not ok:\r\n            return\r\n\r\n        cls = int(cls_str)\r\n        if cls not in self.class_colors:\r\n            self._assign_initial_colors(cls)\r\n        else:\r\n            print({self.class_colors[cls]})\r\n\r\n        # append spectra\r\n\r\n        for x, y in coords:\r\n            if not (0 <= x < self.data.shape[1] and 0 <= y < self.data.shape[0]):\r\n                continue\r\n\r\n            # A) s’il appartenait déjà à une autre classe, on l’enlève\r\n            old = self.selection_mask_map[y, x]\r\n            if old >= 0 and old != cls:\r\n                # retirer coord de sample_coords[old] et de samples[old]\r\n                if (x, y) in self.sample_coords.get(old, set()):\r\n                    self.sample_coords[old].remove((x, y))\r\n                # reconstruire la liste des spectres pour old\r\n                self.samples[old] = [\r\n                    self.data[yy, xx, :]\r\n                    for (xx, yy) in self.sample_coords.get(old, ())\r\n                ]\r\n\r\n            # B) on (ré)assigne le pixel à la classe cls\r\n            self.selection_mask_map[y, x] = cls\r\n            # ajouter dans sample_coords et samples si pas déjà présent\r\n            if (x, y) not in self.sample_coords.setdefault(cls, set()):\r\n                self.sample_coords.setdefault(cls, set()).add((x, y))\r\n                self.samples.setdefault(cls, []).append(self.data[y, x, :])\r\n\r\n            # 3) rafraîchir l’affichage\r\n        self.show_image()\r\n        self.update_legend()\r\n\r\n    def _handle_erasure(self, coords):\r\n\r\n        for x, y in coords:\r\n            cls = self.selection_mask_map[y, x]\r\n            if cls >= 0:\r\n                # enlève du mask\r\n                self.selection_mask_map[y, x] = -1\r\n                # enlève des sets et listes\r\n                if (x, y) in self.sample_coords.get(cls, set()):\r\n                    self.sample_coords[cls].remove((x, y))\r\n                # reconstruit self.samples[cls]\r\n                self.samples[cls] = [\r\n                    self.data[yy, xx, :]\r\n                    for (xx, yy) in self.sample_coords.get(cls, [])\r\n                ]\r\n                if len(self.sample_coords.get(cls, [])) == 0:\r\n                    # on supprime tous les attributs relatifs à cette classe\r\n                    self.sample_coords.pop(cls, None)\r\n                    self.samples.pop(cls, None)\r\n                    self.class_colors.pop(cls, None)\r\n                    self.class_means.pop(cls, None)\r\n                    self.class_stds.pop(cls, None)\r\n\r\n        self.prune_unused_classes()\r\n        self.show_image()\r\n        self.update_legend()\r\n\r\n    def update_spectra(self,x=None,y=None):\r\n        self.spec_ax.clear()\r\n        x_graph = self.wl\r\n\r\n        if x is not None and y is not None:\r\n            if 0 <= x < self.data.shape[1] and 0 <= y < self.data.shape[0]:\r\n                spectrum = self.data[y, x, :]\r\n                # Spectre du pixel\r\n                self.spec_ax.plot(x_graph, spectrum, label='Pixel')\r\n                self.spec_ax.grid(color='black')\r\n\r\n        # Spectres GT moyens ± std\r\n        if self.checkBox_seeGTspectra.isChecked() and hasattr(self, 'class_means'):\r\n            for c, mu in self.class_means.items():\r\n                std = self.class_stds[c]\r\n                b, g, r = self.class_colors[c]\r\n                col = (r/255.0, g/255.0, b/255.0)\r\n                self.spec_ax.fill_between(\r\n                    x_graph, mu - std, mu + std,\r\n                    color=col, alpha=0.3, linewidth=0\r\n                )\r\n                self.spec_ax.plot(\r\n                    x_graph, mu, '--',\r\n                    color=col, label=f\"Class {c}\"\r\n                )\r\n            if self.spec_ax.get_legend_handles_labels()[1]:\r\n                self.spec_ax.legend(loc='upper right', fontsize='small')\r\n            self.spec_ax.set_title(f\"Spectra\")\r\n            self.spec_canvas.setVisible(True)\r\n\r\n        for patch in self.selected_span_patch:\r\n            # patch est un PolyCollection produit par axvspan()\r\n            # On le remet dans l’axe courant :\r\n            self.spec_ax.add_patch(patch)\r\n\r\n            # 4) On rafraîchit le canvas\r\n        self.spec_canvas.draw_idle()\r\n\r\n    def on_alpha_change(self, val):\r\n        self.alpha = val / 100.0\r\n        self.show_image()\r\n\r\n    def toggle_live(self, state):\r\n        if not state:\r\n            self.spec_canvas.setVisible(False)\r\n        else:\r\n            self.update_spectra()\r\n            self.live_spectra_update=True\r\n\r\n    def load_cube(self,cube_info=None,path=None):\r\n\r\n        if self.cls_map is not None : # if work done, stop to permit saving before continue.\r\n            reply = QMessageBox.question(\r\n                self, \"Erase previous selection ?\",\r\n                \"Do you want to erase previous cube work ?\",\r\n                QMessageBox.Yes | QMessageBox.No\r\n            )\r\n            if reply == QMessageBox.No:\r\n               return\r\n\r\n        if cube_info is not None:\r\n            if path is None:\r\n                try:\r\n                    if cube_info.filepath is not None:\r\n                        path=cube_info.filepath\r\n                except:\r\n                    pass\r\n            else :\r\n                if path !=cube_info.filepath :\r\n                    QMessageBox.warning(self, \"Warning\", \"Path  is different from the filepath of cubeInfo\")\r\n                    return\r\n\r\n        if not path :\r\n            print('Ask path for cube')\r\n            path, _ = QFileDialog.getOpenFileName(\r\n            self, \"Open Hypercube\", \"\", \"Hypercube files (*.mat *.h5 *.hdr)\"\r\n            )\r\n            if not path:\r\n                return\r\n\r\n        message_progress = \"[Ground Truth Tool] Loading cube...\"\r\n        loading = LoadingDialog(message_progress, filename=path, parent=self)\r\n        loading.show()\r\n        QApplication.processEvents()\r\n\r\n        try :\r\n            cube = Hypercube(filepath=path, load_init=True)\r\n        except:\r\n            QMessageBox.information(self,\"Problem at loading\",\"Impossible to load this cube. Please check format.\")\r\n            loading.close()\r\n            return\r\n\r\n        loading.close()\r\n\r\n        # todo : check if GT already done in the file\r\n\r\n        if cube_info is None:\r\n            if \"GTLabels\" in cube.metadata.keys():\r\n                if len(cube.metadata[\"GTLabels\"][0]) != 0:\r\n                    reply = QMessageBox.question(\r\n                        self, \"Erase previous Ground Truth ?\",\r\n                        \"Ground truth labels has been found in the file. \\n Are you sure that you want to make a new Ground Truth for this cube ?\",\r\n                        QMessageBox.Yes | QMessageBox.No\r\n                    )\r\n                    if reply == QMessageBox.No:\r\n                        return\r\n\r\n        self.cube = cube\r\n        self.data = self.cube.data\r\n        self.wl = self.cube.wl\r\n\r\n        if self.wl[-1] < 1100 and self.wl[0] > 350:\r\n            self.hyps_rgb_chan_DEFAULT = [610, 540, 435]\r\n        elif self.wl[-1] >= 1100:\r\n            self.hyps_rgb_chan_DEFAULT = [1605, 1205, 1005]\r\n        else:\r\n            mid = int(len(self.wl) / 2)\r\n            self.hyps_rgb_chan_DEFAULT = [self.wl[0], self.wl[mid], self.wl[-1]]\r\n\r\n        self.reset_state()\r\n        self.modif_sliders()\r\n        self.show_image(path) # Notify the manager\r\n\r\n    def load_cube_info(self, ci: CubeInfoTemp):\r\n        self.cube.cube_info = ci\r\n\r\n    def reset_state(self):\r\n        \"\"\"\r\n        Réinitialise tous les états liés au cube courant pour repartir d'un état vierge.\r\n        \"\"\"\r\n        # 1. Segmentation algorithmique\r\n        self.cls_map = None\r\n        # 2. Sélection manuelle\r\n        if self.data is not None:\r\n            H, W = self.data.shape[:2]\r\n            self.selection_mask_map = np.full((H, W), -1, dtype=int)\r\n        # 3. Samples et prototypes\r\n        self.samples = {}\r\n        self.sample_coords = {}\r\n        self.class_means = {}\r\n        self.class_stds = {}\r\n        self.class_colors = {}\r\n        # 4. Masques de preview/erase\r\n        self._preview_mask = None\r\n        if hasattr(self, '_erase_mask'):\r\n            self._erase_mask = None\r\n        # 5. UI\r\n        # Masquer le canvas de spectres\r\n        self.spec_canvas.setVisible(False)\r\n        self.selecting_pixels = False\r\n        self.erase_selection = False\r\n        self.pushButton_class_selection.setChecked(False)\r\n        self.pushButton_erase_selected_pix.setChecked(False)\r\n        self.show_image()\r\n        self.update_legend()\r\n        # Remettre le slider de threshold à 100%\r\n        if hasattr(self, 'horizontalSlider_threshold'):\r\n            self.horizontalSlider_threshold.setValue(100)\r\n\r\n    def set_mode(self):\r\n        self.mode = self.comboBox_ClassifMode.currentText()\r\n        if self.mode == 'Supervised':\r\n            self.stackedWidget.setCurrentWidget(self.page_distance)\r\n            self.label_metric.setText('Spectral distance')\r\n        elif self.mode == 'Unsupervised':\r\n            self.stackedWidget.setCurrentWidget(self.page_normalized)\r\n            self.label_metric.setText('Spectral Normalization')\r\n\r\n\r\n        self.show_image()\r\n\r\n    def show_image(self, preview=False):\r\n        if self.data is None:\r\n            return\r\n\r\n        #hyp image\r\n        H, W, B = self.data.shape\r\n                # Get band indices from spinboxes for RGB\r\n        self.hyps_rgb_chan = [self.spinBox_red_channel.value(),\r\n               self.spinBox_green_channel.value(),\r\n               self.spinBox_blue_channel.value()]\r\n\r\n        idx = [np.argmin(np.abs(self.hyps_rgb_chan[j] - self.wl)) for j in range(3)]\r\n        if self.radioButton_grayscale.isChecked():\r\n            idx=[idx[2],idx[2],idx[2]]\r\n\r\n        rgb = self.data[:, :, idx]\r\n        rgb = (rgb / np.max(rgb) * 255).astype(np.uint8)\r\n\r\n        # overlay of GT\r\n\r\n        if self.cls_map is None:\r\n            overlay = rgb.copy()\r\n\r\n        else:\r\n\r\n            # 1) Construire seg_color (H x W x 3) en BGR\r\n\r\n            H, W = self.cls_map.shape\r\n\r\n            seg_color = np.zeros((H, W, 3), dtype=np.uint8)\r\n\r\n            for cls, (b, g, r) in self.class_colors.items():\r\n                mask = (self.cls_map == cls)\r\n\r\n                # On applique la couleur b,g,r à tous les pixels de cette classe\r\n\r\n                seg_color[mask] = [b, g, r]\r\n\r\n            # 2) Si vous avez défini une classe “other” (indice = n_classes),\r\n\r\n            #    et que vous n’avez pas de couleur pour elle, vous pouvez la mettre en grisé, ex.:\r\n\r\n            other_idx = set(np.unique(self.cls_map)) - set(self.class_colors.keys())\r\n\r\n            for cls in other_idx:\r\n                gray = 128\r\n\r\n                mask = (self.cls_map == cls)\r\n\r\n                seg_color[mask] = [gray, gray, gray]\r\n\r\n            # 3) Faire l’overlay final avec la transparence\r\n\r\n            overlay = cv2.addWeighted(rgb, 1 - self.alpha, seg_color, self.alpha, 0)\r\n\r\n        if self.cls_map is None:\r\n            blank = np.zeros((H, W, 3), dtype=np.uint8)\r\n            pix2 = self._np2pixmap(blank)\r\n        else:\r\n            # On recycle seg_color calculé plus haut :\r\n            # s’il n’est pas dans une variable, recalculer de la même façon :\r\n            seg_color2 = np.zeros((H, W, 3), dtype=np.uint8)\r\n            for cls, (b, g, r) in self.class_colors.items():\r\n                mask = (self.cls_map == cls)\r\n                seg_color2[mask] = [b, g, r]\r\n            other_idx = set(np.unique(self.cls_map)) - set(self.class_colors.keys())\r\n            for cls in other_idx:\r\n                gray = 128\r\n                mask = (self.cls_map == cls)\r\n                seg_color2[mask] = [gray, gray, gray]\r\n\r\n            pix2 = self._np2pixmap(seg_color2)\r\n            self.GT_image = seg_color2\r\n\r\n        self.viewer_right.setImage(pix2)\r\n\r\n        # overlay of selection blended to GT overlay\r\n\r\n        current = overlay.copy()\r\n        if self.selection_mask_map is not None and self.show_selection:\r\n            mixed = overlay.copy()\r\n            α = 0.7\r\n            for cls, color in self.class_colors.items():\r\n                mask2d = (self.selection_mask_map == cls)\r\n                if not mask2d.any():\r\n                    continue\r\n\r\n                layer = np.zeros_like(overlay)\r\n                layer[:] = color\r\n\r\n                blended = cv2.addWeighted(overlay, 1 - α, layer, α, 0)\r\n\r\n                mask3 = mask2d[:, :, None]\r\n                current = np.where(mask3, blended, current)\r\n\r\n        self.current_composite = current\r\n\r\n        if preview and self._preview_mask is not None:\r\n            base = self.current_composite\r\n            layer = np.zeros_like(base)\r\n            layer[..., :] = 0,0,255  # BGR = (0,0,0)\r\n            mixed = cv2.addWeighted(base, 1-0.1, layer, 0.1, 0)\r\n            mask3 = self._preview_mask[:, :, None]\r\n            result = np.where(mask3, mixed, base)\r\n            self.viewer_left.setImage(self._np2pixmap(result))\r\n            return\r\n\r\n        self.viewer_left.setImage(self._np2pixmap(self.current_composite))\r\n\r\n    def update_legend(self):\r\n\r\n        if len(self.class_ncount)!=0:\r\n\r\n            for i in reversed(range(self.frame_legend.layout().count())):\r\n                w = self.frame_legend.layout().itemAt(i).widget()\r\n                self.frame_legend.layout().removeWidget(w)\r\n                w.deleteLater()\r\n\r\n            for c in sorted(self.class_colors):\r\n                b, g, r = self.class_colors[c]\r\n                txt=str(c)\r\n                if self.class_ncount is not None :\r\n                    txt+='-'+str(self.class_ncount[c])+'px'\r\n\r\n                lbl = QLabel(txt)\r\n                # lbl.setFixedSize(30, 20)\r\n                lbl.setAlignment(Qt.AlignCenter)\r\n                lbl.setStyleSheet(\r\n                    f\"background-color: rgb({r},{g},{b});\"\r\n                    \"color: white;\"\r\n                    \"border-radius: 3px;\"\r\n                    \"font-weight: bold;\"\r\n                )\r\n                self.frame_legend.layout().addWidget(lbl)\r\n\r\n    def _replace_placeholder(self, name, widget_cls, **kwargs):\r\n        placeholder = getattr(self, name)\r\n        parent = placeholder.parent()\r\n        # Determine if parent is a layout container or a splitter\r\n        if parent.layout() is not None:\r\n            layout = parent.layout()\r\n            idx = layout.indexOf(placeholder)\r\n            layout.removeWidget(placeholder)\r\n            placeholder.deleteLater()\r\n            widget = widget_cls(**kwargs) if kwargs else widget_cls()\r\n            setattr(self, name, widget)\r\n            layout.insertWidget(idx, widget)\r\n        elif isinstance(parent, QSplitter):\r\n            # Handle QSplitter parent\r\n            idx = parent.indexOf(placeholder)\r\n            placeholder.deleteLater()\r\n            widget = widget_cls(**kwargs) if kwargs else widget_cls()\r\n            setattr(self, name, widget)\r\n            parent.insertWidget(idx, widget)\r\n        else:\r\n            # Fallback: direct replacement\r\n            placeholder.deleteLater()\r\n            widget = widget_cls(**kwargs) if kwargs else widget_cls()\r\n            setattr(self, name, widget)\r\n\r\n    def _promote_canvas(self, name, canvas_cls):\r\n        placeholder = getattr(self, name)\r\n        parent = placeholder.parent()\r\n        from PyQt5.QtWidgets import QSplitter\r\n\r\n        # Crée le nouveau canvas\r\n        canvas = canvas_cls()\r\n        # Supprime l’ancien placeholder\r\n        placeholder.deleteLater()\r\n\r\n        if isinstance(parent, QSplitter):\r\n            # cas splitter : insère au même emplacement\r\n            idx = parent.indexOf(placeholder)\r\n            parent.insertWidget(idx, canvas)\r\n        else:\r\n            # cas layout classique\r\n            layout = parent.layout() or self.verticalLayout\r\n            layout.addWidget(canvas)\r\n\r\n        # Conserve refs pour live spectrum\r\n        self.spec_canvas = canvas\r\n        self.spec_fig = getattr(canvas, 'figure', None) or Figure()\r\n        self.spec_ax = self.spec_fig.add_subplot(111)\r\n        self.spec_ax.set_title('Spectrum')\r\n        canvas.setVisible(False)\r\n\r\n    def compute_distance(self, u, v):\r\n        name = self.comboBox_distance.currentText()\r\n        fn   = self.distance_funcs.get(name)\r\n        return fn(u, v)\r\n\r\n    def run(self):\r\n\r\n        self.stop_pixel_selection()\r\n\r\n        if not self.checkBox_enable_segment.isChecked():\r\n            QMessageBox.warning(self, \"Warning\", \"Enable segmentation with checkbox !\")\r\n            return\r\n\r\n        if self.data is None:\r\n            QMessageBox.warning(self, \"Warning\", \"Load a cube !\")\r\n            return\r\n\r\n        samples_seg={}\r\n        if len(self.selected_bands) > 0:\r\n            bandes = self.selected_bands\r\n            bandes_sorted = sorted(bandes)\r\n            data_seg = self.data[:, :, bandes_sorted]\r\n\r\n        else:\r\n            bandes_sorted=list(range(len(self.wl)))\r\n            data_seg=self.data\r\n\r\n        H, W, B_sel = data_seg.shape\r\n        flat = data_seg.reshape(-1, B_sel)\r\n\r\n        # 1) Unsupervised\r\n        if self.mode == 'Unsupervised':\r\n            if self.comboBox_normalized.currentText()=='Normalize':\r\n                max_flat=np.max(flat,axis=1,keepdims=True)\r\n                flat/=max_flat\r\n\r\n            from sklearn.cluster import KMeans\r\n            n = self.nclass_box.value()\r\n            kmeans = KMeans(n_clusters=n).fit(flat)\r\n            labels = kmeans.labels_\r\n\r\n            # Final : reshape et affichage\r\n            H, W = self.data.shape[:2]\r\n            self.cls_map = labels.reshape(H, W)\r\n\r\n            # stocke moyennes, écarts et colormap\r\n            full_means = {}\r\n            full_stds = {}\r\n            for c in range(n):\r\n                mask_c = (self.cls_map == c)  # True pour tous les pixels de la classe c\r\n                pixels_spectre_complet = self.data[mask_c]  # shape = (N_pixels_classe, F)\r\n                if pixels_spectre_complet.size == 0:\r\n                    full_means[c] = np.zeros(self.data.shape[2])\r\n                    full_stds[c] = np.zeros(self.data.shape[2])\r\n                else:\r\n                    full_means[c] = pixels_spectre_complet.mean(axis=0)\r\n                    full_stds[c] = pixels_spectre_complet.std(axis=0)\r\n            self.class_means = full_means\r\n            self.class_stds = full_stds\r\n\r\n        elif self.mode == 'Supervised':\r\n            # 1) Récupère les prototypes des classes labellisées\r\n            classes = sorted(self.samples.keys())\r\n            if not classes:\r\n                QMessageBox.warning(self, \"Warning\", \"Choose Unsupervided classification or select references pixels and try again !\")\r\n                return\r\n\r\n            means = {}\r\n            for c in classes:\r\n                full_spectra_c = np.vstack(self.samples[c])  # shape = (N_pixels_de_c, F)\r\n                truncated_spectra_c = full_spectra_c[:, bandes_sorted]  # shape = (N_pixels_de_c, B_sel)\r\n                means[c] = truncated_spectra_c.mean(axis=0)\r\n\r\n            thr_pct = self.slider_class_thr.value()\r\n            thr_frac = thr_pct / 100.0  # 0.0–1.0\r\n\r\n            other_label = len(classes)\r\n            labels = np.full(flat.shape[0], other_label, dtype=int)\r\n\r\n            for i, pix in enumerate(flat):\r\n                dists = np.array([self.compute_distance(pix, means[c])\r\n                                  for c in classes])\r\n                min_idx = np.argmin(dists)\r\n                min_dist = dists[min_idx]\r\n\r\n                if thr_pct == 100:\r\n                    labels[i] = classes[min_idx]\r\n                else:\r\n                    # on normalise la distance entre 0 et 1 sur cet exemple\r\n                    max_dist = dists.max() if dists.max() > 0 else 1.0\r\n                    norm_dist = min_dist / max_dist\r\n                    if norm_dist <= thr_frac:\r\n                        labels[i] = classes[min_idx]\r\n\r\n            full_means = {}\r\n            full_stds = {}\r\n\r\n            for c in range(len(classes)):\r\n                mask_c = (self.cls_map == c)  # True pour tous les pixels de la classe c\r\n                pixels_spectre_complet = self.data[mask_c]  # shape = (N_pixels_classe, F)\r\n                if pixels_spectre_complet.size == 0:\r\n                    full_means[c] = np.zeros(self.data.shape[2])\r\n                    full_stds[c] = np.zeros(self.data.shape[2])\r\n                else:\r\n                    full_means[c] = pixels_spectre_complet.mean(axis=0)\r\n                    full_stds[c] = pixels_spectre_complet.std(axis=0)\r\n            self.class_means = full_means\r\n            self.class_stds = full_stds\r\n\r\n            # 5) reshape et préparation de l’affichage\r\n            H, W = self.data.shape[:2]\r\n            self.cls_map = labels.reshape(H, W)\r\n\r\n            # on prend K = nombre de classes + 1 for “other”\r\n            n_colors = other_label + 1\r\n\r\n        self.prune_unused_classes()\r\n        self._assign_initial_colors()\r\n        self.show_image()\r\n        self.update_counts()\r\n        self.update_legend()\r\n        self.update_spectra()\r\n\r\n    def update_counts(self):\r\n        labels, counts = np.unique(self.cls_map, return_counts=True)\r\n        for cls, cnt in zip(labels, counts):\r\n            self.class_ncount[cls]=cnt\r\n\r\n    def _np2pixmap(self, img):\r\n        from PyQt5.QtGui import QImage, QPixmap\r\n        if img.ndim == 2:\r\n            fmt = QImage.Format_Grayscale8\r\n            qimg = QImage(img.data, img.shape[1], img.shape[0], img.strides[0], fmt)\r\n        else:\r\n            rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\r\n            fmt = QImage.Format_RGB888\r\n            qimg = QImage(rgb.data, rgb.shape[1], rgb.shape[0], rgb.strides[0], fmt)\r\n        return QPixmap.fromImage(qimg).copy()\r\n\r\n    def _assign_initial_colors(self,c=None):\r\n\r\n        if c is not None :\r\n            unique_labels=[c]\r\n        elif self.cls_map is not None:\r\n            unique_labels = np.unique(self.cls_map)\r\n        else:\r\n            return\r\n\r\n        cmap = colormaps.get_cmap('tab10')\r\n\r\n        for cls in unique_labels:\r\n            if cls not in self.class_colors:\r\n                # cmap renvoie un tuple RGBA avec floats 0..1\r\n                r_f, g_f, b_f, _ = cmap(cls)\r\n                # on convertit en entiers 0..255\r\n                r, g, b = int(255 * r_f), int(255 * g_f), int(255 * b_f)\r\n                # MAIS OpenCV attend BGR, donc on stocke (b,g,r)\r\n                self.class_colors[cls] = (b, g, r)\r\n                if cls not in self.class_info:\r\n                    self.class_info[cls] = [None,None,(0,0,0)]\r\n                self.class_info[cls][2]=(r,g,b)\r\n\r\n    def prune_unused_classes(self):\r\n        \"\"\"\r\n        Supprime de self.class_colors et self.class_info\r\n        tous les labels qui ne figurent plus dans self.cls_map.\r\n        \"\"\"\r\n        if self.cls_map is None:\r\n            return\r\n\r\n        labels_in_map = set(np.unique(self.cls_map))\r\n        for d in (self.class_colors, self.class_info):\r\n            for cls in list(d.keys()):\r\n                if cls not in labels_in_map:\r\n                    del d[cls]\r\n\r\n    def band_selection(self,checked):\r\n        if checked:\r\n\r\n            try:\r\n                msg = QMessageBox(self)\r\n                msg.setWindowTitle(\"Bands selection\")\r\n                msg.setText(\"Add or suppress bands \")\r\n                add_button = msg.addButton(\"Add\", QMessageBox.AcceptRole)\r\n                remove_button = msg.addButton(\"Suppress\", QMessageBox.AcceptRole)\r\n                reset_button=msg.addButton(\"Clear all bands\", QMessageBox.AcceptRole)\r\n                cancel_button = msg.addButton(QMessageBox.Cancel)\r\n                msg.setDefaultButton(add_button)\r\n                msg.exec_()\r\n\r\n                if msg.clickedButton() == add_button:\r\n                    self._band_action = 'add'\r\n                elif msg.clickedButton() == remove_button:\r\n                    self._band_action = 'del'\r\n                elif msg.clickedButton() == reset_button:\r\n                    print('reset')\r\n                    self._band_action = None\r\n                    self.selected_bands = []\r\n\r\n                    for patch in self.selected_span_patch:  # reset patch\r\n                        patch.remove()\r\n                        self.selected_span_patch = []\r\n\r\n                    self.pushButton_band_selection.setChecked(False)\r\n                    self.spec_canvas.draw_idle()\r\n                    return\r\n\r\n                else:\r\n                    self.span_selector.set_active(False)\r\n                    self.pushButton_band_selection.setChecked(False)\r\n                    return\r\n\r\n                self.span_selector.set_active(True)\r\n                self.pushButton_band_selection.setText('STOP SELECTION')\r\n            except:\r\n                QMessageBox.warning(\r\n                    self, \"Warning\",\r\n                    \"No band selection choice\"\r\n                )\r\n                self.pushButton_band_selection.setChecked(False)\r\n\r\n                return\r\n\r\n        else:\r\n            self.span_selector.set_active(False)\r\n            self.pushButton_band_selection.setText('Band selection')\r\n\r\n    def reset_all(self):\r\n        # Check if sure ?\r\n        ans = QMessageBox.warning(self, 'Reset All',\r\n                                  'If you reset you will loose all the work you have done here.\\n \\nAre you sure you want to reset this tool ? ',\r\n                                  QMessageBox.Yes | QMessageBox.Cancel)\r\n        if ans == QMessageBox.Cancel:\r\n            return\r\n\r\n        # Core data\r\n        self.cube = None\r\n        self.data = None\r\n        self.wl = None\r\n        self.current_cube_info = None\r\n        self.cls_map = None\r\n        self.GT_image = None\r\n\r\n        # Selection and class data\r\n        self.selection_mask_map = None\r\n        self.samples.clear()\r\n        self.sample_coords.clear()\r\n        self.class_means.clear()\r\n        self.class_stds.clear()\r\n        self.class_colors.clear()\r\n        self.class_info.clear()\r\n        self.class_ncount.clear()\r\n\r\n        # Band selections and spectrum patches\r\n        for patch in self.selected_span_patch:\r\n            try:\r\n                patch.remove()\r\n            except:\r\n                pass\r\n        self.selected_span_patch.clear()\r\n        self.selected_bands.clear()\r\n        self._band_action = None\r\n\r\n        # Temporary masks\r\n        self._preview_mask = None\r\n        if hasattr(self, '_erase_mask'):\r\n            self._erase_mask = None\r\n\r\n        # Selection state\r\n        self.selecting_pixels = False\r\n        self.erase_selection = False\r\n        self._pixel_selecting = False\r\n        self._pixel_coords = []\r\n        self.alpha = self.horizontalSlider_transparency_GT.value() / 100.0\r\n        self.live_spectra_update = True\r\n\r\n        # Spectrum plot UI\r\n        self.spec_ax.clear()\r\n        self.spec_canvas.draw_idle()\r\n        self.spec_canvas.setVisible(False)\r\n        self.pushButton_class_selection.setChecked(False)\r\n        self.pushButton_erase_selected_pix.setChecked(False)\r\n        self.checkBox_see_selection_overlay.setChecked(True)\r\n        self.checkBox_seeGTspectra.setChecked(True)\r\n        self.live_cb.setChecked(True)\r\n\r\n        # Clear legend layout\r\n        while self.frame_legend.layout().count():\r\n            item = self.frame_legend.layout().takeAt(0)\r\n            if item.widget():\r\n                item.widget().deleteLater()\r\n\r\n        # Reset RGB sliders\r\n        self.radioButton_rgb_default.setChecked(True)\r\n\r\n        # Clear images\r\n        blank = np.zeros((100, 100, 3), dtype=np.uint8)\r\n        self.viewer_left.setImage(self._np2pixmap(blank))\r\n        self.viewer_right.setImage(self._np2pixmap(blank))\r\n\r\n\r\nif __name__=='__main__':\r\n\r\n    app = QApplication(sys.argv)\r\n    w = GroundTruthWidget()\r\n    # folder=r'C:\\Users\\Usuario\\Documents\\DOC_Yannick\\HYPERDOC Database\\Samples\\minicubes/'\r\n    # file_name='00278-SWIR-mock-up.h5'\r\n    # filepath=folder+file_name\r\n    # w.load_cube(path=filepath)\r\n    w.show()\r\n    sys.exit(app.exec_())\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ground_truth/ground_truth_tool.py b/ground_truth/ground_truth_tool.py
--- a/ground_truth/ground_truth_tool.py	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/ground_truth/ground_truth_tool.py	(date 1752493471752)
@@ -13,7 +13,7 @@
 from PyQt5.QtWidgets import ( QSplitter,
     QApplication,QSizePolicy, QGraphicsScene, QGraphicsPixmapItem,QRubberBand,QWidget, QFileDialog, QMessageBox,QInputDialog , QSplitter,QGraphicsView,QLabel,
 )
-from PyQt5.QtCore import Qt, QEvent, QRect, QRectF, QPoint, QSize
+from PyQt5.QtCore import Qt, QEvent, QRect, QRectF, QPoint, QSize,QTimer
 
 # Graphs
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
@@ -196,11 +196,17 @@
         0.8627451 , 0.74509804, 0.58823529, 0.39215686, 0.19607843]])
 
 class ZoomableGraphicsView(QGraphicsView):
-    def __init__(self):
+    def __init__(self,cursor_style='cross'):
         super().__init__()
         self.setScene(QGraphicsScene())
+        self.cursor_style=cursor_style
+
+        if self.cursor_style=='cross':
+            self.viewport().setCursor(Qt.CrossCursor)
+            self.cursor_style = 'cross'
+            print('Cross Cursor selected')
+
         self.setDragMode(QGraphicsView.ScrollHandDrag)
-        self.setCursor(Qt.OpenHandCursor)
         self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
         self.pixmap_item = None  # check if image loaded
 
@@ -216,6 +222,22 @@
         zoom = zoom_in_factor if event.angleDelta().y() > 0 else zoom_out_factor
         self.scale(zoom, zoom)
 
+    def enterEvent(self, event):
+        super().enterEvent(event)
+        self.update_cursor()
+
+    def mousePressEvent(self, event):
+        super().mousePressEvent(event)
+        self.update_cursor()
+
+    def mouseReleaseEvent(self, event):
+        super().mouseReleaseEvent(event)
+        self.update_cursor()
+
+    def update_cursor(self):
+        if self.cursor_style == 'cross':
+            self.viewport().setCursor(Qt.CrossCursor)
+
 class GroundTruthWidget(QWidget, Ui_GroundTruthWidget):
     cubeLoaded = QtCore.pyqtSignal(str)
     cube_saved = QtCore.pyqtSignal(CubeInfoTemp)
@@ -236,8 +258,8 @@
         n0 = self.nclass_box.value()
 
         # Replace placeholders with custom widgets
-        self._replace_placeholder('viewer_left', ZoomableGraphicsView)
-        self._replace_placeholder('viewer_right', ZoomableGraphicsView)
+        self._replace_placeholder('viewer_left', ZoomableGraphicsView,cursor_style='cross')
+        self._replace_placeholder('viewer_right', ZoomableGraphicsView,cursor_style='hand')
         self._promote_canvas('spec_canvas', FigureCanvas)
 
         self.viewer_left.viewport().installEventFilter(self)
@@ -251,9 +273,9 @@
         # Promote spec_canvas placeholder to FigureCanvas
         self.spec_canvas_layout = self.spec_canvas.layout() if hasattr(self.spec_canvas, 'layout') else None
         self.init_spectrum_canvas()
-        self.spec_canvas.setVisible(True)
+        # self.spec_canvas.setVisible(True)
         self.show_selection=True
-        self.live_spectra_update=True
+        self.checkBox_live_spectra.setChecked(True)
 
         # State variables
         self.cube = None
@@ -282,8 +304,9 @@
         self.pushButton_merge.clicked.connect(self.merge_selec_GT)
         self.pushButton_class_name_assign.clicked.connect(self.open_label_table)
         self.pushButton_band_selection.toggled.connect(self.band_selection)
-        self.pushButton_keep_GT.clicked.connect(self.keep_GT)
+        self.pushButton_save_GT.clicked.connect(self.save_GT)
         self.pushButton_reset.clicked.connect(self.reset_all)
+        self.checkBox_seeGTspectra.toggled.connect(self.update_spectra)
 
         # RGB sliders <-> spinboxes
         self.sliders_rgb = [self.horizontalSlider_red_channel, self.horizontalSlider_green_channel,
@@ -303,7 +326,7 @@
         self.horizontalSlider_transparency_GT.valueChanged.connect(self.on_alpha_change)
 
         # Live spectrum checkbox
-        self.live_cb.stateChanged.connect(self.toggle_live)
+        self.checkBox_live_spectra.stateChanged.connect(self.toggle_live)
 
         self.distance_funcs = {
             'sqeuclidean': spdist.sqeuclidean,
@@ -371,9 +394,10 @@
 
         if event.type() == QEvent.MouseButtonPress and event.button() == Qt.MiddleButton:
             if not self.selecting_pixels:
-                self.live_spectra_update=not self.live_spectra_update
+                self.checkBox_live_spectra.toggle()
 
-        # 2) Mouvement souris → mise à jour de la selection en cours
+
+        # if mouse moove , updtate selection
         if event.type() == QEvent.MouseMove and self._pixel_selecting and mode == 'pixel':
             if not (self.selecting_pixels or self.erase_selection):
                 return False
@@ -410,7 +434,7 @@
             self.ellipse_item.setRect(rect)
             return True
 
-        # 3) Relâchement souris → calcul de la sélection
+        # mouse realeas
 
         if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton and mode == 'pixel' and self._pixel_selecting :
             if not (self.selecting_pixels or self.erase_selection):
@@ -506,8 +530,8 @@
             return True
 
         # 4) Mouvement souris pour le live spectrum
-        if source is self.viewer_left.viewport() and event.type() == QEvent.MouseMove and self.live_spectra_update:
-            if self.live_cb.isChecked() and self.data is not None:
+        if source is self.viewer_left.viewport() and event.type() == QEvent.MouseMove and self.checkBox_live_spectra.isChecked():
+            if self.checkBox_live_spectra.isChecked() and self.data is not None:
                 pos = self.viewer_left.mapToScene(event.pos())
                 x,y=int(pos.x()),int(pos.y())
                 H, W = self.data.shape[0], self.data.shape[1]
@@ -519,7 +543,7 @@
         # return super().eventFilter(source, event)
         return False
 
-    def keep_GT(self):
+    def save_GT(self):
         # On envoie dans metadata : map de GT, class_counts (pixels_averaged), 'GT_cmap','spectra_mean','spectra_std'
 
         if self.cls_map is None:
@@ -539,13 +563,16 @@
         self.cube.cube_info.metadata_temp['spectra_mean']=list(self.class_means.values())
         self.cube.cube_info.metadata_temp['spectra_std']=list(self.class_stds.values())
 
+        file_name_default = self.cube.cube_info.filepath.split('.')[0]+"_GT"
+
         if  hasattr(self, 'GT_image'):
             path, _ = QFileDialog.getSaveFileName(
                 self,
                 "Save segmentation image",
-                "",
-                "PNG (*.png)"
+                file_name_default,
+                "PNG (*.png)",
             )
+
             if not path:
                 return
 
@@ -609,7 +636,7 @@
         self.show_selection=True
         self.pushButton_class_selection.setText("Stop Selection")
         self.pushButton_erase_selected_pix.setChecked(False)
-        self.live_spectra_update=False # to bloc tracking
+        self.checkBox_live_spectra.setChecked(False) # to bloc tracking
 
         if len(self.samples)>0 :
             reply = QMessageBox.question(
@@ -625,8 +652,6 @@
 
         self.selecting_pixels = True
         # self.viewer_left.setDragMode(QGraphicsView.NoDrag)
-        self.viewer_left.setCursor(Qt.CrossCursor)
-        self.viewer_left.viewport().setCursor(Qt.CrossCursor)
         self.show_image()
 
     def toggle_show_selection(self):
@@ -640,8 +665,6 @@
 
         # ready to select
         self.viewer_left.setDragMode(QGraphicsView.ScrollHandDrag)
-        self.viewer_left.setCursor(Qt.ArrowCursor)
-        self.viewer_left.viewport().setCursor(Qt.ArrowCursor)
 
         # remet le bouton à l'état initial
         self.pushButton_class_selection.setText("Start Selection")
@@ -665,12 +688,10 @@
             self.pushButton_erase_selected_pix.setText("Stop Erasing")
             self.pushButton_class_selection.setChecked(False)
             # self.viewer_left.setDragMode(QGraphicsView.NoDrag)
-            self.viewer_left.setCursor(Qt.CrossCursor)
 
         else:
             self.pushButton_erase_selected_pix.setText("Erase Pixels")
             self.viewer_left.setDragMode(QGraphicsView.ScrollHandDrag)
-            self.viewer_left.unsetCursor()
 
     def on_toggle_selection(self, checked: bool):
 
@@ -827,8 +848,6 @@
             placeholder.deleteLater()
             self.verticalLayout.addWidget(self.spec_canvas)
 
-        self.spec_canvas.setVisible(True)
-
     def _on_bandselect(self, lambda_min, lambda_max):
         """
         Callback  SpanSelector
@@ -986,17 +1005,19 @@
 
     def update_spectra(self,x=None,y=None):
         self.spec_ax.clear()
+        self.spec_ax.grid(color='black')
         x_graph = self.wl
-
+        maxR = 1
         if x is not None and y is not None:
             if 0 <= x < self.data.shape[1] and 0 <= y < self.data.shape[0]:
                 spectrum = self.data[y, x, :]
                 # Spectre du pixel
                 self.spec_ax.plot(x_graph, spectrum, label='Pixel')
-                self.spec_ax.grid(color='black')
+                if np.max(spectrum) > maxR: maxR = np.max(spectrum)
 
         # Spectres GT moyens ± std
         if self.checkBox_seeGTspectra.isChecked() and hasattr(self, 'class_means'):
+            maxR = 1
             for c, mu in self.class_means.items():
                 std = self.class_stds[c]
                 b, g, r = self.class_colors[c]
@@ -1009,10 +1030,15 @@
                     x_graph, mu, '--',
                     color=col, label=f"Class {c}"
                 )
+                if np.max(mu + std) > maxR: maxR = np.max(mu + std)
+
             if self.spec_ax.get_legend_handles_labels()[1]:
                 self.spec_ax.legend(loc='upper right', fontsize='small')
+
             self.spec_ax.set_title(f"Spectra")
-            self.spec_canvas.setVisible(True)
+            self.spec_ax.set_xlim((x_graph[0], x_graph[-1] + maxR))
+            self.spec_ax.set_ylim((0, 0.05 + maxR))
+
 
         for patch in self.selected_span_patch:
             # patch est un PolyCollection produit par axvspan()
@@ -1027,11 +1053,8 @@
         self.show_image()
 
     def toggle_live(self, state):
-        if not state:
-            self.spec_canvas.setVisible(False)
-        else:
-            self.update_spectra()
-            self.live_spectra_update=True
+
+        self.update_spectra()
 
     def load_cube(self,cube_info=None,path=None):
 
@@ -1132,7 +1155,6 @@
             self._erase_mask = None
         # 5. UI
         # Masquer le canvas de spectres
-        self.spec_canvas.setVisible(False)
         self.selecting_pixels = False
         self.erase_selection = False
         self.pushButton_class_selection.setChecked(False)
@@ -1615,17 +1637,16 @@
         self._pixel_selecting = False
         self._pixel_coords = []
         self.alpha = self.horizontalSlider_transparency_GT.value() / 100.0
-        self.live_spectra_update = True
+        self.checkBox_live_spectra.setChecked(True)
 
         # Spectrum plot UI
         self.spec_ax.clear()
         self.spec_canvas.draw_idle()
-        self.spec_canvas.setVisible(False)
         self.pushButton_class_selection.setChecked(False)
         self.pushButton_erase_selected_pix.setChecked(False)
         self.checkBox_see_selection_overlay.setChecked(True)
         self.checkBox_seeGTspectra.setChecked(True)
-        self.live_cb.setChecked(True)
+        self.checkBox_live_spectra.setChecked(True)
 
         # Clear legend layout
         while self.frame_legend.layout().count():
@@ -1641,15 +1662,14 @@
         self.viewer_left.setImage(self._np2pixmap(blank))
         self.viewer_right.setImage(self._np2pixmap(blank))
 
-
 if __name__=='__main__':
 
     app = QApplication(sys.argv)
     w = GroundTruthWidget()
-    # folder=r'C:\Users\Usuario\Documents\DOC_Yannick\HYPERDOC Database\Samples\minicubes/'
-    # file_name='00278-SWIR-mock-up.h5'
-    # filepath=folder+file_name
-    # w.load_cube(path=filepath)
+    folder=r'C:\Users\Usuario\Documents\DOC_Yannick\HYPERDOC Database\Samples\minicubes/'
+    file_name='00278-SWIR-mock-up.h5'
+    filepath=folder+file_name
+    w.load_cube(path=filepath)
     w.show()
     sys.exit(app.exec_())
 
Index: registration/register_tool.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># cd C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\registration\r\n# python -m PyQt5.uic.pyuic -o registration_window.py registration_window.ui\r\n# pyinstaller --noconsole --exclude-module tensorflow --exclude-module torch --icon=\"registration_icon.ico\"   register_tool.py\r\n\r\nimport sys\r\nimport os\r\nimport warnings\r\n\r\nimport numpy as np\r\nimport cv2\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QMainWindow, QVBoxLayout, QPushButton, QSpinBox, QProgressBar,\r\n    QLabel, QFileDialog, QHBoxLayout, QMessageBox, QComboBox, QDialog, QLineEdit,\r\n    QGraphicsView, QGraphicsScene, QGraphicsPixmapItem, QRubberBand, QFormLayout, QDialogButtonBox\r\n)\r\nfrom PyQt5.QtGui import QPixmap, QImage, QTransform, QPen, QColor\r\nfrom PyQt5.QtCore import Qt, QPointF, QRectF, QRect, QPoint, QSize, pyqtSignal, QStandardPaths\r\nfrom PyQt5 import QtCore\r\n\r\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\r\n\r\nfrom registration.registration_window import *\r\nfrom hypercubes.hypercube import *\r\nfrom interface.some_widget_for_interface import LoadingDialog\r\n# TODO : Manual outling features\r\n# TODO : Clean Cache to to well od close and save as.\r\n# TODO : Trier les save depuis tool et depuis main -> Metadatas a bien reflechir.\r\n# TODO : automatic fill name for saving\r\n\r\nfrom registration.registration_window import*\r\nfrom hypercubes.hypercube import*\r\nfrom interface.some_widget_for_interface import LoadingDialog\r\n\r\ndef np_to_qpixmap(img):\r\n    if len(img.shape) == 2:\r\n        try:\r\n            qimg = QImage(img.data, img.shape[1], img.shape[0], img.strides[0], QImage.Format_Grayscale8)\r\n        except:\r\n            if img.dtype != np.uint8:\r\n                img = img.astype(np.uint8)\r\n            qimg = QImage(img.tobytes(), img.shape[1], img.shape[0],img.shape[1], QImage.Format_Grayscale8)\r\n\r\n    else:\r\n        rgb_image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\r\n        qimg = QImage(rgb_image.data, rgb_image.shape[1], rgb_image.shape[0], rgb_image.strides[0], QImage.Format_RGB888)\r\n    return QPixmap.fromImage(qimg).copy()\r\n\r\ndef overlay_color_blend(fixed, aligned):\r\n    blended = cv2.merge([\r\n        cv2.normalize(fixed, None, 0, 255, cv2.NORM_MINMAX),\r\n        cv2.normalize(aligned, None, 0, 255, cv2.NORM_MINMAX),\r\n        cv2.normalize(fixed, None, 0, 255, cv2.NORM_MINMAX)\r\n    ])\r\n    return blended\r\n\r\ndef overlay_checkerboard(fixed, aligned, tile_size=20):\r\n    result = np.zeros_like(fixed)\r\n    for y in range(0, fixed.shape[0], tile_size):\r\n        for x in range(0, fixed.shape[1], tile_size):\r\n            if ((x // tile_size) + (y // tile_size)) % 2 == 0:\r\n                result[y:y+tile_size, x:x+tile_size] = fixed[y:y+tile_size, x:x+tile_size]\r\n            else:\r\n                result[y:y+tile_size, x:x+tile_size] = aligned[y:y+tile_size, x:x+tile_size]\r\n    return result\r\n\r\ndef find_paired_cube_path(current_path):\r\n    \"\"\"\r\n    À partir du chemin d'un cube VNIR ou SWIR, essaie de trouver son homologue.\r\n    Retourne le chemin du fichier si trouvé, sinon None.\r\n    \"\"\"\r\n    if not current_path:\r\n        return None\r\n\r\n    dirname, basename = os.path.split(current_path)\r\n\r\n    if \"SWIR\" in basename:\r\n        alt_name = basename.replace(\"SWIR\", \"VNIR\")\r\n    elif \"VNIR\" in basename:\r\n        alt_name = basename.replace(\"VNIR\", \"SWIR\")\r\n    else:\r\n        return None  # Aucun tag identifiable\r\n\r\n    alt_path = os.path.join(dirname, alt_name)\r\n    return alt_path if os.path.exists(alt_path) else None\r\n\r\n\r\nclass ZoomableGraphicsView(QGraphicsView):\r\n    middleClicked = pyqtSignal(QPointF) # suppres features\r\n    moveFeatureStart = pyqtSignal(QPointF) # movefeatures\r\n    moveFeatureUpdate = pyqtSignal(QPointF)\r\n    moveFeatureEnd = pyqtSignal()\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setScene(QGraphicsScene())\r\n        self.setDragMode(QGraphicsView.ScrollHandDrag)\r\n        self.setCursor(Qt.OpenHandCursor)\r\n        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\r\n        self.pixmap_item = None  # check if image loaded\r\n\r\n        # Rubber band selection\r\n        self.origin = QPoint()\r\n        self.rubber_band = QRubberBand(QRubberBand.Rectangle, self)\r\n        self._selecting = False\r\n        self.last_rect_item = None\r\n        self.rect_coords = None\r\n\r\n        # Moving point\r\n        self.editing_match = None  # (match_index, side: \"left\"/\"right\")\r\n        self.setMouseTracking(True)  # enable mouseMoveEvent without press\r\n\r\n    def setImage(self, pixmap):\r\n        self.clear_rectangle()\r\n        self.scene().clear()\r\n        self.pixmap_item = QGraphicsPixmapItem(pixmap)\r\n        self.scene().addItem(self.pixmap_item)\r\n        self.setSceneRect(QRectF(pixmap.rect()))\r\n\r\n    def wheelEvent(self, event):\r\n        zoom_in_factor = 1.25\r\n        zoom_out_factor = 1 / zoom_in_factor\r\n        zoom = zoom_in_factor if event.angleDelta().y() > 0 else zoom_out_factor\r\n        self.scale(zoom, zoom)\r\n\r\n    def mousePressEvent(self, event):\r\n        if event.button() == Qt.RightButton and self.pixmap_item: # rectangle selection\r\n            self.viewport().setCursor(Qt.CrossCursor)\r\n            self.origin = event.pos()\r\n            self.rubber_band.setGeometry(QRect(self.origin, QSize()))\r\n            self.rubber_band.show()\r\n            self._selecting = True\r\n\r\n        elif event.button() == Qt.MiddleButton and self.pixmap_item: # feature supress\r\n            scene_pos = self.mapToScene(event.pos())\r\n            self.middleClicked.emit(scene_pos)\r\n\r\n        elif event.button() == Qt.LeftButton and event.modifiers() == Qt.ControlModifier and self.pixmap_item: # feature supress\r\n            scene_pos = self.mapToScene(event.pos())\r\n            self.middleClicked.emit(scene_pos)\r\n            event.accept()\r\n            return\r\n\r\n        elif event.button() == Qt.LeftButton and event.modifiers() == Qt.AltModifier and self.pixmap_item:\r\n            scene_pos = self.mapToScene(event.pos())\r\n            self.moveFeatureStart.emit(scene_pos)\r\n            event.accept()\r\n            return\r\n\r\n        super().mousePressEvent(event)\r\n\r\n    def mouseMoveEvent(self, event):\r\n        if self._selecting:\r\n            max_w = self.viewport().width() - 1\r\n            max_h = self.viewport().height() - 1\r\n            x = min(max(event.pos().x(), 0), max_w)\r\n            y = min(max(event.pos().y(), 0), max_h)\r\n            rect = QRect(self.origin, QPoint(x, y)).normalized()\r\n            self.rubber_band.setGeometry(rect)\r\n\r\n        elif self.editing_match is not None:\r\n            scene_pos = self.mapToScene(event.pos())\r\n            self.moveFeatureUpdate.emit(scene_pos)\r\n\r\n        super().mouseMoveEvent(event)\r\n\r\n    def mouseReleaseEvent(self, event):\r\n        if event.button() == Qt.RightButton and self.pixmap_item and self._selecting:\r\n            self.rubber_band.hide()\r\n            self.viewport().setCursor(Qt.OpenHandCursor)\r\n            self._selecting = False\r\n\r\n            # Convert view coords to scene coords\r\n            start_scene = self.mapToScene(self.origin)\r\n            end_scene = self.mapToScene(event.pos())\r\n\r\n            # Convert scene coords to pixmap (image) coords\r\n            p1 = self.pixmap_item.mapFromScene(start_scene)\r\n            p2 = self.pixmap_item.mapFromScene(end_scene)\r\n\r\n            x1, y1 = int(p1.x()), int(p1.y())\r\n            x2, y2 = int(p2.x()), int(p2.y())\r\n\r\n            # Clamp aux bords de l'image\r\n            w, h = self.pixmap_item.pixmap().width(), self.pixmap_item.pixmap().height()\r\n            x1 = max(0, min(x1, w - 1))\r\n            x2 = max(0, min(x2, w - 1))\r\n            y1 = max(0, min(y1, h - 1))\r\n            y2 = max(0, min(y2, h - 1))\r\n\r\n            # Erase previous rectangle\r\n            self.clear_rectangle()\r\n\r\n            # Création du rectangle avec coins clampés\r\n            x_min, x_max = sorted([x1, x2])\r\n            y_min, y_max = sorted([y1, y2])\r\n            width, height = x_max - x_min, y_max - y_min\r\n\r\n            if width < 2 or height < 2:\r\n                self.rect_coords = None\r\n                self.last_rect_item = None\r\n                return\r\n\r\n            self.rect_coords = [x_min, y_min, width, height]\r\n            self.last_rect_item = self.scene().addRect(\r\n                x_min, y_min, width, height, QPen(QColor(\"red\"))\r\n            )\r\n\r\n        if self.editing_match is not None:\r\n            self.moveFeatureEnd.emit()\r\n            self.editing_match = None\r\n\r\n        super().mouseReleaseEvent(event)\r\n\r\n    def get_rect_coords(self):\r\n        return self.rect_coords\r\n\r\n    def clear_rectangle(self):\r\n        if self.last_rect_item:\r\n            try:\r\n                self.scene().removeItem(self.last_rect_item)\r\n            except:\r\n                None\r\n        self.last_rect_item = None\r\n        self.rect_coords=None\r\n\r\nclass RegistrationApp(QMainWindow, Ui_MainWindow):\r\n\r\n    alignedCubeReady = pyqtSignal(CubeInfoTemp) # send signal to main\r\n    cubeLoaded = QtCore.pyqtSignal(str)\r\n    cube_saved = pyqtSignal(CubeInfoTemp)\r\n\r\n    def __init__(self,parent=None):\r\n        super().__init__(parent)\r\n        self.setupUi(self)\r\n        self.setWindowTitle(\"Image Registration\")\r\n\r\n        self.fixed_cube = Hypercube()\r\n        self.moving_cube = Hypercube()\r\n        self.aligned_cube= Hypercube()\r\n        self.fixed_img = None\r\n        self.moving_img = None\r\n        self.aligned_img = None\r\n        self.kp1 = None # features positions\r\n        self.kp2 = None\r\n        self.show_features = False #show features in small images\r\n        self.matches= None # only %selected matches\r\n        self.matches_all=None #all matches list\r\n        self.parent_aligned_for_minicubes=None # to use as parent_cube for mincubes extraction\r\n        self.auto_load_lock = False #to control auto_load and do not have infinite loop\r\n\r\n        self.manual_feature_modif=False #to see if manual have been made in features selection\r\n        self.selected_zone=[0,0]\r\n        self.selected_rect_coords=None\r\n\r\n        self.cube=[self.fixed_cube,self.moving_cube]\r\n        self.img=[self.fixed_img,self.moving_img]\r\n        self.radioButton_one=[self.radioButton_one_ref,self.radioButton_one_mov]\r\n        self.radioButton_whole=[self.radioButton_whole_ref,self.radioButton_whole_mov]\r\n        self.slider_channel=[self.horizontalSlider_ref_channel,self.horizontalSlider_mov_channel]\r\n        self.spinBox_channel=[self.spinBox_ref_channel,self.spinBox_mov_channel]\r\n\r\n        self.pushButton_open_ref_hypercube.clicked.connect(self.load_fixed_btn)\r\n        self.pushButton_open_mov_hypercube.clicked.connect(self.load_moving_btn)\r\n        self.pushButton_getFeatures.clicked.connect(self.choose_register_method)\r\n        self.pushButton_register.clicked.connect(self.register_imageAndCube)\r\n        self.checkBox_crop.clicked.connect(self.check_selected_zones)\r\n        self.pushButton_save_cube.clicked.connect(self.open_save_dialog)\r\n        self.pushButton_reset.clicked.connect(self.reset_all)\r\n\r\n        self.pushButton_switch_images.clicked.connect(self.switch_fixe_mov)\r\n\r\n        self.overlay_selector.currentIndexChanged.connect(self.update_display)\r\n\r\n        self.viewer_aligned = ZoomableGraphicsView()\r\n        self.right_layout.addWidget(self.viewer_aligned, stretch=1)\r\n\r\n        self.label_fixed = QLabel(\"Fixed Image\")\r\n        self.left_layout.addWidget(self.label_fixed)\r\n        self.viewer_fixed = ZoomableGraphicsView()\r\n        self.left_layout.addWidget(self.viewer_fixed, stretch=1)\r\n        self.label_moving = QLabel(\"Moving Image\")\r\n        self.left_layout.addWidget(self.label_moving)\r\n        self.viewer_moving = ZoomableGraphicsView()\r\n        self.left_layout.addWidget(self.viewer_moving, stretch=1)\r\n        self.viewer_img=[self.viewer_fixed,self.viewer_moving,self.viewer_aligned]\r\n        self.viewer_label=[self.label_fixed,self.label_moving]\r\n\r\n        self.viewer_aligned.middleClicked.connect(self.middle_click_on_match) #interaction for features supress\r\n        self.viewer_aligned.moveFeatureStart.connect(self.start_move_feature) # move features\r\n        self.viewer_aligned.moveFeatureUpdate.connect(self.update_move_feature)\r\n        self.viewer_aligned.moveFeatureEnd.connect(self.end_move_feature)\r\n\r\n        self.setLayout(self.main_layout)\r\n\r\n        self.label_fixed.setAlignment(Qt.AlignCenter)\r\n        self.label_moving.setAlignment(Qt.AlignCenter)\r\n\r\n        self.horizontalSlider_ref_channel.setEnabled(False)\r\n        self.horizontalSlider_mov_channel.setEnabled(False)\r\n        self.spinBox_ref_channel.setEnabled(False)\r\n        self.spinBox_mov_channel.setEnabled(False)\r\n\r\n        self.horizontalSlider_ref_channel.valueChanged.connect(self.update_images)\r\n        self.horizontalSlider_mov_channel.valueChanged.connect(self.update_images)\r\n\r\n        self.radioButton_whole_ref.toggled.connect(self.update_sliders)\r\n        self.radioButton_whole_mov.toggled.connect(self.update_sliders)\r\n\r\n        self.spinBox_keypointPerPacket.valueChanged.connect(self.update_keypoints_display)\r\n        self.horizontalSlider_keyPacketToShow.valueChanged.connect(self.update_keypoints_display)\r\n        self.features_slider.valueChanged.connect(self.update_slider_packet)\r\n\r\n    def update_sliders(self):\r\n        if self.radioButton_whole_ref.isChecked():\r\n            self.horizontalSlider_ref_channel.setEnabled(False)\r\n            self.spinBox_ref_channel.setEnabled(False)\r\n        else:\r\n            self.horizontalSlider_ref_channel.setEnabled(True)\r\n            self.spinBox_ref_channel.setEnabled(True)\r\n\r\n        if self.radioButton_whole_mov.isChecked():\r\n            self.horizontalSlider_mov_channel.setEnabled(False)\r\n            self.spinBox_mov_channel.setEnabled(False)\r\n\r\n        else:\r\n            self.horizontalSlider_mov_channel.setEnabled(True)\r\n            self.spinBox_mov_channel.setEnabled(True)\r\n\r\n        self.update_images()\r\n\r\n    def update_images(self):\r\n\r\n        for i_mov in [0,1]:\r\n            cube=self.cube[i_mov].data\r\n            wl=self.cube[i_mov].wl\r\n            if cube is not None:\r\n                mode = ['one', 'whole'][self.radioButton_whole[i_mov].isChecked()]\r\n                chan = np.argmin(np.abs(self.slider_channel[i_mov].value() - wl))\r\n                img = self.cube_to_img(cube, mode, chan)\r\n                img = (img * 256 / np.max(img)).astype('uint8')\r\n\r\n                if i_mov:\r\n                    self.moving_img = img\r\n                else:\r\n                    self.fixed_img = img\r\n                self.img = [self.fixed_img, self.moving_img]\r\n\r\n                # self.label_img[i_mov].setPixmap(np_to_qpixmap(img).scaled(300, 300, Qt.KeepAspectRatio))\r\n                self.viewer_img[i_mov].setImage(np_to_qpixmap(img))\r\n\r\n    def load_cube_info(self, ci: CubeInfoTemp):\r\n        \"\"\"\r\n        Used by the manager to inject updated CubeInfoTemp.\r\n        Detects whether the filepath matches the fixed or moving cube.\r\n        \"\"\"\r\n        if self.fixed_cube and self.fixed_cube.cube_info.filepath == ci.filepath:\r\n            self.fixed_cube.cube_info=ci\r\n\r\n        elif self.moving_cube and self.moving_cube.cube_info.filepath == ci.filepath:\r\n            self.moving_cube.cube_info=ci\r\n\r\n        else:\r\n            print(f\"[Warning] CubeInfo path does not match fixed or moving cube: {ci.filepath}\")\r\n\r\n    def load_cube(self,i_mov=None,fname=None,switch=False):\r\n\r\n        if switch:\r\n            # 1) swap the cubes\r\n            old_fixed_cube = self.fixed_cube\r\n            self.fixed_cube = self.moving_cube\r\n            self.moving_cube = old_fixed_cube\r\n            self.cube = [self.fixed_cube, self.moving_cube]\r\n\r\n            # 2) swap the images\r\n            old_fixed_img = self.fixed_img\r\n            self.fixed_img = self.moving_img\r\n            self.moving_img = old_fixed_img\r\n            self.img = [self.fixed_img, self.moving_img]\r\n\r\n            # 3) update sliders & views for both fixed (idx=0) and moving (idx=1)\r\n            for idx in range(2):\r\n                cube_data = self.cube[idx].data\r\n                wl=self.cube[idx].wl\r\n\r\n\r\n                # self.slider_channel[idx].setMaximum(cube_data.shape[2] - 1)\r\n                # self.spinBox_channel[idx].setMaximum(cube_data.shape[2] - 1)\r\n\r\n                self.slider_channel[idx].setMaximum(int(np.max(wl)))\r\n                self.slider_channel[idx].setMinimum(int(np.min(wl)))\r\n                self.slider_channel[idx].setSingleStep(int(wl[1] - wl[0]))\r\n\r\n                self.spinBox_channel[idx].setMaximum(int(np.max(wl)))\r\n                self.spinBox_channel[idx].setMinimum(int(np.min(wl)))\r\n                self.spinBox_channel[idx].setSingleStep(int(wl[1] - wl[0]))\r\n\r\n                # reposition initial channel if needed\r\n                if cube_data.shape[2] == 121:\r\n                    self.slider_channel[idx].setValue(750)\r\n                    self.spinBox_channel[idx].setValue(750)\r\n                elif cube_data.shape[2] == 161:\r\n                    self.slider_channel[idx].setValue(1300)\r\n                    self.spinBox_channel[idx].setValue(1300)\r\n\r\n                # regenerate the image slice\r\n                mode = ['one', 'whole'][self.radioButton_whole[idx].isChecked()]\r\n                chan = np.argmin(np.abs(self.slider_channel[idx].value() - wl))\r\n                img = self.cube_to_img(cube_data, mode, chan)\r\n                img = (img * 256 / np.max(img)).astype('uint8')\r\n\r\n                # clear previous rectangle and display\r\n                self.viewer_img[idx].clear_rectangle()\r\n                self.viewer_img[idx].setImage(np_to_qpixmap(img))\r\n                suffixe_label=[\" (fixed)\",\" (moving)\"][idx]\r\n                self.viewer_label[idx].setText(self.cube[idx].filepath.split('/')[-1]+suffixe_label)\r\n\r\n            return  # important : on sort de la méthode après le switch\r\n\r\n        else :\r\n            if fname is None:\r\n                fname, _ = QFileDialog.getOpenFileName(self, ['Load Fixed Cube','Load Moving Cube'][i_mov])\r\n\r\n            if fname:\r\n                which_cube=['FIXED','MOVING'][i_mov]\r\n                message_progress=  \"[Register Tool] Loading \"+which_cube+\" cube...\"\r\n                loading = LoadingDialog(message_progress, filename=fname, parent=self)\r\n                loading.show()\r\n                QApplication.processEvents()\r\n\r\n                if fname[-3:] in['mat', '.h5']:\r\n                    if i_mov:\r\n                        self.moving_cube.open_hyp(fname, open_dialog=False)\r\n                        cube=self.moving_cube.data\r\n                        wl=self.moving_cube.wl\r\n                        self.cubeLoaded.emit(fname)  # Notify the manager\r\n\r\n\r\n                    else:\r\n                        self.fixed_cube.open_hyp(fname, open_dialog=False)\r\n                        cube=self.fixed_cube.data\r\n                        wl = self.fixed_cube.wl\r\n                        self.cubeLoaded.emit(fname)  # Notify the manager\r\n\r\n                    # Auto-load paired cube if not already loaded\r\n                    paired_path=None\r\n                    if not self.auto_load_lock:\r\n                        paired_path = find_paired_cube_path(fname)\r\n\r\n                        if paired_path:\r\n                            load_fixe_auto = True\r\n                        else:\r\n                            print(f\"[Auto-load] Aucun cube équivalent trouvé pour : {fname}\")\r\n\r\n                    self.cube = [self.fixed_cube, self.moving_cube]\r\n\r\n                    # self.slider_channel[i_mov].setMaximum(cube.shape[2]-1)\r\n                    self.slider_channel[i_mov].setMaximum(int(np.max(wl)))\r\n                    self.slider_channel[i_mov].setMinimum(int(np.min(wl)))\r\n                    self.slider_channel[i_mov].setSingleStep(int(wl[1]-wl[0]))\r\n\r\n                    # self.spinBox_channel[i_mov].setMaximum(cube.shape[2] - 1)\r\n                    self.spinBox_channel[i_mov].setMaximum(int(np.max(wl)))\r\n                    self.spinBox_channel[i_mov].setMinimum(int(np.min(wl)))\r\n                    self.spinBox_channel[i_mov].setSingleStep(int(wl[1] - wl[0]))\r\n\r\n                    if cube.shape[2]==121:\r\n                        self.slider_channel[i_mov].setValue(750)\r\n                        self.spinBox_channel[i_mov].setValue(750)\r\n                    elif cube.shape[2]==161:\r\n                        self.slider_channel[i_mov].setValue(1300)\r\n                        self.spinBox_channel[i_mov].setValue(1300)\r\n\r\n                    mode = ['one', 'whole'][self.radioButton_whole[i_mov].isChecked()]\r\n                    chan = np.argmin(np.abs(self.slider_channel[i_mov].value()-wl))\r\n                    img = self.cube_to_img(cube, mode, chan)\r\n                    img =(img * 256 / np.max(img)).astype('uint8')\r\n                else:\r\n                    img = cv2.imread(fname, cv2.IMREAD_GRAYSCALE)\r\n\r\n                self.viewer_img[i_mov].clear_rectangle()\r\n\r\n                if i_mov:\r\n                    self.moving_img=img\r\n                else:\r\n                    self.fixed_img = img\r\n\r\n                self.img = [self.fixed_img, self.moving_img]\r\n\r\n                self.viewer_img[i_mov].setImage(np_to_qpixmap(img))\r\n                suffixe_label = [\" (fixed)\", \" (moving)\"][i_mov]\r\n                self.viewer_label[i_mov].setText(self.cube[i_mov].filepath.split('/')[-1] + suffixe_label)\r\n\r\n                loading.close()\r\n\r\n            if not self.auto_load_lock and paired_path is not None:\r\n                self.auto_load_lock = True\r\n                self.load_cube(i_mov=1 - i_mov, fname=paired_path)\r\n                self.auto_load_lock = False\r\n\r\n        self.pushButton_register.setEnabled(False)\r\n\r\n    def load_fixed_btn(self,fname=None):\r\n        self.load_cube(0)\r\n\r\n    def load_moving_btn(self,fname=None):\r\n        self.load_cube(1)\r\n\r\n    def cube_to_img(self,cube,mode,chan):\r\n        if mode=='whole':\r\n            return np.mean(cube, axis=2).astype(np.float32)\r\n        elif mode=='one':\r\n            return cube[:,:,chan]\r\n\r\n    def choose_register_method(self):\r\n        if self.fixed_img is None or self.moving_img is None:\r\n            QMessageBox.warning(self, \"Error\", \"Please load both images first.\")\r\n            return\r\n\r\n        method = self.method_selector.currentText()\r\n        if method == \"ORB\":\r\n            self.get_features(cv2.ORB_create(5000))\r\n        elif method == \"AKAZE\":\r\n            self.get_features(cv2.AKAZE_create())\r\n        elif method == \"SIFT\":\r\n            self.get_features(cv2.SIFT_create())\r\n        else:\r\n            QMessageBox.warning(self, \"Error\", \"Unknown method.\")\r\n\r\n    def get_features(self, detector):\r\n\r\n        if not self.checkBox_autorize_modify.isChecked():\r\n            QMessageBox.warning(self,'Not autorized','Check Autorize modifying registered cube. \\nDoing this, you will loose actual parent cube for minicube extraction.')\r\n            return\r\n\r\n        crop = False\r\n        fixed = self.fixed_img\r\n        moving = self.moving_img\r\n        if self.checkBox_crop.isChecked():\r\n            self.check_selected_zones()\r\n            if self.selected_zone.count(1)==0:\r\n                return\r\n            else:\r\n                crop=True\r\n                if self.selected_zone[0]==1:\r\n                    y, x, dy, dx=self.viewer_img[0].get_rect_coords()\r\n                    fixed = self.fixed_img[x:x + dx, y:y + dy]\r\n                    kp1, des1 = detector.detectAndCompute(fixed, None)\r\n                    for kp in kp1:\r\n                        kp.pt = (kp.pt[0] + y, kp.pt[1] + x)\r\n                if self.selected_zone[1] == 1:\r\n                    y, x, dy, dx = self.viewer_img[1].get_rect_coords()\r\n                    moving = self.moving_img[x:x + dx, y:y + dy]\r\n                    kp2, des2 = detector.detectAndCompute(moving, None)\r\n                    for kp in kp2:\r\n                        kp.pt = (kp.pt[0] + y, kp.pt[1] + x)\r\n\r\n        if not crop :\r\n            kp1, des1 = detector.detectAndCompute(fixed, None)\r\n            kp2, des2 = detector.detectAndCompute(moving, None)\r\n\r\n        try :\r\n            if des1 is None or des2 is None:\r\n                QMessageBox.warning(self, \"Error\", \"Feature detection failed.\")\r\n                return\r\n\r\n        except:\r\n            QMessageBox.warning(self, \"Error\",\r\n                                \"Select a rectangle in both cubes or erase all.\")\r\n            return\r\n\r\n\r\n        self.kp1, self.kp2 = kp1, kp2\r\n\r\n        matcher = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)\r\n\r\n        matches = matcher.match(des1, des2)\r\n        self.matches_all = sorted(matches, key=lambda x: x.distance)\r\n\r\n        self.register_imageAndCube()\r\n\r\n    def register_imageAndCube(self):\r\n\r\n        if not self.checkBox_autorize_modify.isChecked():\r\n            QMessageBox.warning(self,'Not autorized','Check Autorize modifying registered cube. \\nDoing this, you will loose actual parent cube for minicube extraction.')\r\n            return\r\n\r\n        # Keep only the top percentage of matches\r\n        keep_percent = self.features_slider.value() / 100\r\n        num_keep = int(len(self.matches_all) * keep_percent)\r\n        self.matches = self.matches_all[:num_keep]\r\n\r\n        src_pts = np.float32([self.kp2[m.trainIdx].pt for m in self.matches]).reshape(-1, 1, 2)\r\n        dst_pts = np.float32([self.kp1[m.queryIdx].pt for m in self.matches]).reshape(-1, 1, 2)\r\n\r\n        transform_type = self.transform_selector.currentText()\r\n        registration_done=False\r\n\r\n        if transform_type == \"Affine\":\r\n            # Need at least 3 point pairs for affine\r\n            if len(self.matches) < 3:\r\n                QMessageBox.warning(self, \"Error\",\r\n                                    \"At least 3 matches are required for an affine transform.\")\r\n                return\r\n\r\n            try:\r\n                matrix, inliers = cv2.estimateAffinePartial2D(src_pts, dst_pts)\r\n            except cv2.error as e:\r\n                QMessageBox.warning(self, \"OpenCV Error\",\r\n                                    f\"Affine estimation failed:\\n{e}\")\r\n                return\r\n\r\n            # Check matrix validity\r\n            if matrix is None or matrix.shape != (2, 3):\r\n                QMessageBox.warning(self, \"Error\",\r\n                                    \"Failed to compute a valid affine matrix.\")\r\n                return\r\n\r\n            # Ensure correct dtype for warpAffine\r\n            matrix = matrix.astype(np.float32)\r\n\r\n            # Warp the moving image\r\n            self.aligned_img = cv2.warpAffine(self.moving_img, matrix,\r\n                                              (self.fixed_img.shape[1], self.fixed_img.shape[0]))\r\n\r\n            # Prepare an empty numpy array for the aligned cube\r\n            h, w = self.fixed_img.shape[:2]\r\n            depth = self.moving_cube.data.shape[2]\r\n            aligned_arr = np.zeros((h, w, depth), dtype=np.float32)\r\n\r\n            # Convert each slice out of the memoryview and warp it\r\n            for k in range(depth):\r\n                slice_k = np.asarray(self.moving_cube.data[:, :, k])\r\n                aligned_arr[:, :, k] = cv2.warpAffine(slice_k, matrix, (w, h))\r\n\r\n            registration_done=True\r\n\r\n        elif transform_type == \"Perspective\":\r\n\r\n            # Need at least 4 point pairs for homography\r\n\r\n            if len(self.matches) < 4:\r\n                QMessageBox.warning(self, \"Registration Error\",\r\n\r\n                                    \"At least 4 matches are required for a homography.\\n\"\r\n\r\n                                    \"Please try again with better images.\")\r\n\r\n                return\r\n\r\n            try:\r\n\r\n                matrix, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC)\r\n\r\n            except cv2.error as e:\r\n\r\n                QMessageBox.warning(self, \"OpenCV Error\",\r\n\r\n                                    f\"Homography estimation failed:\\n{e}\")\r\n\r\n                return\r\n\r\n            if matrix is None or matrix.shape != (3, 3):\r\n                QMessageBox.warning(self, \"Error\",\r\n\r\n                                    \"Failed to compute a valid homography matrix.\")\r\n\r\n                return\r\n\r\n            # Warp the moving image\r\n\r\n            self.aligned_img = cv2.warpPerspective(self.moving_img, matrix,\r\n\r\n                                                   (self.fixed_img.shape[1], self.fixed_img.shape[0]))\r\n\r\n            # Prepare an empty numpy array for the aligned cube\r\n\r\n            h, w = self.fixed_img.shape[:2]\r\n\r\n            depth = self.moving_cube.data.shape[2]\r\n\r\n            aligned_arr = np.zeros((h, w, depth), dtype=np.float32)\r\n\r\n            # Convert each slice out of the memoryview and warp it\r\n\r\n            for k in range(depth):\r\n                slice_k = np.asarray(self.moving_cube.data[:, :, k])\r\n\r\n                aligned_arr[:, :, k] = cv2.warpPerspective(slice_k, matrix, (w, h))\r\n\r\n            registration_done=True\r\n\r\n        else:\r\n            QMessageBox.warning(self, \"Error\", \"Unsupported transformation.\")\r\n            return\r\n\r\n        if registration_done:\r\n            # Replace aligned_cube with a proper Hypercube\r\n            self.aligned_cube = Hypercube(data=aligned_arr,\r\n                                          wl=self.moving_cube.wl,\r\n                                          metadata=self.moving_cube.metadata)\r\n            self.aligned_cube.cube_info=self.moving_cube.cube_info\r\n\r\n        self.update_display()\r\n        self.pushButton_register.setEnabled(True)\r\n        self.pushButton_save_cube.setEnabled(True)\r\n        self.parent_aligned_for_minicubes = None\r\n\r\n    def choose_register_method_ecc(self):\r\n        try:\r\n            fixed_f = self.fixed_img.astype(np.float32) / 255\r\n            moving_f = self.moving_img.astype(np.float32) / 255\r\n\r\n            warp_mode = cv2.MOTION_AFFINE\r\n            warp_matrix = np.eye(2, 3, dtype=np.float32)\r\n\r\n            criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 5000, 1e-6)\r\n            cc, warp_matrix = cv2.findTransformECC(fixed_f, moving_f, warp_matrix, warp_mode, criteria)\r\n\r\n            self.aligned_img = cv2.warpAffine(self.moving_img, warp_matrix, (self.fixed_img.shape[1], self.fixed_img.shape[0]), flags=cv2.INTER_LINEAR + cv2.WARP_INVERSE_MAP)\r\n            self.update_display()\r\n        except Exception as e:\r\n            QMessageBox.warning(self, \"ECC Error\", str(e))\r\n\r\n    def update_display(self):\r\n        if self.fixed_img is None or self.aligned_img is None:\r\n            return\r\n        if self.fixed_img.shape != self.aligned_img.shape:\r\n            QMessageBox.warning(self,\"Error\", \"Get feature and register before.\")\r\n            return\r\n\r\n        display_mode = self.overlay_selector.currentText()\r\n        img=None\r\n        if display_mode == \"Color\":\r\n            img = overlay_color_blend(self.fixed_img, self.aligned_img)\r\n        elif display_mode == \"Checkboard\":\r\n            img = overlay_checkerboard(self.fixed_img, self.aligned_img)\r\n        elif display_mode == \"View Matches\":\r\n            self.update_keypoints_display()\r\n        elif display_mode == \"Only aligned\":\r\n            img = self.aligned_img\r\n\r\n        # Display the final aligned image\r\n        if img is not None:\r\n            self.viewer_aligned.setImage(np_to_qpixmap(img))\r\n\r\n    def update_keypoints_display(self):\r\n\r\n        if self.matches_all is None:\r\n            return\r\n\r\n        self.update_slider_packet()\r\n\r\n        keypoints_per_packet = self.spinBox_keypointPerPacket.value()\r\n        packet_idx = self.horizontalSlider_keyPacketToShow.value()\r\n\r\n        start_idx = packet_idx * keypoints_per_packet\r\n        end_idx = start_idx + keypoints_per_packet\r\n        selected_matches = self.matches_all[start_idx:end_idx]\r\n        self.match_display_to_global_index = {\r\n            i: start_idx + i for i in range(len(selected_matches))\r\n        } #to keep corespondace between displayed number and number in the feature list\r\n\r\n        # Créer une image combinée côte à côte\r\n        fixed_img_vis = cv2.cvtColor(self.fixed_img, cv2.COLOR_GRAY2BGR) if len(\r\n            self.fixed_img.shape) == 2 else self.fixed_img.copy()\r\n        moving_img_vis = cv2.cvtColor(self.moving_img, cv2.COLOR_GRAY2BGR) if len(\r\n            self.moving_img.shape) == 2 else self.moving_img.copy()\r\n\r\n        # S'assurer que les deux images ont la même hauteur\r\n        max_height = max(fixed_img_vis.shape[0], moving_img_vis.shape[0])\r\n        fixed_img_vis = cv2.copyMakeBorder(fixed_img_vis, 0, max_height - fixed_img_vis.shape[0], 0, 0,\r\n                                           cv2.BORDER_CONSTANT)\r\n        moving_img_vis = cv2.copyMakeBorder(moving_img_vis, 0, max_height - moving_img_vis.shape[0], 0, 0,\r\n                                            cv2.BORDER_CONSTANT)\r\n\r\n        combined = np.hstack((fixed_img_vis, moving_img_vis))\r\n\r\n        def index_to_color(idx):\r\n            # Une fonction simple pour faire un \"arc-en-ciel\" déterministe\r\n            r = (37 * idx) % 256\r\n            g = (97 * idx) % 256\r\n            b = (173 * idx) % 256\r\n            return (r, g, b)\r\n\r\n        for i, m in enumerate(selected_matches):\r\n            kp1 = self.kp1[m.queryIdx]\r\n            kp2 = self.kp2[m.trainIdx]\r\n\r\n            pt1 = tuple(np.round(kp1.pt).astype(int))\r\n            pt2 = tuple(np.round(kp2.pt).astype(int))\r\n            pt2_shifted = (int(pt2[0] + fixed_img_vis.shape[1]), pt2[1])  # Décalage pour image de droite\r\n\r\n            color = index_to_color(start_idx + i)\r\n            cv2.circle(combined, pt1, 5, color, thickness = 2)\r\n            cv2.circle(combined, pt2_shifted, 5, color, thickness = 2)\r\n            cv2.line(combined, pt1, pt2_shifted, color, thickness = 2)\r\n            cv2.putText(combined, str(i), (pt1[0] + 6, pt1[1] - 6), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)\r\n            cv2.putText(combined, str(i), (pt2_shifted[0] + 6, pt2_shifted[1] - 6), cv2.FONT_HERSHEY_SIMPLEX, 0.5,\r\n                        color, 1)\r\n\r\n        self.currently_displayed_matches = selected_matches\r\n        self.match_display_to_global_index = {\r\n            i: start_idx + i for i in range(len(selected_matches))\r\n        }\r\n\r\n        self.viewer_aligned.setImage(np_to_qpixmap(combined))\r\n\r\n    def update_slider_packet(self):\r\n        # update max slider\r\n        if self.matches_all is None:\r\n            return\r\n\r\n        n_features=len(self.matches_all)\r\n        n_features_per_packet=self.spinBox_keypointPerPacket.value()\r\n        n_packet=int(n_features/n_features_per_packet)\r\n        # if n_features%n_features_per_packet !=0:\r\n        #     n_packet+=1\r\n        self.horizontalSlider_keyPacketToShow.setMaximum(n_packet)\r\n        # update label\r\n        packet_show=self.horizontalSlider_keyPacketToShow.value()\r\n        feat_start=packet_show*n_features_per_packet\r\n        feat_stop=(packet_show+1)*n_features_per_packet-1\r\n        if feat_stop>=n_features:feat_stop=n_features\r\n        self.label_packetToShow.setText(f\"features {feat_start} to {feat_stop} / {n_features}\")\r\n        if packet_show>n_packet*self.features_slider.value()/ 100:\r\n            self.label_packetToShow.setStyleSheet(u\"color: rgb(255, 0, 0);\")\r\n        else:\r\n            self.label_packetToShow.setStyleSheet(u\"color: rgb(0, 0, 0);\")\r\n\r\n    def check_selected_zones(self):\r\n        if self.checkBox_crop.isChecked():\r\n            for i in range(2):\r\n                    self.selected_zone[i]=(self.viewer_img[i].get_rect_coords() is not None)\r\n\r\n            n_selected_zone = self.selected_zone.count(1)\r\n\r\n            if  n_selected_zone==0:\r\n                msg = QMessageBox()\r\n                msg.setIcon(QMessageBox.Warning)\r\n                msg.setWindowTitle(\"Error\")\r\n                msg.setText(\"No zone selected. Please select a rectangle.\")\r\n                msg.exec_()\r\n                self.checkBox_crop.setChecked(False)\r\n\r\n                return\r\n\r\n    def open_save_dialog(self):\r\n        \"\"\"Ouvre la dialog SaveWindow, récupère les options et déclenche la sauvegarde.\"\"\"\r\n        dialogWindow = SaveWindow(self)\r\n        # Affiche en modal : si OK, on récupère les options\r\n        if dialogWindow.exec_() == QDialog.Accepted:\r\n            opts = dialogWindow.get_options()\r\n            self.save_cube_with_options(opts)\r\n\r\n    def save_cube_with_options(self, opts):\r\n        \"\"\"\r\n        Sauvegarde les cubes et images selon le dict opts retourné par SaveWindow.get_options().\r\n        \"\"\"\r\n        save_path_align=None\r\n        save_path_fixed=None\r\n        save_both = opts['save_both']\r\n\r\n        flag_save_aligned=False #to follow if parent cube\r\n\r\n        if opts['crop_cube']:\r\n\r\n            if self.parent_aligned_for_minicubes is None:\r\n                msg_box = QMessageBox(self)\r\n                msg_box.setWindowTitle(\"No parent cube ! \")\r\n                msg_box.setIcon(QMessageBox.Question)\r\n                msg_box.setText(\r\n                    \"You choosed to keep only the selected part of the whole cube but you have not saved the whole registered cube first.\\nThe minicubes would not have accurate parent cubes. \\n Do you want to first save the whole cube aligned ?\")\r\n\r\n                only_whole_aligned = msg_box.addButton(\"Yes, Save whole aligned cube first\", QMessageBox.ActionRole)\r\n                cropped = msg_box.addButton(\"No, just minicubes\", QMessageBox.ActionRole)\r\n                msg_box.exec()\r\n\r\n                if msg_box.clickedButton() == only_whole_aligned:\r\n                    save_both = False\r\n                    opts['crop_cube'] = False\r\n                    flag_save_aligned = True\r\n\r\n                if not flag_save_aligned:\r\n\r\n                    if self.viewer_aligned.get_rect_coords() is None:\r\n                        QMessageBox.warning(self, 'NO selected zone',\r\n                                            'NO selected zone in the aligned cube.\\nSelect first a rectangle with the right click or do not check \"Croped cubes\" on saving')\r\n                        return\r\n\r\n            if not save_both and not flag_save_aligned:\r\n\r\n                # if croped selected but not save both -> ask if sure\r\n                msg_box = QMessageBox(self)\r\n                msg_box.setWindowTitle(\"Only one cube ?\")\r\n                msg_box.setIcon(QMessageBox.Question)\r\n                msg_box.setText(\r\n                    \"You choosed to keep only the selected part of the whole cube.\\nAre you sure you do not want to save both croped cubes ?\")\r\n                only_aligned = msg_box.addButton(\"Yes, just keep croped aligned cube\", QMessageBox.ActionRole)\r\n                save_both = msg_box.addButton(\"No, save both\", QMessageBox.ActionRole)\r\n                msg_box.exec()\r\n\r\n                if msg_box.clickedButton() == save_both:\r\n                    save_both=True\r\n                elif msg_box.clickedButton() == only_aligned:\r\n                    save_both=False\r\n\r\n        print(f\"save both : {save_both}\")\r\n\r\n        mini_fixed_cube = Hypercube(data=self.fixed_cube.data,metadata=self.fixed_cube.cube_info.metadata_temp, wl=self.fixed_cube.wl, cube_info=self.fixed_cube.cube_info)\r\n        mini_align_cube = Hypercube(data=self.moving_cube.data, wl=self.moving_cube.wl,metadata=self.moving_cube.cube_info.metadata_temp,\r\n                                    cube_info=self.moving_cube.cube_info)\r\n\r\n        # 1) Choix des noms de fichier\r\n        file_name_align=self.aligned_cube.cube_info.filepath.split('.')[0]\r\n        if '_reg' not in os.path.basename(file_name_align):\r\n            file_name_align+='_reg'\r\n\r\n        if opts['crop_cube']:\r\n            file_name_align+='_minicube_'\r\n\r\n        save_path_align, _ = QFileDialog.getSaveFileName(self,\"ALIGNED cube Save As…\",file_name_align)\r\n        mini_align_cube.cube_info.filepath=save_path_align\r\n\r\n        if not save_path_align:\r\n            QMessageBox.critical(self,'Abort','No filepath given : Save action aborted')\r\n            return\r\n\r\n        if save_both:\r\n\r\n            folder_name_fixed=os.path.dirname(save_path_align) #same as before\r\n            name_fixed=os.path.basename(self.fixed_cube.cube_info.filepath).split('.')[0]\r\n            if '_reg' not in name_fixed:\r\n                name_fixed+='_reg'\r\n\r\n            if opts['crop_cube']:\r\n                name_fixed += '_minicube_'\r\n\r\n            try:\r\n                name_fixed+=os.path.basename(save_path_align).split('_')[-1]\r\n            except:pass\r\n\r\n            file_name_fixed=os.path.join(folder_name_fixed,name_fixed)\r\n\r\n            save_path_fixed, _ = QFileDialog.getSaveFileName(self,\"FIXED cube Save As…\",file_name_fixed)\r\n            mini_fixed_cube.cube_info.filepath = save_path_fixed\r\n\r\n            if not save_path_fixed:\r\n                QMessageBox.critical(self, 'Abort', 'No filepath given : Save action aborted')\r\n                return\r\n\r\n        # Crop\r\n        if opts['crop_cube']:\r\n            #todo : add metadata position, name, parent,cube_info\r\n\r\n            if self.viewer_aligned.get_rect_coords() is not None:\r\n                y, x, dy, dx = self.viewer_aligned.get_rect_coords()\r\n                y, x, dy, dx = map(int, (y, x, dy, dx))\r\n                mini_fixed_cube.data = self.fixed_cube.data[x:x + dx, y:y + dy, :]\r\n                mini_align_cube.data = self.aligned_cube.data[x:x + dx, y:y + dy, :]\r\n\r\n                fixed_img = self.fixed_img[x:x + dx, y:y + dy]\r\n                aligned_img = self.aligned_img[x:x + dx, y:y + dy]\r\n\r\n\r\n                ## metadata for croped fixed cube from fixed_cube\r\n                mini_fixed_cube.cube_info.metadata_temp['position'] =[y, x, dy, dx]\r\n                try:\r\n                   mini_fixed_cube.cube_info.metadata_temp['parent_cube']=self.fixed_cube.cube_info.metadata_temp['name']\r\n                except:\r\n                   mini_fixed_cube.cube_info.metadata_temp['parent_cube'] = os.path.basename(self.fixed_cube.cube_info.filepath).split('.')[0]\r\n\r\n\r\n                ## metadata for croped moving cube from parent_aligned_for_minicubes\r\n                mini_align_cube.cube_info.metadata_temp['position'] = [y, x, dy, dx]\r\n                if self.parent_aligned_for_minicubes is not None:\r\n                    try:\r\n                        mini_align_cube.cube_info.metadata_temp['parent_cube'] = self.parent_aligned_for_minicubes.cube_info.metadata_temp['name']\r\n                    except:\r\n                        mini_align_cube.cube_info.metadata_temp['parent_cube'] = os.path.basename(self.parent_aligned_for_minicubes.cube_info.filepath).split('.')[0]\r\n                else:\r\n                    try:\r\n                        mini_align_cube.cube_info.metadata_temp['parent_cube'] = self.moving_cube.cube_info.metadata_temp['name']\r\n                    except:\r\n                        mini_align_cube.cube_info.metadata_temp['parent_cube'] = os.path.basename(self.moving_cube.cube_info.filepath).split('.')[0]\r\n\r\n                ##open window to change name and cube info with previous value\r\n\r\n                dialog = QDialog(self)\r\n                dialog.setWindowTitle(\"Minicubes Specific Metadata\")\r\n                layout = QVBoxLayout(dialog)\r\n                form_layout = QFormLayout()\r\n\r\n                form_layout.addRow(QLabel(\"<b><div align='center'>FOR REGISTERED (ALIGNED) CUBE</div></b>\"))\r\n                lineedit_reg_name = QLineEdit()\r\n                lineedit_reg_name.setText(os.path.basename(save_path_align).split('.')[0])\r\n                form_layout.addRow(QLabel('name'), lineedit_reg_name)\r\n\r\n                lineedit_reg_parent = QLineEdit()\r\n                lineedit_reg_parent.setText(mini_align_cube.cube_info.metadata_temp['parent_cube'])\r\n                form_layout.addRow(QLabel(\"parent_cube\"), lineedit_reg_parent)\r\n\r\n                if save_both:\r\n                    form_layout.addRow(QLabel(\"\"))\r\n                    form_layout.addRow(QLabel(\"<b><div align='center'>FOR FIXED (REFERENCE) CUBE</div></b>\"))\r\n                    lineedit_fix_name = QLineEdit()\r\n                    lineedit_fix_name.setText(os.path.basename(save_path_fixed).split('.')[0])\r\n\r\n                    form_layout.addRow(QLabel('name'), lineedit_fix_name)\r\n\r\n                    lineedit_fix_parent = QLineEdit()\r\n                    lineedit_fix_parent.setText(mini_fixed_cube.cube_info.metadata_temp['parent_cube'])\r\n                    form_layout.addRow(QLabel(\"parent_cube\"), lineedit_fix_parent)\r\n\r\n                form_layout.addRow(QLabel(\"\"))\r\n\r\n                if save_both:\r\n                    form_layout.addRow(QLabel(\"<b><div align='center'>FOR BOTH CUBES</div></b>\"))\r\n\r\n                lineedit_cubeinfo = QLineEdit()\r\n                try:\r\n                    lineedit_cubeinfo.setText(mini_align_cube.cube_info.metadata_temp['cubeinfo'])\r\n                except:\r\n                    pass\r\n                form_layout.addRow(QLabel(\"cubeinfo\"), lineedit_cubeinfo)\r\n\r\n                lineedit_number = QLineEdit()\r\n                try: lineedit_number.setText(os.path.basename(save_path_fixed).split('.')[0].split('_')[-1])\r\n                except:pass\r\n                form_layout.addRow(QLabel(\"number\"), lineedit_number)\r\n\r\n\r\n                layout.addLayout(form_layout)\r\n\r\n                # Buttons\r\n                buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)\r\n                layout.addWidget(buttons)\r\n\r\n                def on_accept():\r\n\r\n                    mini_align_cube.cube_info.metadata_temp['name'] = lineedit_reg_name.text().strip()\r\n                    mini_align_cube.cube_info.metadata_temp['cubeinfo'] = lineedit_cubeinfo.text().strip()\r\n                    mini_align_cube.cube_info.metadata_temp['number'] = lineedit_number.text().strip()\r\n                    mini_align_cube.cube_info.metadata_temp['parent_cube'] = lineedit_reg_parent.text().strip()\r\n                    if save_both:\r\n                        mini_fixed_cube.cube_info.metadata_temp['name'] = lineedit_fix_name.text().strip()\r\n                        mini_fixed_cube.cube_info.metadata_temp['cubeinfo'] = lineedit_cubeinfo.text().strip()\r\n                        mini_fixed_cube.cube_info.metadata_temp['number'] = lineedit_number.text().strip()\r\n                        mini_fixed_cube.cube_info.metadata_temp['parent_cube'] = lineedit_fix_parent.text().strip()\r\n\r\n                    dialog.accept()\r\n\r\n                buttons.accepted.connect(on_accept)\r\n                buttons.rejected.connect(dialog.reject)\r\n\r\n                dialog.setLayout(layout)\r\n                dialog.exec_()\r\n\r\n        else:\r\n            fixed_img = self.fixed_img\r\n            aligned_img = self.aligned_img\r\n\r\n        if opts['image_mode_rgb']: ## si rgb on remplace les image de gris precedentes par les false rgb par default\r\n            wl = mini_fixed_cube.wl\r\n            if wl[-1] < 1100 and wl[0] > 350:\r\n                wl_rgb = [610, 540, 435]\r\n            elif wl[-1] >= 1100:\r\n                wl_rgb = [1605, 1205, 1005]\r\n            else:\r\n                mid = int(len(wl) / 2)\r\n                wl_rgb = [wl[0], wl[mid], wl[-1]]\r\n\r\n            chan=[np.argmin(np.abs(wl-wl_col)) for wl_col in wl_rgb]\r\n            chan.reverse()\r\n            print(chan)\r\n\r\n            fixed_img = (mini_fixed_cube.data[:, :, chan]*255).clip(0,255).astype(np.uint8)\r\n\r\n            wl = mini_align_cube.wl\r\n            if wl[-1] < 1100 and wl[0] > 350:\r\n                wl_rgb = [610, 540, 435]\r\n            elif wl[-1] >= 1100:\r\n                wl_rgb = [1605, 1205, 1005]\r\n            else:\r\n                mid = int(len(wl) / 2)\r\n                wl_rgb = [wl[0], wl[mid], wl[-1]]\r\n\r\n            chan=[np.argmin(np.abs(wl-wl_col)) for wl_col in wl_rgb]\r\n            chan.reverse()\r\n            print(chan)\r\n\r\n            aligned_img = (mini_align_cube.data[:, :, chan]*255).clip(0,255).astype(np.uint8)\r\n\r\n        # Image\r\n        if opts['export_images']:\r\n            # on s’assure d’avoir un “.” devant l’extension\r\n            ext = '.' + opts['image_format'].lower().lstrip('.')\r\n\r\n            # --- pour l’image alignée ---\r\n            folder = os.path.dirname(save_path_align)\r\n            base = os.path.splitext(os.path.basename(save_path_align))[0]\r\n            save_path_image = os.path.join(folder, base + ext)\r\n            # cv2.imwrite renvoie False si ça a échoué\r\n            if not cv2.imwrite(save_path_image, aligned_img):\r\n                QMessageBox.warning(self, \"Save Error\",\r\n                                    f\"Impossible to save : {save_path_image}\")\r\n\r\n            # --- si on veut sauvegarder aussi l’image fixe ---\r\n            if save_both:\r\n                folder2 = os.path.dirname(save_path_fixed)\r\n                base2 = os.path.splitext(os.path.basename(save_path_fixed))[0]\r\n                save_path_image2 = os.path.join(folder2, base2 + ext)\r\n                if not cv2.imwrite(save_path_image2, fixed_img):\r\n                    QMessageBox.warning(self, \"Save Error\",\r\n                                        f\"Impossible to save : {save_path_image2}\")\r\n\r\n        # 4) Export cubes\r\n        fmt = opts['cube_format']\r\n        try :\r\n            mini_align_cube.save(save_path_align,fmt=fmt,meta_from_cube_info=True)\r\n            if len(save_path_align.split('.'))==1:\r\n                if fmt == \"MATLAB\":\r\n                    ext = '.mat'\r\n                elif fmt == \"HDF5\":\r\n                    ext = '.h5'\r\n                elif fmt == \"ENVI\":\r\n                    ext = '.hdr'\r\n                else :\r\n                    ext = '.h5'\r\n                save_path_align+=ext\r\n\r\n            mini_align_cube.cube_info.filepath=save_path_align\r\n            self.cube_saved.emit(mini_align_cube.cube_info)\r\n            print(f\"mini_align_cube save {mini_align_cube.cube_info.filepath}\")\r\n            if flag_save_aligned or not opts['crop_cube']:\r\n                self.parent_aligned_for_minicubes=mini_align_cube\r\n                self.checkBox_autorize_modify.setChecked(False)\r\n            if not save_both:\r\n                QMessageBox.information(self, \"Succès\", f\"Cube saved as {fmt} in :\\n{save_path_align}\")\r\n\r\n        except :\r\n            QMessageBox.warning(self, \"Problem\", f\"Cube NOT SAVED as {fmt} in :\\n{save_path_align}\")\r\n\r\n        if save_both:\r\n            mini_fixed_cube.save(save_path_fixed,fmt=fmt,meta_from_cube_info=True)\r\n            if len(save_path_fixed.split('.'))==1:\r\n                if fmt == \"MATLAB\":\r\n                    ext = '.mat'\r\n                elif fmt == \"HDF5\":\r\n                    ext = '.h5'\r\n                elif fmt == \"ENVI\":\r\n                    ext = '.hdr'\r\n                else :\r\n                    ext = '.h5'\r\n                save_path_fixed+=ext\r\n            mini_fixed_cube.cube_info.filepath=save_path_fixed\r\n            self.cube_saved.emit(mini_fixed_cube.cube_info)\r\n            QMessageBox.information(self, \"Succès\", f\"Cubes saved as {fmt} in :\\n{save_path_align} \\n{save_path_fixed} \")\r\n\r\n    def switch_fixe_mov(self):\r\n        self.load_cube(switch=True)\r\n\r\n    def middle_click_on_match(self, scene_pos):\r\n        if self.overlay_selector.currentText() != \"View Matches\":\r\n            return\r\n\r\n        clicked_x, clicked_y = scene_pos.x(), scene_pos.y()\r\n        img_width = self.fixed_img.shape[1]\r\n        min_dist = 15\r\n        closest_display_idx = None\r\n\r\n        for i, match in enumerate(self.currently_displayed_matches):\r\n            pt1 = np.array(self.kp1[match.queryIdx].pt)\r\n            pt2 = np.array(self.kp2[match.trainIdx].pt) + np.array([img_width, 0])\r\n            dist1 = np.linalg.norm(pt1 - np.array([clicked_x, clicked_y]))\r\n            dist2 = np.linalg.norm(pt2 - np.array([clicked_x, clicked_y]))\r\n\r\n            if dist1 < min_dist or dist2 < min_dist:\r\n                closest_display_idx = i\r\n                break\r\n\r\n        if closest_display_idx is not None:\r\n            self.dialog_remove_match(closest_display_idx)\r\n\r\n    def dialog_remove_match(self, match_idx):\r\n        dialog = QDialog(self)\r\n        dialog.setWindowTitle(\"Remove Match\")\r\n        layout = QVBoxLayout(dialog)\r\n\r\n        label = QLabel(\"Supress feature #\")\r\n        spinbox = QSpinBox()\r\n        spinbox.setRange(0, len(self.matches_all) - 1)\r\n        spinbox.setValue(match_idx)\r\n\r\n        layout.addWidget(label)\r\n        layout.addWidget(spinbox)\r\n\r\n        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)\r\n        layout.addWidget(buttons)\r\n\r\n        def on_accept():\r\n            display_idx = spinbox.value()\r\n            real_idx = self.match_display_to_global_index.get(display_idx, None)\r\n            if real_idx is not None:\r\n                del self.matches_all[real_idx]\r\n                self.update_keypoints_display()\r\n                self.checkBox_autorize_modify.setChecked(False)\r\n            dialog.accept()\r\n\r\n        buttons.accepted.connect(on_accept)\r\n        buttons.rejected.connect(dialog.reject)\r\n\r\n        dialog.exec_()\r\n\r\n    def start_move_feature(self, scene_pos):\r\n        if self.overlay_selector.currentText() != \"View Matches\":\r\n            return\r\n\r\n        clicked_x, clicked_y = scene_pos.x(), scene_pos.y()\r\n        img_width = self.fixed_img.shape[1]\r\n        min_dist = 15\r\n\r\n        for i, match in enumerate(self.currently_displayed_matches):\r\n            pt1 = np.array(self.kp1[match.queryIdx].pt)\r\n            pt2 = np.array(self.kp2[match.trainIdx].pt) + np.array([img_width, 0])\r\n            if np.linalg.norm(pt1 - [clicked_x, clicked_y]) < min_dist:\r\n                self.viewer_aligned.editing_match = (i, \"left\")\r\n                return\r\n            elif np.linalg.norm(pt2 - [clicked_x, clicked_y]) < min_dist:\r\n                self.viewer_aligned.editing_match = (i, \"right\")\r\n                return\r\n\r\n    def update_move_feature(self, scene_pos):\r\n        if not self.viewer_aligned.editing_match:\r\n            return\r\n\r\n        idx_display, side = self.viewer_aligned.editing_match\r\n        real_idx = self.match_display_to_global_index.get(idx_display, None)\r\n        if real_idx is None:\r\n            return\r\n\r\n        match = self.matches_all[real_idx]\r\n\r\n        if side == \"left\":\r\n            self.kp1[match.queryIdx].pt = (scene_pos.x(), scene_pos.y())\r\n        elif side == \"right\":\r\n            self.kp2[match.trainIdx].pt = (scene_pos.x() - self.fixed_img.shape[1], scene_pos.y())\r\n\r\n        self.update_keypoints_display()\r\n\r\n    def end_move_feature(self):\r\n        self.checkBox_autorize_modify.setChecked(False)\r\n\r\n    def reset_all(self):\r\n        \r\n        ans=QMessageBox.warning(self,'Reset All','If you reset you will loose all the work you have done here.\\n \\nAre you sure you want to reset this tool ? ', QMessageBox.Yes|QMessageBox.Cancel)\r\n        if ans==QMessageBox.Cancel:\r\n            return\r\n        \r\n        # reinit cube and images\r\n        self.fixed_cube = Hypercube()\r\n        self.moving_cube = Hypercube()\r\n        self.aligned_cube = Hypercube()\r\n        self.fixed_img = None\r\n        self.moving_img = None\r\n        self.aligned_img = None\r\n        self.img = [None, None]\r\n\r\n        # clean features and variables\r\n        self.kp1 = None\r\n        self.kp2 = None\r\n        self.matches = None\r\n        self.matches_all = None\r\n        self.currently_displayed_matches = []\r\n        self.match_display_to_global_index = {}\r\n        self.manual_feature_modif = False\r\n        self.parent_aligned_for_minicubes = None\r\n\r\n        # Reset sliders\r\n        for slider, spin in zip(self.slider_channel + self.spinBox_channel,\r\n                                self.slider_channel + self.spinBox_channel):\r\n            slider.setValue(0)\r\n            slider.setEnabled(False)\r\n            spin.setValue(0)\r\n            spin.setEnabled(False)\r\n\r\n        self.horizontalSlider_keyPacketToShow.setValue(0)\r\n        self.features_slider.setValue(50)\r\n\r\n        # Reset rectangles\r\n        for viewer in self.viewer_img:\r\n            viewer.clear_rectangle()\r\n\r\n        # Reset images & labels\r\n        for viewer in self.viewer_img:\r\n            viewer.setImage(QPixmap())\r\n        for label in self.viewer_label:\r\n            label.setText(\"\")\r\n\r\n        # Reset aligned viewer\r\n        self.viewer_aligned.setImage(QPixmap())\r\n\r\n        # Buttons disabled les boutons\r\n        self.pushButton_register.setEnabled(False)\r\n        self.pushButton_save_cube.setEnabled(False)\r\n\r\n        # checkbox to intial state\r\n        self.checkBox_crop.setChecked(False)\r\n        self.checkBox_autorize_modify.setChecked(True)\r\n\r\ndef save_cropped_registered_images(self):\r\n    if self.fixed_img is None or self.aligned_img is None:\r\n        QMessageBox.warning(self, \"Erreur\", \"Les images ne sont pas prêtes.\")\r\n        return\r\n\r\n    if not hasattr(self.viewer_aligned, 'get_rect_coords'):\r\n        QMessageBox.warning(self, \"Erreur\", \"Aucune sélection trouvée dans viewer_aligned.\")\r\n        return\r\n\r\n    # Ouvre un QFileDialog pour sélectionner un dossier\r\n    save_dir = QFileDialog.getExistingDirectory(self, \"Choisir un dossier de sauvegarde\")\r\n    if not save_dir:\r\n        return  # L'utilisateur a annulé\r\n\r\n    y, x, dy, dx = self.viewer_aligned.get_rect_coords()\r\n    x, y, dx, dy = int(x), int(y), int(dx), int(dy)\r\n\r\n    # Rogner et sauvegarder les cubes\r\n    if hasattr(self, \"aligned_cube\"):\r\n        aligned_cube_crop = self.aligned_cube[y:y+dy, x:x+dx, :]\r\n        np.save(os.path.join(save_dir, \"aligned_cube_crop.npy\"), aligned_cube_crop)\r\n\r\n    if hasattr(self, \"fixed_cube\"):\r\n        fixed_cube_crop = self.fixed_cube[y:y+dy, x:x+dx, :]\r\n        np.save(os.path.join(save_dir, \"fixed_cube_crop.npy\"), fixed_cube_crop)\r\n\r\n    QMessageBox.information(self, \"Succès\", f\"Images et cubes rognés sauvegardés dans:\\n{save_dir}\")\r\n\r\nif __name__ == '__main__':\r\n    app = QApplication(sys.argv)\r\n\r\n    window = RegistrationApp()\r\n    window.show()\r\n    app.setStyle('Fusion')\r\n\r\n    # folder_cube=r'C:\\Users\\Usuario\\Documents\\DOC_Yannick\\Hyperdoc_Test\\Archivo chancilleria/'\r\n    # path_fixed_cube=folder_cube+'MPD41a_SWIR.mat'\r\n    # path_moving_cube=folder_cube+'MPD41a_VNIR.mat'\r\n    # window.load_cube(0,path_fixed_cube)\r\n    # window.load_cube(1,path_moving_cube)\r\n\r\n    sys.exit(app.exec_())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/registration/register_tool.py b/registration/register_tool.py
--- a/registration/register_tool.py	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/registration/register_tool.py	(date 1752478303594)
@@ -83,7 +83,6 @@
     alt_path = os.path.join(dirname, alt_name)
     return alt_path if os.path.exists(alt_path) else None
 
-
 class ZoomableGraphicsView(QGraphicsView):
     middleClicked = pyqtSignal(QPointF) # suppres features
     moveFeatureStart = pyqtSignal(QPointF) # movefeatures
Index: ground_truth/ground_truth_window.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\n\r\n# Form implementation generated from reading ui file 'ground_truth_window.ui'\r\n#\r\n# Created by: PyQt5 UI code generator 5.15.11\r\n#\r\n# WARNING: Any manual changes made to this file will be lost when pyuic5 is\r\n# run again.  Do not edit this file unless you know what you are doing.\r\n\r\n\r\nfrom PyQt5 import QtCore, QtGui, QtWidgets\r\n\r\n\r\nclass Ui_GroundTruthWidget(object):\r\n    def setupUi(self, GroundTruthWidget):\r\n        GroundTruthWidget.setObjectName(\"GroundTruthWidget\")\r\n        GroundTruthWidget.resize(1327, 609)\r\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(GroundTruthWidget.sizePolicy().hasHeightForWidth())\r\n        GroundTruthWidget.setSizePolicy(sizePolicy)\r\n        GroundTruthWidget.setStyleSheet(\"background-color: rgb(181, 181, 181);\")\r\n        self.verticalLayout = QtWidgets.QVBoxLayout(GroundTruthWidget)\r\n        self.verticalLayout.setObjectName(\"verticalLayout\")\r\n        self.frame = QtWidgets.QFrame(GroundTruthWidget)\r\n        self.frame.setAutoFillBackground(False)\r\n        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)\r\n        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)\r\n        self.frame.setObjectName(\"frame\")\r\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.frame)\r\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\r\n        self.verticalLayout_7 = QtWidgets.QVBoxLayout()\r\n        self.verticalLayout_7.setObjectName(\"verticalLayout_7\")\r\n        self.load_btn = QtWidgets.QPushButton(self.frame)\r\n        self.load_btn.setObjectName(\"load_btn\")\r\n        self.verticalLayout_7.addWidget(self.load_btn)\r\n        self.pushButton_reset = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_reset.setStyleSheet(\"color: rgba(255, 0, 0, 125);\")\r\n        self.pushButton_reset.setObjectName(\"pushButton_reset\")\r\n        self.verticalLayout_7.addWidget(self.pushButton_reset)\r\n        self.horizontalLayout_2.addLayout(self.verticalLayout_7)\r\n        self.line_4 = QtWidgets.QFrame(self.frame)\r\n        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_4.setObjectName(\"line_4\")\r\n        self.horizontalLayout_2.addWidget(self.line_4)\r\n        self.groupBox_image_type = QtWidgets.QGroupBox(self.frame)\r\n        self.groupBox_image_type.setObjectName(\"groupBox_image_type\")\r\n        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.groupBox_image_type)\r\n        self.verticalLayout_5.setObjectName(\"verticalLayout_5\")\r\n        self.radioButton_rgb_default = QtWidgets.QRadioButton(self.groupBox_image_type)\r\n        self.radioButton_rgb_default.setChecked(True)\r\n        self.radioButton_rgb_default.setObjectName(\"radioButton_rgb_default\")\r\n        self.verticalLayout_5.addWidget(self.radioButton_rgb_default)\r\n        self.radioButton_rgb_user = QtWidgets.QRadioButton(self.groupBox_image_type)\r\n        self.radioButton_rgb_user.setEnabled(True)\r\n        self.radioButton_rgb_user.setChecked(False)\r\n        self.radioButton_rgb_user.setObjectName(\"radioButton_rgb_user\")\r\n        self.verticalLayout_5.addWidget(self.radioButton_rgb_user)\r\n        self.radioButton_grayscale = QtWidgets.QRadioButton(self.groupBox_image_type)\r\n        self.radioButton_grayscale.setObjectName(\"radioButton_grayscale\")\r\n        self.verticalLayout_5.addWidget(self.radioButton_grayscale)\r\n        self.horizontalLayout_2.addWidget(self.groupBox_image_type)\r\n        self.gridLayout_RGBchannels_3 = QtWidgets.QGridLayout()\r\n        self.gridLayout_RGBchannels_3.setObjectName(\"gridLayout_RGBchannels_3\")\r\n        self.spinBox_green_channel = QtWidgets.QSpinBox(self.frame)\r\n        self.spinBox_green_channel.setMaximum(149)\r\n        self.spinBox_green_channel.setProperty(\"value\", 0)\r\n        self.spinBox_green_channel.setObjectName(\"spinBox_green_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_green_channel, 1, 1, 1, 1)\r\n        self.spinBox_blue_channel = QtWidgets.QSpinBox(self.frame)\r\n        self.spinBox_blue_channel.setMaximum(149)\r\n        self.spinBox_blue_channel.setProperty(\"value\", 0)\r\n        self.spinBox_blue_channel.setObjectName(\"spinBox_blue_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_blue_channel, 2, 1, 1, 1)\r\n        self.spinBox_red_channel = QtWidgets.QSpinBox(self.frame)\r\n        self.spinBox_red_channel.setMaximum(149)\r\n        self.spinBox_red_channel.setSingleStep(1)\r\n        self.spinBox_red_channel.setProperty(\"value\", 0)\r\n        self.spinBox_red_channel.setObjectName(\"spinBox_red_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_red_channel, 0, 1, 1, 1)\r\n        self.horizontalSlider_blue_channel = QtWidgets.QSlider(self.frame)\r\n        self.horizontalSlider_blue_channel.setMaximum(149)\r\n        self.horizontalSlider_blue_channel.setProperty(\"value\", 0)\r\n        self.horizontalSlider_blue_channel.setOrientation(QtCore.Qt.Horizontal)\r\n        self.horizontalSlider_blue_channel.setObjectName(\"horizontalSlider_blue_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_blue_channel, 2, 2, 1, 1)\r\n        self.label_green_channel = QtWidgets.QLabel(self.frame)\r\n        self.label_green_channel.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_green_channel.setObjectName(\"label_green_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.label_green_channel, 1, 0, 1, 1)\r\n        self.label_blue_channel = QtWidgets.QLabel(self.frame)\r\n        self.label_blue_channel.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_blue_channel.setObjectName(\"label_blue_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.label_blue_channel, 2, 0, 1, 1)\r\n        self.label_red_channel = QtWidgets.QLabel(self.frame)\r\n        self.label_red_channel.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_red_channel.setObjectName(\"label_red_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.label_red_channel, 0, 0, 1, 1)\r\n        self.horizontalSlider_green_channel = QtWidgets.QSlider(self.frame)\r\n        self.horizontalSlider_green_channel.setMaximum(149)\r\n        self.horizontalSlider_green_channel.setProperty(\"value\", 0)\r\n        self.horizontalSlider_green_channel.setOrientation(QtCore.Qt.Horizontal)\r\n        self.horizontalSlider_green_channel.setObjectName(\"horizontalSlider_green_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_green_channel, 1, 2, 1, 1)\r\n        self.horizontalSlider_red_channel = QtWidgets.QSlider(self.frame)\r\n        self.horizontalSlider_red_channel.setMinimumSize(QtCore.QSize(60, 0))\r\n        self.horizontalSlider_red_channel.setMaximum(149)\r\n        self.horizontalSlider_red_channel.setProperty(\"value\", 0)\r\n        self.horizontalSlider_red_channel.setOrientation(QtCore.Qt.Horizontal)\r\n        self.horizontalSlider_red_channel.setObjectName(\"horizontalSlider_red_channel\")\r\n        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_red_channel, 0, 2, 1, 1)\r\n        self.horizontalLayout_2.addLayout(self.gridLayout_RGBchannels_3)\r\n        self.line = QtWidgets.QFrame(self.frame)\r\n        self.line.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line.setObjectName(\"line\")\r\n        self.horizontalLayout_2.addWidget(self.line)\r\n        self.gridLayout = QtWidgets.QGridLayout()\r\n        self.gridLayout.setObjectName(\"gridLayout\")\r\n        self.checkBox_enable_segment = QtWidgets.QCheckBox(self.frame)\r\n        self.checkBox_enable_segment.setChecked(True)\r\n        self.checkBox_enable_segment.setObjectName(\"checkBox_enable_segment\")\r\n        self.gridLayout.addWidget(self.checkBox_enable_segment, 3, 7, 1, 2)\r\n        self.line_2 = QtWidgets.QFrame(self.frame)\r\n        self.line_2.setLineWidth(1)\r\n        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_2.setObjectName(\"line_2\")\r\n        self.gridLayout.addWidget(self.line_2, 0, 6, 4, 1)\r\n        self.label_metric = QtWidgets.QLabel(self.frame)\r\n        self.label_metric.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_metric.setObjectName(\"label_metric\")\r\n        self.gridLayout.addWidget(self.label_metric, 0, 4, 1, 1)\r\n        self.pushButton_class_selection = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_class_selection.setEnabled(True)\r\n        self.pushButton_class_selection.setStyleSheet(\"background-color: rgba(186, 255, 112, 125);\")\r\n        self.pushButton_class_selection.setCheckable(True)\r\n        self.pushButton_class_selection.setObjectName(\"pushButton_class_selection\")\r\n        self.gridLayout.addWidget(self.pushButton_class_selection, 0, 7, 1, 1)\r\n        self.run_btn = QtWidgets.QPushButton(self.frame)\r\n        self.run_btn.setStyleSheet(\"background-color: rgb(173, 173, 173);\")\r\n        self.run_btn.setObjectName(\"run_btn\")\r\n        self.gridLayout.addWidget(self.run_btn, 3, 4, 1, 1)\r\n        self.pushButton_erase_selected_pix = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_erase_selected_pix.setStyleSheet(\"background-color: rgb(255, 206, 206);\")\r\n        self.pushButton_erase_selected_pix.setCheckable(True)\r\n        self.pushButton_erase_selected_pix.setObjectName(\"pushButton_erase_selected_pix\")\r\n        self.gridLayout.addWidget(self.pushButton_erase_selected_pix, 2, 7, 1, 1)\r\n        self.comboBox_ClassifMode = QtWidgets.QComboBox(self.frame)\r\n        self.comboBox_ClassifMode.setObjectName(\"comboBox_ClassifMode\")\r\n        self.comboBox_ClassifMode.addItem(\"\")\r\n        self.comboBox_ClassifMode.addItem(\"\")\r\n        self.gridLayout.addWidget(self.comboBox_ClassifMode, 2, 2, 1, 2)\r\n        self.label_class_type = QtWidgets.QLabel(self.frame)\r\n        self.label_class_type.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_class_type.setObjectName(\"label_class_type\")\r\n        self.gridLayout.addWidget(self.label_class_type, 0, 2, 1, 2)\r\n        self.label_selec_mode = QtWidgets.QLabel(self.frame)\r\n        self.label_selec_mode.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.label_selec_mode.setObjectName(\"label_selec_mode\")\r\n        self.gridLayout.addWidget(self.label_selec_mode, 0, 8, 1, 1)\r\n        self.nclass_label = QtWidgets.QLabel(self.frame)\r\n        self.nclass_label.setObjectName(\"nclass_label\")\r\n        self.gridLayout.addWidget(self.nclass_label, 3, 2, 1, 1)\r\n        self.slider_class_thr = QtWidgets.QSlider(self.frame)\r\n        self.slider_class_thr.setMinimum(0)\r\n        self.slider_class_thr.setMaximum(100)\r\n        self.slider_class_thr.setProperty(\"value\", 100)\r\n        self.slider_class_thr.setOrientation(QtCore.Qt.Vertical)\r\n        self.slider_class_thr.setTickPosition(QtWidgets.QSlider.NoTicks)\r\n        self.slider_class_thr.setObjectName(\"slider_class_thr\")\r\n        self.gridLayout.addWidget(self.slider_class_thr, 2, 5, 2, 1)\r\n        self.verticalLayout_4 = QtWidgets.QVBoxLayout()\r\n        self.verticalLayout_4.setObjectName(\"verticalLayout_4\")\r\n        self.stackedWidget = QtWidgets.QStackedWidget(self.frame)\r\n        self.stackedWidget.setObjectName(\"stackedWidget\")\r\n        self.page_distance = QtWidgets.QWidget()\r\n        self.page_distance.setObjectName(\"page_distance\")\r\n        self.horizontalLayout = QtWidgets.QHBoxLayout(self.page_distance)\r\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\r\n        self.comboBox_distance = QtWidgets.QComboBox(self.page_distance)\r\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(self.comboBox_distance.sizePolicy().hasHeightForWidth())\r\n        self.comboBox_distance.setSizePolicy(sizePolicy)\r\n        self.comboBox_distance.setObjectName(\"comboBox_distance\")\r\n        self.comboBox_distance.addItem(\"\")\r\n        self.comboBox_distance.addItem(\"\")\r\n        self.comboBox_distance.addItem(\"\")\r\n        self.horizontalLayout.addWidget(self.comboBox_distance)\r\n        self.stackedWidget.addWidget(self.page_distance)\r\n        self.page_normalized = QtWidgets.QWidget()\r\n        self.page_normalized.setObjectName(\"page_normalized\")\r\n        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.page_normalized)\r\n        self.horizontalLayout_3.setObjectName(\"horizontalLayout_3\")\r\n        self.comboBox_normalized = QtWidgets.QComboBox(self.page_normalized)\r\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(self.comboBox_normalized.sizePolicy().hasHeightForWidth())\r\n        self.comboBox_normalized.setSizePolicy(sizePolicy)\r\n        self.comboBox_normalized.setObjectName(\"comboBox_normalized\")\r\n        self.comboBox_normalized.addItem(\"\")\r\n        self.comboBox_normalized.addItem(\"\")\r\n        self.horizontalLayout_3.addWidget(self.comboBox_normalized)\r\n        self.stackedWidget.addWidget(self.page_normalized)\r\n        self.verticalLayout_4.addWidget(self.stackedWidget)\r\n        self.gridLayout.addLayout(self.verticalLayout_4, 2, 4, 1, 1)\r\n        self.comboBox_pixel_selection_mode = QtWidgets.QComboBox(self.frame)\r\n        self.comboBox_pixel_selection_mode.setObjectName(\"comboBox_pixel_selection_mode\")\r\n        self.comboBox_pixel_selection_mode.addItem(\"\")\r\n        self.comboBox_pixel_selection_mode.addItem(\"\")\r\n        self.comboBox_pixel_selection_mode.addItem(\"\")\r\n        self.gridLayout.addWidget(self.comboBox_pixel_selection_mode, 2, 8, 1, 1)\r\n        self.nclass_box = QtWidgets.QSpinBox(self.frame)\r\n        self.nclass_box.setMinimum(2)\r\n        self.nclass_box.setMaximum(20)\r\n        self.nclass_box.setProperty(\"value\", 3)\r\n        self.nclass_box.setObjectName(\"nclass_box\")\r\n        self.gridLayout.addWidget(self.nclass_box, 3, 3, 1, 1)\r\n        self.label_thr = QtWidgets.QLabel(self.frame)\r\n        self.label_thr.setObjectName(\"label_thr\")\r\n        self.gridLayout.addWidget(self.label_thr, 0, 5, 1, 1)\r\n        self.horizontalLayout_2.addLayout(self.gridLayout)\r\n        self.frame_legend = QtWidgets.QFrame(self.frame)\r\n        self.frame_legend.setFrameShape(QtWidgets.QFrame.StyledPanel)\r\n        self.frame_legend.setFrameShadow(QtWidgets.QFrame.Raised)\r\n        self.frame_legend.setObjectName(\"frame_legend\")\r\n        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.frame_legend)\r\n        self.verticalLayout_6.setObjectName(\"verticalLayout_6\")\r\n        self.horizontalLayout_2.addWidget(self.frame_legend)\r\n        self.line_3 = QtWidgets.QFrame(self.frame)\r\n        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_3.setObjectName(\"line_3\")\r\n        self.horizontalLayout_2.addWidget(self.line_3)\r\n        self.gridLayout_4 = QtWidgets.QGridLayout()\r\n        self.gridLayout_4.setObjectName(\"gridLayout_4\")\r\n        self.horizontalSlider_transparency_GT = QtWidgets.QSlider(self.frame)\r\n        self.horizontalSlider_transparency_GT.setMinimumSize(QtCore.QSize(60, 0))\r\n        self.horizontalSlider_transparency_GT.setMaximum(100)\r\n        self.horizontalSlider_transparency_GT.setProperty(\"value\", 0)\r\n        self.horizontalSlider_transparency_GT.setSliderPosition(0)\r\n        self.horizontalSlider_transparency_GT.setOrientation(QtCore.Qt.Horizontal)\r\n        self.horizontalSlider_transparency_GT.setObjectName(\"horizontalSlider_transparency_GT\")\r\n        self.gridLayout_4.addWidget(self.horizontalSlider_transparency_GT, 1, 3, 1, 1)\r\n        self.label_GT_3 = QtWidgets.QLabel(self.frame)\r\n        self.label_GT_3.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\r\n        self.label_GT_3.setObjectName(\"label_GT_3\")\r\n        self.gridLayout_4.addWidget(self.label_GT_3, 1, 2, 1, 1)\r\n        self.live_cb = QtWidgets.QCheckBox(self.frame)\r\n        self.live_cb.setChecked(True)\r\n        self.live_cb.setObjectName(\"live_cb\")\r\n        self.gridLayout_4.addWidget(self.live_cb, 2, 2, 1, 1)\r\n        self.checkBox_seeGTspectra = QtWidgets.QCheckBox(self.frame)\r\n        self.checkBox_seeGTspectra.setChecked(True)\r\n        self.checkBox_seeGTspectra.setObjectName(\"checkBox_seeGTspectra\")\r\n        self.gridLayout_4.addWidget(self.checkBox_seeGTspectra, 3, 2, 1, 1)\r\n        self.checkBox_see_selection_overlay = QtWidgets.QCheckBox(self.frame)\r\n        self.checkBox_see_selection_overlay.setChecked(True)\r\n        self.checkBox_see_selection_overlay.setObjectName(\"checkBox_see_selection_overlay\")\r\n        self.gridLayout_4.addWidget(self.checkBox_see_selection_overlay, 2, 3, 1, 1)\r\n        self.pushButton_band_selection = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_band_selection.setCheckable(True)\r\n        self.pushButton_band_selection.setObjectName(\"pushButton_band_selection\")\r\n        self.gridLayout_4.addWidget(self.pushButton_band_selection, 3, 3, 1, 1)\r\n        self.horizontalLayout_2.addLayout(self.gridLayout_4)\r\n        self.line_5 = QtWidgets.QFrame(self.frame)\r\n        self.line_5.setFrameShape(QtWidgets.QFrame.VLine)\r\n        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)\r\n        self.line_5.setObjectName(\"line_5\")\r\n        self.horizontalLayout_2.addWidget(self.line_5)\r\n        self.verticalLayout_3 = QtWidgets.QVBoxLayout()\r\n        self.verticalLayout_3.setObjectName(\"verticalLayout_3\")\r\n        self.pushButton_merge = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_merge.setObjectName(\"pushButton_merge\")\r\n        self.verticalLayout_3.addWidget(self.pushButton_merge)\r\n        self.pushButton_class_name_assign = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_class_name_assign.setObjectName(\"pushButton_class_name_assign\")\r\n        self.verticalLayout_3.addWidget(self.pushButton_class_name_assign)\r\n        self.pushButton_keep_GT = QtWidgets.QPushButton(self.frame)\r\n        self.pushButton_keep_GT.setObjectName(\"pushButton_keep_GT\")\r\n        self.verticalLayout_3.addWidget(self.pushButton_keep_GT)\r\n        self.horizontalLayout_2.addLayout(self.verticalLayout_3)\r\n        self.horizontalLayout_2.setStretch(1, 1)\r\n        self.horizontalLayout_2.setStretch(2, 1)\r\n        self.horizontalLayout_2.setStretch(3, 2)\r\n        self.horizontalLayout_2.setStretch(4, 1)\r\n        self.horizontalLayout_2.setStretch(6, 1)\r\n        self.horizontalLayout_2.setStretch(7, 1)\r\n        self.horizontalLayout_2.setStretch(8, 4)\r\n        self.horizontalLayout_2.setStretch(9, 1)\r\n        self.horizontalLayout_2.setStretch(10, 2)\r\n        self.verticalLayout.addWidget(self.frame)\r\n        self.frame_2 = QtWidgets.QFrame(GroundTruthWidget)\r\n        self.frame_2.setFrameShape(QtWidgets.QFrame.NoFrame)\r\n        self.frame_2.setFrameShadow(QtWidgets.QFrame.Plain)\r\n        self.frame_2.setLineWidth(0)\r\n        self.frame_2.setObjectName(\"frame_2\")\r\n        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.frame_2)\r\n        self.horizontalLayout_4.setObjectName(\"horizontalLayout_4\")\r\n        self.splitter = QtWidgets.QSplitter(self.frame_2)\r\n        self.splitter.setStyleSheet(\"border-color: rgb(100, 100, 100);\")\r\n        self.splitter.setFrameShape(QtWidgets.QFrame.NoFrame)\r\n        self.splitter.setFrameShadow(QtWidgets.QFrame.Raised)\r\n        self.splitter.setLineWidth(2)\r\n        self.splitter.setMidLineWidth(2)\r\n        self.splitter.setOrientation(QtCore.Qt.Horizontal)\r\n        self.splitter.setObjectName(\"splitter\")\r\n        self.verticalFrame = QtWidgets.QFrame(self.splitter)\r\n        self.verticalFrame.setObjectName(\"verticalFrame\")\r\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalFrame)\r\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\r\n        self.splitter_2 = QtWidgets.QSplitter(self.verticalFrame)\r\n        self.splitter_2.setOrientation(QtCore.Qt.Vertical)\r\n        self.splitter_2.setObjectName(\"splitter_2\")\r\n        self.viewer_left = QtWidgets.QWidget(self.splitter_2)\r\n        self.viewer_left.setObjectName(\"viewer_left\")\r\n        self.viewer_right = QtWidgets.QWidget(self.splitter_2)\r\n        self.viewer_right.setObjectName(\"viewer_right\")\r\n        self.verticalLayout_2.addWidget(self.splitter_2)\r\n        self.spec_canvas = QtWidgets.QWidget(self.splitter)\r\n        self.spec_canvas.setAutoFillBackground(False)\r\n        self.spec_canvas.setObjectName(\"spec_canvas\")\r\n        self.horizontalLayout_4.addWidget(self.splitter)\r\n        self.verticalLayout.addWidget(self.frame_2)\r\n        self.verticalLayout.setStretch(1, 6)\r\n\r\n        self.retranslateUi(GroundTruthWidget)\r\n        self.stackedWidget.setCurrentIndex(0)\r\n        QtCore.QMetaObject.connectSlotsByName(GroundTruthWidget)\r\n\r\n    def retranslateUi(self, GroundTruthWidget):\r\n        _translate = QtCore.QCoreApplication.translate\r\n        self.load_btn.setText(_translate(\"GroundTruthWidget\", \"Load Cube\"))\r\n        self.pushButton_reset.setText(_translate(\"GroundTruthWidget\", \"Reset all\"))\r\n        self.groupBox_image_type.setTitle(_translate(\"GroundTruthWidget\", \"Image Choice\"))\r\n        self.radioButton_rgb_default.setText(_translate(\"GroundTruthWidget\", \"RGB default\"))\r\n        self.radioButton_rgb_user.setText(_translate(\"GroundTruthWidget\", \"RGB user\"))\r\n        self.radioButton_grayscale.setText(_translate(\"GroundTruthWidget\", \"Grayscale\"))\r\n        self.label_green_channel.setText(_translate(\"GroundTruthWidget\", \"Green\"))\r\n        self.label_blue_channel.setText(_translate(\"GroundTruthWidget\", \"Blue\"))\r\n        self.label_red_channel.setText(_translate(\"GroundTruthWidget\", \"Red\"))\r\n        self.checkBox_enable_segment.setText(_translate(\"GroundTruthWidget\", \"Enable auto segmentation\"))\r\n        self.label_metric.setText(_translate(\"GroundTruthWidget\", \"Spectral distance\"))\r\n        self.pushButton_class_selection.setText(_translate(\"GroundTruthWidget\", \"Start selection\"))\r\n        self.run_btn.setText(_translate(\"GroundTruthWidget\", \"Segmentation\"))\r\n        self.pushButton_erase_selected_pix.setText(_translate(\"GroundTruthWidget\", \"Erase Selected\"))\r\n        self.comboBox_ClassifMode.setItemText(0, _translate(\"GroundTruthWidget\", \"Supervised\"))\r\n        self.comboBox_ClassifMode.setItemText(1, _translate(\"GroundTruthWidget\", \"Unsupervised\"))\r\n        self.label_class_type.setText(_translate(\"GroundTruthWidget\", \"Classification type\"))\r\n        self.label_selec_mode.setText(_translate(\"GroundTruthWidget\", \"Select mode\"))\r\n        self.nclass_label.setText(_translate(\"GroundTruthWidget\", \"# Classes:\"))\r\n        self.comboBox_distance.setItemText(0, _translate(\"GroundTruthWidget\", \"cosine\"))\r\n        self.comboBox_distance.setItemText(1, _translate(\"GroundTruthWidget\", \"sqeuclidean\"))\r\n        self.comboBox_distance.setItemText(2, _translate(\"GroundTruthWidget\", \"correlation\"))\r\n        self.comboBox_normalized.setItemText(0, _translate(\"GroundTruthWidget\", \"Raw\"))\r\n        self.comboBox_normalized.setItemText(1, _translate(\"GroundTruthWidget\", \"Normalize\"))\r\n        self.comboBox_pixel_selection_mode.setItemText(0, _translate(\"GroundTruthWidget\", \"rectangle\"))\r\n        self.comboBox_pixel_selection_mode.setItemText(1, _translate(\"GroundTruthWidget\", \"ellipse\"))\r\n        self.comboBox_pixel_selection_mode.setItemText(2, _translate(\"GroundTruthWidget\", \"pixel\"))\r\n        self.label_thr.setText(_translate(\"GroundTruthWidget\", \"thr\"))\r\n        self.label_GT_3.setText(_translate(\"GroundTruthWidget\", \"GT transparency\"))\r\n        self.live_cb.setText(_translate(\"GroundTruthWidget\", \"Spectra visualization\"))\r\n        self.checkBox_seeGTspectra.setText(_translate(\"GroundTruthWidget\", \"See GT spectra\"))\r\n        self.checkBox_see_selection_overlay.setText(_translate(\"GroundTruthWidget\", \"See selection\"))\r\n        self.pushButton_band_selection.setText(_translate(\"GroundTruthWidget\", \"Band selection\"))\r\n        self.pushButton_merge.setText(_translate(\"GroundTruthWidget\", \"Merge GT and select\"))\r\n        self.pushButton_class_name_assign.setText(_translate(\"GroundTruthWidget\", \"Class name assign\"))\r\n        self.pushButton_keep_GT.setText(_translate(\"GroundTruthWidget\", \"Save GT map\"))\r\n        self.viewer_left.setToolTip(_translate(\"GroundTruthWidget\", \"Promote to ZoomableGraphicsView\"))\r\n        self.viewer_right.setToolTip(_translate(\"GroundTruthWidget\", \"Promote to ZoomableGraphicsView\"))\r\n        self.spec_canvas.setToolTip(_translate(\"GroundTruthWidget\", \"Promote to FigureCanvas\"))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    GroundTruthWidget = QtWidgets.QWidget()\r\n    ui = Ui_GroundTruthWidget()\r\n    ui.setupUi(GroundTruthWidget)\r\n    GroundTruthWidget.show()\r\n    sys.exit(app.exec_())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ground_truth/ground_truth_window.py b/ground_truth/ground_truth_window.py
--- a/ground_truth/ground_truth_window.py	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/ground_truth/ground_truth_window.py	(date 1752488324342)
@@ -14,7 +14,7 @@
 class Ui_GroundTruthWidget(object):
     def setupUi(self, GroundTruthWidget):
         GroundTruthWidget.setObjectName("GroundTruthWidget")
-        GroundTruthWidget.resize(1327, 609)
+        GroundTruthWidget.resize(1155, 609)
         sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
@@ -40,141 +40,51 @@
         self.pushButton_reset.setObjectName("pushButton_reset")
         self.verticalLayout_7.addWidget(self.pushButton_reset)
         self.horizontalLayout_2.addLayout(self.verticalLayout_7)
-        self.line_4 = QtWidgets.QFrame(self.frame)
-        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
-        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
-        self.line_4.setObjectName("line_4")
-        self.horizontalLayout_2.addWidget(self.line_4)
-        self.groupBox_image_type = QtWidgets.QGroupBox(self.frame)
-        self.groupBox_image_type.setObjectName("groupBox_image_type")
-        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.groupBox_image_type)
-        self.verticalLayout_5.setObjectName("verticalLayout_5")
-        self.radioButton_rgb_default = QtWidgets.QRadioButton(self.groupBox_image_type)
-        self.radioButton_rgb_default.setChecked(True)
-        self.radioButton_rgb_default.setObjectName("radioButton_rgb_default")
-        self.verticalLayout_5.addWidget(self.radioButton_rgb_default)
-        self.radioButton_rgb_user = QtWidgets.QRadioButton(self.groupBox_image_type)
-        self.radioButton_rgb_user.setEnabled(True)
-        self.radioButton_rgb_user.setChecked(False)
-        self.radioButton_rgb_user.setObjectName("radioButton_rgb_user")
-        self.verticalLayout_5.addWidget(self.radioButton_rgb_user)
-        self.radioButton_grayscale = QtWidgets.QRadioButton(self.groupBox_image_type)
-        self.radioButton_grayscale.setObjectName("radioButton_grayscale")
-        self.verticalLayout_5.addWidget(self.radioButton_grayscale)
-        self.horizontalLayout_2.addWidget(self.groupBox_image_type)
-        self.gridLayout_RGBchannels_3 = QtWidgets.QGridLayout()
-        self.gridLayout_RGBchannels_3.setObjectName("gridLayout_RGBchannels_3")
-        self.spinBox_green_channel = QtWidgets.QSpinBox(self.frame)
-        self.spinBox_green_channel.setMaximum(149)
-        self.spinBox_green_channel.setProperty("value", 0)
-        self.spinBox_green_channel.setObjectName("spinBox_green_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_green_channel, 1, 1, 1, 1)
-        self.spinBox_blue_channel = QtWidgets.QSpinBox(self.frame)
-        self.spinBox_blue_channel.setMaximum(149)
-        self.spinBox_blue_channel.setProperty("value", 0)
-        self.spinBox_blue_channel.setObjectName("spinBox_blue_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_blue_channel, 2, 1, 1, 1)
-        self.spinBox_red_channel = QtWidgets.QSpinBox(self.frame)
-        self.spinBox_red_channel.setMaximum(149)
-        self.spinBox_red_channel.setSingleStep(1)
-        self.spinBox_red_channel.setProperty("value", 0)
-        self.spinBox_red_channel.setObjectName("spinBox_red_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_red_channel, 0, 1, 1, 1)
-        self.horizontalSlider_blue_channel = QtWidgets.QSlider(self.frame)
-        self.horizontalSlider_blue_channel.setMaximum(149)
-        self.horizontalSlider_blue_channel.setProperty("value", 0)
-        self.horizontalSlider_blue_channel.setOrientation(QtCore.Qt.Horizontal)
-        self.horizontalSlider_blue_channel.setObjectName("horizontalSlider_blue_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_blue_channel, 2, 2, 1, 1)
-        self.label_green_channel = QtWidgets.QLabel(self.frame)
-        self.label_green_channel.setAlignment(QtCore.Qt.AlignCenter)
-        self.label_green_channel.setObjectName("label_green_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.label_green_channel, 1, 0, 1, 1)
-        self.label_blue_channel = QtWidgets.QLabel(self.frame)
-        self.label_blue_channel.setAlignment(QtCore.Qt.AlignCenter)
-        self.label_blue_channel.setObjectName("label_blue_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.label_blue_channel, 2, 0, 1, 1)
-        self.label_red_channel = QtWidgets.QLabel(self.frame)
-        self.label_red_channel.setAlignment(QtCore.Qt.AlignCenter)
-        self.label_red_channel.setObjectName("label_red_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.label_red_channel, 0, 0, 1, 1)
-        self.horizontalSlider_green_channel = QtWidgets.QSlider(self.frame)
-        self.horizontalSlider_green_channel.setMaximum(149)
-        self.horizontalSlider_green_channel.setProperty("value", 0)
-        self.horizontalSlider_green_channel.setOrientation(QtCore.Qt.Horizontal)
-        self.horizontalSlider_green_channel.setObjectName("horizontalSlider_green_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_green_channel, 1, 2, 1, 1)
-        self.horizontalSlider_red_channel = QtWidgets.QSlider(self.frame)
-        self.horizontalSlider_red_channel.setMinimumSize(QtCore.QSize(60, 0))
-        self.horizontalSlider_red_channel.setMaximum(149)
-        self.horizontalSlider_red_channel.setProperty("value", 0)
-        self.horizontalSlider_red_channel.setOrientation(QtCore.Qt.Horizontal)
-        self.horizontalSlider_red_channel.setObjectName("horizontalSlider_red_channel")
-        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_red_channel, 0, 2, 1, 1)
-        self.horizontalLayout_2.addLayout(self.gridLayout_RGBchannels_3)
-        self.line = QtWidgets.QFrame(self.frame)
-        self.line.setFrameShape(QtWidgets.QFrame.VLine)
-        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
-        self.line.setObjectName("line")
-        self.horizontalLayout_2.addWidget(self.line)
+        self.tabWidget = QtWidgets.QTabWidget(self.frame)
+        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.West)
+        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
+        self.tabWidget.setObjectName("tabWidget")
+        self.tab_2_Segmentation = QtWidgets.QWidget()
+        self.tab_2_Segmentation.setObjectName("tab_2_Segmentation")
+        self.horizontalLayout_6 = QtWidgets.QHBoxLayout(self.tab_2_Segmentation)
+        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
         self.gridLayout = QtWidgets.QGridLayout()
         self.gridLayout.setObjectName("gridLayout")
-        self.checkBox_enable_segment = QtWidgets.QCheckBox(self.frame)
-        self.checkBox_enable_segment.setChecked(True)
-        self.checkBox_enable_segment.setObjectName("checkBox_enable_segment")
-        self.gridLayout.addWidget(self.checkBox_enable_segment, 3, 7, 1, 2)
-        self.line_2 = QtWidgets.QFrame(self.frame)
+        self.line_2 = QtWidgets.QFrame(self.tab_2_Segmentation)
         self.line_2.setLineWidth(1)
         self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
         self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
         self.line_2.setObjectName("line_2")
         self.gridLayout.addWidget(self.line_2, 0, 6, 4, 1)
-        self.label_metric = QtWidgets.QLabel(self.frame)
-        self.label_metric.setAlignment(QtCore.Qt.AlignCenter)
-        self.label_metric.setObjectName("label_metric")
-        self.gridLayout.addWidget(self.label_metric, 0, 4, 1, 1)
-        self.pushButton_class_selection = QtWidgets.QPushButton(self.frame)
-        self.pushButton_class_selection.setEnabled(True)
-        self.pushButton_class_selection.setStyleSheet("background-color: rgba(186, 255, 112, 125);")
-        self.pushButton_class_selection.setCheckable(True)
-        self.pushButton_class_selection.setObjectName("pushButton_class_selection")
-        self.gridLayout.addWidget(self.pushButton_class_selection, 0, 7, 1, 1)
-        self.run_btn = QtWidgets.QPushButton(self.frame)
-        self.run_btn.setStyleSheet("background-color: rgb(173, 173, 173);")
-        self.run_btn.setObjectName("run_btn")
-        self.gridLayout.addWidget(self.run_btn, 3, 4, 1, 1)
-        self.pushButton_erase_selected_pix = QtWidgets.QPushButton(self.frame)
-        self.pushButton_erase_selected_pix.setStyleSheet("background-color: rgb(255, 206, 206);")
-        self.pushButton_erase_selected_pix.setCheckable(True)
-        self.pushButton_erase_selected_pix.setObjectName("pushButton_erase_selected_pix")
-        self.gridLayout.addWidget(self.pushButton_erase_selected_pix, 2, 7, 1, 1)
-        self.comboBox_ClassifMode = QtWidgets.QComboBox(self.frame)
+        self.slider_class_thr = QtWidgets.QSlider(self.tab_2_Segmentation)
+        self.slider_class_thr.setMinimum(0)
+        self.slider_class_thr.setMaximum(100)
+        self.slider_class_thr.setProperty("value", 100)
+        self.slider_class_thr.setOrientation(QtCore.Qt.Vertical)
+        self.slider_class_thr.setTickPosition(QtWidgets.QSlider.NoTicks)
+        self.slider_class_thr.setObjectName("slider_class_thr")
+        self.gridLayout.addWidget(self.slider_class_thr, 2, 5, 2, 1)
+        self.comboBox_ClassifMode = QtWidgets.QComboBox(self.tab_2_Segmentation)
         self.comboBox_ClassifMode.setObjectName("comboBox_ClassifMode")
         self.comboBox_ClassifMode.addItem("")
         self.comboBox_ClassifMode.addItem("")
         self.gridLayout.addWidget(self.comboBox_ClassifMode, 2, 2, 1, 2)
-        self.label_class_type = QtWidgets.QLabel(self.frame)
+        self.label_class_type = QtWidgets.QLabel(self.tab_2_Segmentation)
         self.label_class_type.setAlignment(QtCore.Qt.AlignCenter)
         self.label_class_type.setObjectName("label_class_type")
         self.gridLayout.addWidget(self.label_class_type, 0, 2, 1, 2)
-        self.label_selec_mode = QtWidgets.QLabel(self.frame)
-        self.label_selec_mode.setAlignment(QtCore.Qt.AlignCenter)
-        self.label_selec_mode.setObjectName("label_selec_mode")
-        self.gridLayout.addWidget(self.label_selec_mode, 0, 8, 1, 1)
-        self.nclass_label = QtWidgets.QLabel(self.frame)
+        self.nclass_label = QtWidgets.QLabel(self.tab_2_Segmentation)
         self.nclass_label.setObjectName("nclass_label")
         self.gridLayout.addWidget(self.nclass_label, 3, 2, 1, 1)
-        self.slider_class_thr = QtWidgets.QSlider(self.frame)
-        self.slider_class_thr.setMinimum(0)
-        self.slider_class_thr.setMaximum(100)
-        self.slider_class_thr.setProperty("value", 100)
-        self.slider_class_thr.setOrientation(QtCore.Qt.Vertical)
-        self.slider_class_thr.setTickPosition(QtWidgets.QSlider.NoTicks)
-        self.slider_class_thr.setObjectName("slider_class_thr")
-        self.gridLayout.addWidget(self.slider_class_thr, 2, 5, 2, 1)
+        self.nclass_box = QtWidgets.QSpinBox(self.tab_2_Segmentation)
+        self.nclass_box.setMinimum(2)
+        self.nclass_box.setMaximum(20)
+        self.nclass_box.setProperty("value", 3)
+        self.nclass_box.setObjectName("nclass_box")
+        self.gridLayout.addWidget(self.nclass_box, 3, 3, 1, 1)
         self.verticalLayout_4 = QtWidgets.QVBoxLayout()
         self.verticalLayout_4.setObjectName("verticalLayout_4")
-        self.stackedWidget = QtWidgets.QStackedWidget(self.frame)
+        self.stackedWidget = QtWidgets.QStackedWidget(self.tab_2_Segmentation)
         self.stackedWidget.setObjectName("stackedWidget")
         self.page_distance = QtWidgets.QWidget()
         self.page_distance.setObjectName("page_distance")
@@ -209,22 +119,117 @@
         self.stackedWidget.addWidget(self.page_normalized)
         self.verticalLayout_4.addWidget(self.stackedWidget)
         self.gridLayout.addLayout(self.verticalLayout_4, 2, 4, 1, 1)
-        self.comboBox_pixel_selection_mode = QtWidgets.QComboBox(self.frame)
+        self.label_metric = QtWidgets.QLabel(self.tab_2_Segmentation)
+        self.label_metric.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_metric.setObjectName("label_metric")
+        self.gridLayout.addWidget(self.label_metric, 0, 4, 1, 1)
+        self.run_btn = QtWidgets.QPushButton(self.tab_2_Segmentation)
+        self.run_btn.setStyleSheet("background-color: rgb(173, 173, 173);")
+        self.run_btn.setObjectName("run_btn")
+        self.gridLayout.addWidget(self.run_btn, 3, 4, 1, 1)
+        self.checkBox_enable_segment = QtWidgets.QCheckBox(self.tab_2_Segmentation)
+        self.checkBox_enable_segment.setChecked(True)
+        self.checkBox_enable_segment.setObjectName("checkBox_enable_segment")
+        self.gridLayout.addWidget(self.checkBox_enable_segment, 3, 7, 1, 2)
+        self.label_thr = QtWidgets.QLabel(self.tab_2_Segmentation)
+        self.label_thr.setObjectName("label_thr")
+        self.gridLayout.addWidget(self.label_thr, 0, 5, 1, 1)
+        self.pushButton_class_selection = QtWidgets.QPushButton(self.tab_2_Segmentation)
+        self.pushButton_class_selection.setEnabled(True)
+        self.pushButton_class_selection.setStyleSheet("background-color: rgba(186, 255, 112, 125);")
+        self.pushButton_class_selection.setCheckable(True)
+        self.pushButton_class_selection.setObjectName("pushButton_class_selection")
+        self.gridLayout.addWidget(self.pushButton_class_selection, 0, 7, 1, 1)
+        self.pushButton_erase_selected_pix = QtWidgets.QPushButton(self.tab_2_Segmentation)
+        self.pushButton_erase_selected_pix.setStyleSheet("background-color: rgb(255, 206, 206);")
+        self.pushButton_erase_selected_pix.setCheckable(True)
+        self.pushButton_erase_selected_pix.setObjectName("pushButton_erase_selected_pix")
+        self.gridLayout.addWidget(self.pushButton_erase_selected_pix, 2, 7, 1, 1)
+        self.comboBox_pixel_selection_mode = QtWidgets.QComboBox(self.tab_2_Segmentation)
         self.comboBox_pixel_selection_mode.setObjectName("comboBox_pixel_selection_mode")
         self.comboBox_pixel_selection_mode.addItem("")
         self.comboBox_pixel_selection_mode.addItem("")
         self.comboBox_pixel_selection_mode.addItem("")
         self.gridLayout.addWidget(self.comboBox_pixel_selection_mode, 2, 8, 1, 1)
-        self.nclass_box = QtWidgets.QSpinBox(self.frame)
-        self.nclass_box.setMinimum(2)
-        self.nclass_box.setMaximum(20)
-        self.nclass_box.setProperty("value", 3)
-        self.nclass_box.setObjectName("nclass_box")
-        self.gridLayout.addWidget(self.nclass_box, 3, 3, 1, 1)
-        self.label_thr = QtWidgets.QLabel(self.frame)
-        self.label_thr.setObjectName("label_thr")
-        self.gridLayout.addWidget(self.label_thr, 0, 5, 1, 1)
-        self.horizontalLayout_2.addLayout(self.gridLayout)
+        self.label_selec_mode = QtWidgets.QLabel(self.tab_2_Segmentation)
+        self.label_selec_mode.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_selec_mode.setObjectName("label_selec_mode")
+        self.gridLayout.addWidget(self.label_selec_mode, 0, 8, 1, 1)
+        self.horizontalLayout_6.addLayout(self.gridLayout)
+        self.tabWidget.addTab(self.tab_2_Segmentation, "")
+        self.tab_image_choice = QtWidgets.QWidget()
+        self.tab_image_choice.setObjectName("tab_image_choice")
+        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.tab_image_choice)
+        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
+        self.groupBox_image_type = QtWidgets.QGroupBox(self.tab_image_choice)
+        self.groupBox_image_type.setObjectName("groupBox_image_type")
+        self.gridLayout_2 = QtWidgets.QGridLayout(self.groupBox_image_type)
+        self.gridLayout_2.setObjectName("gridLayout_2")
+        self.radioButton_rgb_user = QtWidgets.QRadioButton(self.groupBox_image_type)
+        self.radioButton_rgb_user.setEnabled(True)
+        self.radioButton_rgb_user.setChecked(False)
+        self.radioButton_rgb_user.setObjectName("radioButton_rgb_user")
+        self.gridLayout_2.addWidget(self.radioButton_rgb_user, 1, 0, 1, 1)
+        self.radioButton_grayscale = QtWidgets.QRadioButton(self.groupBox_image_type)
+        self.radioButton_grayscale.setObjectName("radioButton_grayscale")
+        self.gridLayout_2.addWidget(self.radioButton_grayscale, 2, 0, 1, 1)
+        self.radioButton_rgb_default = QtWidgets.QRadioButton(self.groupBox_image_type)
+        self.radioButton_rgb_default.setChecked(True)
+        self.radioButton_rgb_default.setObjectName("radioButton_rgb_default")
+        self.gridLayout_2.addWidget(self.radioButton_rgb_default, 0, 0, 1, 1)
+        self.horizontalLayout_5.addWidget(self.groupBox_image_type)
+        self.gridLayout_RGBchannels_3 = QtWidgets.QGridLayout()
+        self.gridLayout_RGBchannels_3.setObjectName("gridLayout_RGBchannels_3")
+        self.spinBox_green_channel = QtWidgets.QSpinBox(self.tab_image_choice)
+        self.spinBox_green_channel.setMaximum(149)
+        self.spinBox_green_channel.setProperty("value", 0)
+        self.spinBox_green_channel.setObjectName("spinBox_green_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_green_channel, 1, 1, 1, 1)
+        self.spinBox_blue_channel = QtWidgets.QSpinBox(self.tab_image_choice)
+        self.spinBox_blue_channel.setMaximum(149)
+        self.spinBox_blue_channel.setProperty("value", 0)
+        self.spinBox_blue_channel.setObjectName("spinBox_blue_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_blue_channel, 2, 1, 1, 1)
+        self.spinBox_red_channel = QtWidgets.QSpinBox(self.tab_image_choice)
+        self.spinBox_red_channel.setMaximum(149)
+        self.spinBox_red_channel.setSingleStep(1)
+        self.spinBox_red_channel.setProperty("value", 0)
+        self.spinBox_red_channel.setObjectName("spinBox_red_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.spinBox_red_channel, 0, 1, 1, 1)
+        self.horizontalSlider_blue_channel = QtWidgets.QSlider(self.tab_image_choice)
+        self.horizontalSlider_blue_channel.setMaximum(149)
+        self.horizontalSlider_blue_channel.setProperty("value", 0)
+        self.horizontalSlider_blue_channel.setOrientation(QtCore.Qt.Horizontal)
+        self.horizontalSlider_blue_channel.setObjectName("horizontalSlider_blue_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_blue_channel, 2, 2, 1, 1)
+        self.label_green_channel = QtWidgets.QLabel(self.tab_image_choice)
+        self.label_green_channel.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_green_channel.setObjectName("label_green_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.label_green_channel, 1, 0, 1, 1)
+        self.label_blue_channel = QtWidgets.QLabel(self.tab_image_choice)
+        self.label_blue_channel.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_blue_channel.setObjectName("label_blue_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.label_blue_channel, 2, 0, 1, 1)
+        self.label_red_channel = QtWidgets.QLabel(self.tab_image_choice)
+        self.label_red_channel.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_red_channel.setObjectName("label_red_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.label_red_channel, 0, 0, 1, 1)
+        self.horizontalSlider_green_channel = QtWidgets.QSlider(self.tab_image_choice)
+        self.horizontalSlider_green_channel.setMaximum(149)
+        self.horizontalSlider_green_channel.setProperty("value", 0)
+        self.horizontalSlider_green_channel.setOrientation(QtCore.Qt.Horizontal)
+        self.horizontalSlider_green_channel.setObjectName("horizontalSlider_green_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_green_channel, 1, 2, 1, 1)
+        self.horizontalSlider_red_channel = QtWidgets.QSlider(self.tab_image_choice)
+        self.horizontalSlider_red_channel.setMinimumSize(QtCore.QSize(60, 0))
+        self.horizontalSlider_red_channel.setMaximum(149)
+        self.horizontalSlider_red_channel.setProperty("value", 0)
+        self.horizontalSlider_red_channel.setOrientation(QtCore.Qt.Horizontal)
+        self.horizontalSlider_red_channel.setObjectName("horizontalSlider_red_channel")
+        self.gridLayout_RGBchannels_3.addWidget(self.horizontalSlider_red_channel, 0, 2, 1, 1)
+        self.horizontalLayout_5.addLayout(self.gridLayout_RGBchannels_3)
+        self.tabWidget.addTab(self.tab_image_choice, "")
+        self.horizontalLayout_2.addWidget(self.tabWidget)
         self.frame_legend = QtWidgets.QFrame(self.frame)
         self.frame_legend.setFrameShape(QtWidgets.QFrame.StyledPanel)
         self.frame_legend.setFrameShadow(QtWidgets.QFrame.Raised)
@@ -232,42 +237,45 @@
         self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.frame_legend)
         self.verticalLayout_6.setObjectName("verticalLayout_6")
         self.horizontalLayout_2.addWidget(self.frame_legend)
-        self.line_3 = QtWidgets.QFrame(self.frame)
-        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
-        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
-        self.line_3.setObjectName("line_3")
-        self.horizontalLayout_2.addWidget(self.line_3)
-        self.gridLayout_4 = QtWidgets.QGridLayout()
-        self.gridLayout_4.setObjectName("gridLayout_4")
-        self.horizontalSlider_transparency_GT = QtWidgets.QSlider(self.frame)
+        self.groupBox = QtWidgets.QGroupBox(self.frame)
+        self.groupBox.setObjectName("groupBox")
+        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.groupBox)
+        self.verticalLayout_8.setObjectName("verticalLayout_8")
+        self.checkBox_live_spectra = QtWidgets.QCheckBox(self.groupBox)
+        self.checkBox_live_spectra.setChecked(True)
+        self.checkBox_live_spectra.setObjectName("checkBox_live_spectra")
+        self.verticalLayout_8.addWidget(self.checkBox_live_spectra)
+        self.checkBox_seeGTspectra = QtWidgets.QCheckBox(self.groupBox)
+        self.checkBox_seeGTspectra.setChecked(True)
+        self.checkBox_seeGTspectra.setObjectName("checkBox_seeGTspectra")
+        self.verticalLayout_8.addWidget(self.checkBox_seeGTspectra)
+        self.pushButton_band_selection = QtWidgets.QPushButton(self.groupBox)
+        self.pushButton_band_selection.setCheckable(True)
+        self.pushButton_band_selection.setObjectName("pushButton_band_selection")
+        self.verticalLayout_8.addWidget(self.pushButton_band_selection)
+        self.horizontalLayout_2.addWidget(self.groupBox)
+        self.groupBox_2 = QtWidgets.QGroupBox(self.frame)
+        self.groupBox_2.setObjectName("groupBox_2")
+        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.groupBox_2)
+        self.verticalLayout_9.setObjectName("verticalLayout_9")
+        self.label_GT_overlay = QtWidgets.QLabel(self.groupBox_2)
+        self.label_GT_overlay.setMaximumSize(QtCore.QSize(16777215, 20))
+        self.label_GT_overlay.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_GT_overlay.setObjectName("label_GT_overlay")
+        self.verticalLayout_9.addWidget(self.label_GT_overlay)
+        self.horizontalSlider_transparency_GT = QtWidgets.QSlider(self.groupBox_2)
         self.horizontalSlider_transparency_GT.setMinimumSize(QtCore.QSize(60, 0))
         self.horizontalSlider_transparency_GT.setMaximum(100)
         self.horizontalSlider_transparency_GT.setProperty("value", 0)
         self.horizontalSlider_transparency_GT.setSliderPosition(0)
         self.horizontalSlider_transparency_GT.setOrientation(QtCore.Qt.Horizontal)
         self.horizontalSlider_transparency_GT.setObjectName("horizontalSlider_transparency_GT")
-        self.gridLayout_4.addWidget(self.horizontalSlider_transparency_GT, 1, 3, 1, 1)
-        self.label_GT_3 = QtWidgets.QLabel(self.frame)
-        self.label_GT_3.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_GT_3.setObjectName("label_GT_3")
-        self.gridLayout_4.addWidget(self.label_GT_3, 1, 2, 1, 1)
-        self.live_cb = QtWidgets.QCheckBox(self.frame)
-        self.live_cb.setChecked(True)
-        self.live_cb.setObjectName("live_cb")
-        self.gridLayout_4.addWidget(self.live_cb, 2, 2, 1, 1)
-        self.checkBox_seeGTspectra = QtWidgets.QCheckBox(self.frame)
-        self.checkBox_seeGTspectra.setChecked(True)
-        self.checkBox_seeGTspectra.setObjectName("checkBox_seeGTspectra")
-        self.gridLayout_4.addWidget(self.checkBox_seeGTspectra, 3, 2, 1, 1)
-        self.checkBox_see_selection_overlay = QtWidgets.QCheckBox(self.frame)
+        self.verticalLayout_9.addWidget(self.horizontalSlider_transparency_GT)
+        self.checkBox_see_selection_overlay = QtWidgets.QCheckBox(self.groupBox_2)
         self.checkBox_see_selection_overlay.setChecked(True)
         self.checkBox_see_selection_overlay.setObjectName("checkBox_see_selection_overlay")
-        self.gridLayout_4.addWidget(self.checkBox_see_selection_overlay, 2, 3, 1, 1)
-        self.pushButton_band_selection = QtWidgets.QPushButton(self.frame)
-        self.pushButton_band_selection.setCheckable(True)
-        self.pushButton_band_selection.setObjectName("pushButton_band_selection")
-        self.gridLayout_4.addWidget(self.pushButton_band_selection, 3, 3, 1, 1)
-        self.horizontalLayout_2.addLayout(self.gridLayout_4)
+        self.verticalLayout_9.addWidget(self.checkBox_see_selection_overlay)
+        self.horizontalLayout_2.addWidget(self.groupBox_2)
         self.line_5 = QtWidgets.QFrame(self.frame)
         self.line_5.setFrameShape(QtWidgets.QFrame.VLine)
         self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
@@ -281,19 +289,15 @@
         self.pushButton_class_name_assign = QtWidgets.QPushButton(self.frame)
         self.pushButton_class_name_assign.setObjectName("pushButton_class_name_assign")
         self.verticalLayout_3.addWidget(self.pushButton_class_name_assign)
-        self.pushButton_keep_GT = QtWidgets.QPushButton(self.frame)
-        self.pushButton_keep_GT.setObjectName("pushButton_keep_GT")
-        self.verticalLayout_3.addWidget(self.pushButton_keep_GT)
+        self.pushButton_save_GT = QtWidgets.QPushButton(self.frame)
+        self.pushButton_save_GT.setObjectName("pushButton_save_GT")
+        self.verticalLayout_3.addWidget(self.pushButton_save_GT)
         self.horizontalLayout_2.addLayout(self.verticalLayout_3)
-        self.horizontalLayout_2.setStretch(1, 1)
+        self.horizontalLayout_2.setStretch(0, 1)
+        self.horizontalLayout_2.setStretch(1, 4)
         self.horizontalLayout_2.setStretch(2, 1)
-        self.horizontalLayout_2.setStretch(3, 2)
-        self.horizontalLayout_2.setStretch(4, 1)
+        self.horizontalLayout_2.setStretch(5, 1)
         self.horizontalLayout_2.setStretch(6, 1)
-        self.horizontalLayout_2.setStretch(7, 1)
-        self.horizontalLayout_2.setStretch(8, 4)
-        self.horizontalLayout_2.setStretch(9, 1)
-        self.horizontalLayout_2.setStretch(10, 2)
         self.verticalLayout.addWidget(self.frame)
         self.frame_2 = QtWidgets.QFrame(GroundTruthWidget)
         self.frame_2.setFrameShape(QtWidgets.QFrame.NoFrame)
@@ -323,6 +327,11 @@
         self.viewer_right.setObjectName("viewer_right")
         self.verticalLayout_2.addWidget(self.splitter_2)
         self.spec_canvas = QtWidgets.QWidget(self.splitter)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.spec_canvas.sizePolicy().hasHeightForWidth())
+        self.spec_canvas.setSizePolicy(sizePolicy)
         self.spec_canvas.setAutoFillBackground(False)
         self.spec_canvas.setObjectName("spec_canvas")
         self.horizontalLayout_4.addWidget(self.splitter)
@@ -330,6 +339,7 @@
         self.verticalLayout.setStretch(1, 6)
 
         self.retranslateUi(GroundTruthWidget)
+        self.tabWidget.setCurrentIndex(0)
         self.stackedWidget.setCurrentIndex(0)
         QtCore.QMetaObject.connectSlotsByName(GroundTruthWidget)
 
@@ -337,40 +347,44 @@
         _translate = QtCore.QCoreApplication.translate
         self.load_btn.setText(_translate("GroundTruthWidget", "Load Cube"))
         self.pushButton_reset.setText(_translate("GroundTruthWidget", "Reset all"))
-        self.groupBox_image_type.setTitle(_translate("GroundTruthWidget", "Image Choice"))
-        self.radioButton_rgb_default.setText(_translate("GroundTruthWidget", "RGB default"))
-        self.radioButton_rgb_user.setText(_translate("GroundTruthWidget", "RGB user"))
-        self.radioButton_grayscale.setText(_translate("GroundTruthWidget", "Grayscale"))
-        self.label_green_channel.setText(_translate("GroundTruthWidget", "Green"))
-        self.label_blue_channel.setText(_translate("GroundTruthWidget", "Blue"))
-        self.label_red_channel.setText(_translate("GroundTruthWidget", "Red"))
-        self.checkBox_enable_segment.setText(_translate("GroundTruthWidget", "Enable auto segmentation"))
-        self.label_metric.setText(_translate("GroundTruthWidget", "Spectral distance"))
-        self.pushButton_class_selection.setText(_translate("GroundTruthWidget", "Start selection"))
-        self.run_btn.setText(_translate("GroundTruthWidget", "Segmentation"))
-        self.pushButton_erase_selected_pix.setText(_translate("GroundTruthWidget", "Erase Selected"))
         self.comboBox_ClassifMode.setItemText(0, _translate("GroundTruthWidget", "Supervised"))
         self.comboBox_ClassifMode.setItemText(1, _translate("GroundTruthWidget", "Unsupervised"))
         self.label_class_type.setText(_translate("GroundTruthWidget", "Classification type"))
-        self.label_selec_mode.setText(_translate("GroundTruthWidget", "Select mode"))
         self.nclass_label.setText(_translate("GroundTruthWidget", "# Classes:"))
         self.comboBox_distance.setItemText(0, _translate("GroundTruthWidget", "cosine"))
         self.comboBox_distance.setItemText(1, _translate("GroundTruthWidget", "sqeuclidean"))
         self.comboBox_distance.setItemText(2, _translate("GroundTruthWidget", "correlation"))
         self.comboBox_normalized.setItemText(0, _translate("GroundTruthWidget", "Raw"))
         self.comboBox_normalized.setItemText(1, _translate("GroundTruthWidget", "Normalize"))
+        self.label_metric.setText(_translate("GroundTruthWidget", "Spectral distance"))
+        self.run_btn.setText(_translate("GroundTruthWidget", "Segmentation"))
+        self.checkBox_enable_segment.setText(_translate("GroundTruthWidget", "Enable auto segmentation"))
+        self.label_thr.setText(_translate("GroundTruthWidget", "thr"))
+        self.pushButton_class_selection.setText(_translate("GroundTruthWidget", "Start selection"))
+        self.pushButton_erase_selected_pix.setText(_translate("GroundTruthWidget", "Erase Selected"))
         self.comboBox_pixel_selection_mode.setItemText(0, _translate("GroundTruthWidget", "rectangle"))
         self.comboBox_pixel_selection_mode.setItemText(1, _translate("GroundTruthWidget", "ellipse"))
         self.comboBox_pixel_selection_mode.setItemText(2, _translate("GroundTruthWidget", "pixel"))
-        self.label_thr.setText(_translate("GroundTruthWidget", "thr"))
-        self.label_GT_3.setText(_translate("GroundTruthWidget", "GT transparency"))
-        self.live_cb.setText(_translate("GroundTruthWidget", "Spectra visualization"))
+        self.label_selec_mode.setText(_translate("GroundTruthWidget", "Select mode"))
+        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2_Segmentation), _translate("GroundTruthWidget", "Segment"))
+        self.groupBox_image_type.setTitle(_translate("GroundTruthWidget", "Image Choice"))
+        self.radioButton_rgb_user.setText(_translate("GroundTruthWidget", "RGB user"))
+        self.radioButton_grayscale.setText(_translate("GroundTruthWidget", "Grayscale"))
+        self.radioButton_rgb_default.setText(_translate("GroundTruthWidget", "RGB default"))
+        self.label_green_channel.setText(_translate("GroundTruthWidget", "Green"))
+        self.label_blue_channel.setText(_translate("GroundTruthWidget", "Blue"))
+        self.label_red_channel.setText(_translate("GroundTruthWidget", "Red"))
+        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_image_choice), _translate("GroundTruthWidget", "Cube"))
+        self.groupBox.setTitle(_translate("GroundTruthWidget", "Spectra"))
+        self.checkBox_live_spectra.setText(_translate("GroundTruthWidget", "Live spectra"))
         self.checkBox_seeGTspectra.setText(_translate("GroundTruthWidget", "See GT spectra"))
-        self.checkBox_see_selection_overlay.setText(_translate("GroundTruthWidget", "See selection"))
         self.pushButton_band_selection.setText(_translate("GroundTruthWidget", "Band selection"))
+        self.groupBox_2.setTitle(_translate("GroundTruthWidget", "Overlay on Cube Image"))
+        self.label_GT_overlay.setText(_translate("GroundTruthWidget", "GT transparency"))
+        self.checkBox_see_selection_overlay.setText(_translate("GroundTruthWidget", "See manual selection"))
         self.pushButton_merge.setText(_translate("GroundTruthWidget", "Merge GT and select"))
         self.pushButton_class_name_assign.setText(_translate("GroundTruthWidget", "Class name assign"))
-        self.pushButton_keep_GT.setText(_translate("GroundTruthWidget", "Save GT map"))
+        self.pushButton_save_GT.setText(_translate("GroundTruthWidget", "Save GT map"))
         self.viewer_left.setToolTip(_translate("GroundTruthWidget", "Promote to ZoomableGraphicsView"))
         self.viewer_right.setToolTip(_translate("GroundTruthWidget", "Promote to ZoomableGraphicsView"))
         self.spec_canvas.setToolTip(_translate("GroundTruthWidget", "Promote to FigureCanvas"))
Index: ground_truth/ground_truth_window.ui
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<ui version=\"4.0\">\r\n <class>GroundTruthWidget</class>\r\n <widget class=\"QWidget\" name=\"GroundTruthWidget\">\r\n  <property name=\"geometry\">\r\n   <rect>\r\n    <x>0</x>\r\n    <y>0</y>\r\n    <width>1327</width>\r\n    <height>609</height>\r\n   </rect>\r\n  </property>\r\n  <property name=\"sizePolicy\">\r\n   <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Fixed\">\r\n    <horstretch>0</horstretch>\r\n    <verstretch>0</verstretch>\r\n   </sizepolicy>\r\n  </property>\r\n  <property name=\"styleSheet\">\r\n   <string notr=\"true\">background-color: rgb(181, 181, 181);</string>\r\n  </property>\r\n  <layout class=\"QVBoxLayout\" name=\"verticalLayout\" stretch=\"0,6\">\r\n   <item>\r\n    <widget class=\"QFrame\" name=\"frame\">\r\n     <property name=\"autoFillBackground\">\r\n      <bool>false</bool>\r\n     </property>\r\n     <property name=\"frameShape\">\r\n      <enum>QFrame::StyledPanel</enum>\r\n     </property>\r\n     <property name=\"frameShadow\">\r\n      <enum>QFrame::Raised</enum>\r\n     </property>\r\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\" stretch=\"0,1,1,2,1,0,1,1,4,1,2\">\r\n      <item>\r\n       <layout class=\"QVBoxLayout\" name=\"verticalLayout_7\">\r\n        <item>\r\n         <widget class=\"QPushButton\" name=\"load_btn\">\r\n          <property name=\"text\">\r\n           <string>Load Cube</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item>\r\n         <widget class=\"QPushButton\" name=\"pushButton_reset\">\r\n          <property name=\"styleSheet\">\r\n           <string notr=\"true\">color: rgba(255, 0, 0, 125);</string>\r\n          </property>\r\n          <property name=\"text\">\r\n           <string>Reset all</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n       </layout>\r\n      </item>\r\n      <item>\r\n       <widget class=\"Line\" name=\"line_4\">\r\n        <property name=\"orientation\">\r\n         <enum>Qt::Vertical</enum>\r\n        </property>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <widget class=\"QGroupBox\" name=\"groupBox_image_type\">\r\n        <property name=\"title\">\r\n         <string>Image Choice</string>\r\n        </property>\r\n        <layout class=\"QVBoxLayout\" name=\"verticalLayout_5\">\r\n         <item>\r\n          <widget class=\"QRadioButton\" name=\"radioButton_rgb_default\">\r\n           <property name=\"text\">\r\n            <string>RGB default</string>\r\n           </property>\r\n           <property name=\"checked\">\r\n            <bool>true</bool>\r\n           </property>\r\n          </widget>\r\n         </item>\r\n         <item>\r\n          <widget class=\"QRadioButton\" name=\"radioButton_rgb_user\">\r\n           <property name=\"enabled\">\r\n            <bool>true</bool>\r\n           </property>\r\n           <property name=\"text\">\r\n            <string>RGB user</string>\r\n           </property>\r\n           <property name=\"checked\">\r\n            <bool>false</bool>\r\n           </property>\r\n          </widget>\r\n         </item>\r\n         <item>\r\n          <widget class=\"QRadioButton\" name=\"radioButton_grayscale\">\r\n           <property name=\"text\">\r\n            <string>Grayscale</string>\r\n           </property>\r\n          </widget>\r\n         </item>\r\n        </layout>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <layout class=\"QGridLayout\" name=\"gridLayout_RGBchannels_3\">\r\n        <item row=\"1\" column=\"1\">\r\n         <widget class=\"QSpinBox\" name=\"spinBox_green_channel\">\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"1\">\r\n         <widget class=\"QSpinBox\" name=\"spinBox_blue_channel\">\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"1\">\r\n         <widget class=\"QSpinBox\" name=\"spinBox_red_channel\">\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"singleStep\">\r\n           <number>1</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"2\">\r\n         <widget class=\"QSlider\" name=\"horizontalSlider_blue_channel\">\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Horizontal</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"1\" column=\"0\">\r\n         <widget class=\"QLabel\" name=\"label_green_channel\">\r\n          <property name=\"text\">\r\n           <string>Green</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"0\">\r\n         <widget class=\"QLabel\" name=\"label_blue_channel\">\r\n          <property name=\"text\">\r\n           <string>Blue</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"0\">\r\n         <widget class=\"QLabel\" name=\"label_red_channel\">\r\n          <property name=\"text\">\r\n           <string>Red</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"1\" column=\"2\">\r\n         <widget class=\"QSlider\" name=\"horizontalSlider_green_channel\">\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Horizontal</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"2\">\r\n         <widget class=\"QSlider\" name=\"horizontalSlider_red_channel\">\r\n          <property name=\"minimumSize\">\r\n           <size>\r\n            <width>60</width>\r\n            <height>0</height>\r\n           </size>\r\n          </property>\r\n          <property name=\"maximum\">\r\n           <number>149</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Horizontal</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n       </layout>\r\n      </item>\r\n      <item>\r\n       <widget class=\"Line\" name=\"line\">\r\n        <property name=\"orientation\">\r\n         <enum>Qt::Vertical</enum>\r\n        </property>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <layout class=\"QGridLayout\" name=\"gridLayout\">\r\n        <item row=\"3\" column=\"7\" colspan=\"2\">\r\n         <widget class=\"QCheckBox\" name=\"checkBox_enable_segment\">\r\n          <property name=\"text\">\r\n           <string>Enable auto segmentation</string>\r\n          </property>\r\n          <property name=\"checked\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"6\" rowspan=\"4\">\r\n         <widget class=\"Line\" name=\"line_2\">\r\n          <property name=\"lineWidth\">\r\n           <number>1</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Vertical</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"4\">\r\n         <widget class=\"QLabel\" name=\"label_metric\">\r\n          <property name=\"text\">\r\n           <string>Spectral distance</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"7\">\r\n         <widget class=\"QPushButton\" name=\"pushButton_class_selection\">\r\n          <property name=\"enabled\">\r\n           <bool>true</bool>\r\n          </property>\r\n          <property name=\"styleSheet\">\r\n           <string notr=\"true\">background-color: rgba(186, 255, 112, 125);</string>\r\n          </property>\r\n          <property name=\"text\">\r\n           <string>Start selection</string>\r\n          </property>\r\n          <property name=\"checkable\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"3\" column=\"4\">\r\n         <widget class=\"QPushButton\" name=\"run_btn\">\r\n          <property name=\"styleSheet\">\r\n           <string notr=\"true\">background-color: rgb(173, 173, 173);</string>\r\n          </property>\r\n          <property name=\"text\">\r\n           <string>Segmentation</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"7\">\r\n         <widget class=\"QPushButton\" name=\"pushButton_erase_selected_pix\">\r\n          <property name=\"styleSheet\">\r\n           <string notr=\"true\">background-color: rgb(255, 206, 206);</string>\r\n          </property>\r\n          <property name=\"text\">\r\n           <string>Erase Selected</string>\r\n          </property>\r\n          <property name=\"checkable\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"2\" colspan=\"2\">\r\n         <widget class=\"QComboBox\" name=\"comboBox_ClassifMode\">\r\n          <item>\r\n           <property name=\"text\">\r\n            <string>Supervised</string>\r\n           </property>\r\n          </item>\r\n          <item>\r\n           <property name=\"text\">\r\n            <string>Unsupervised</string>\r\n           </property>\r\n          </item>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"2\" colspan=\"2\">\r\n         <widget class=\"QLabel\" name=\"label_class_type\">\r\n          <property name=\"text\">\r\n           <string>Classification type</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"8\">\r\n         <widget class=\"QLabel\" name=\"label_selec_mode\">\r\n          <property name=\"text\">\r\n           <string>Select mode</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"3\" column=\"2\">\r\n         <widget class=\"QLabel\" name=\"nclass_label\">\r\n          <property name=\"text\">\r\n           <string># Classes:</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"5\" rowspan=\"2\">\r\n         <widget class=\"QSlider\" name=\"slider_class_thr\">\r\n          <property name=\"minimum\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"maximum\">\r\n           <number>100</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>100</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Vertical</enum>\r\n          </property>\r\n          <property name=\"tickPosition\">\r\n           <enum>QSlider::NoTicks</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"4\">\r\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\r\n          <item>\r\n           <widget class=\"QStackedWidget\" name=\"stackedWidget\">\r\n            <property name=\"currentIndex\">\r\n             <number>0</number>\r\n            </property>\r\n            <widget class=\"QWidget\" name=\"page_distance\">\r\n             <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\r\n              <item>\r\n               <widget class=\"QComboBox\" name=\"comboBox_distance\">\r\n                <property name=\"sizePolicy\">\r\n                 <sizepolicy hsizetype=\"Expanding\" vsizetype=\"Fixed\">\r\n                  <horstretch>0</horstretch>\r\n                  <verstretch>0</verstretch>\r\n                 </sizepolicy>\r\n                </property>\r\n                <item>\r\n                 <property name=\"text\">\r\n                  <string>cosine</string>\r\n                 </property>\r\n                </item>\r\n                <item>\r\n                 <property name=\"text\">\r\n                  <string>sqeuclidean</string>\r\n                 </property>\r\n                </item>\r\n                <item>\r\n                 <property name=\"text\">\r\n                  <string>correlation</string>\r\n                 </property>\r\n                </item>\r\n               </widget>\r\n              </item>\r\n             </layout>\r\n            </widget>\r\n            <widget class=\"QWidget\" name=\"page_normalized\">\r\n             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\r\n              <item>\r\n               <widget class=\"QComboBox\" name=\"comboBox_normalized\">\r\n                <property name=\"sizePolicy\">\r\n                 <sizepolicy hsizetype=\"Expanding\" vsizetype=\"Fixed\">\r\n                  <horstretch>0</horstretch>\r\n                  <verstretch>0</verstretch>\r\n                 </sizepolicy>\r\n                </property>\r\n                <item>\r\n                 <property name=\"text\">\r\n                  <string>Raw</string>\r\n                 </property>\r\n                </item>\r\n                <item>\r\n                 <property name=\"text\">\r\n                  <string>Normalize</string>\r\n                 </property>\r\n                </item>\r\n               </widget>\r\n              </item>\r\n             </layout>\r\n            </widget>\r\n           </widget>\r\n          </item>\r\n         </layout>\r\n        </item>\r\n        <item row=\"2\" column=\"8\">\r\n         <widget class=\"QComboBox\" name=\"comboBox_pixel_selection_mode\">\r\n          <item>\r\n           <property name=\"text\">\r\n            <string>rectangle</string>\r\n           </property>\r\n          </item>\r\n          <item>\r\n           <property name=\"text\">\r\n            <string>ellipse</string>\r\n           </property>\r\n          </item>\r\n          <item>\r\n           <property name=\"text\">\r\n            <string>pixel</string>\r\n           </property>\r\n          </item>\r\n         </widget>\r\n        </item>\r\n        <item row=\"3\" column=\"3\">\r\n         <widget class=\"QSpinBox\" name=\"nclass_box\">\r\n          <property name=\"minimum\">\r\n           <number>2</number>\r\n          </property>\r\n          <property name=\"maximum\">\r\n           <number>20</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>3</number>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"0\" column=\"5\">\r\n         <widget class=\"QLabel\" name=\"label_thr\">\r\n          <property name=\"text\">\r\n           <string>thr</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n       </layout>\r\n      </item>\r\n      <item>\r\n       <widget class=\"QFrame\" name=\"frame_legend\">\r\n        <property name=\"frameShape\">\r\n         <enum>QFrame::StyledPanel</enum>\r\n        </property>\r\n        <property name=\"frameShadow\">\r\n         <enum>QFrame::Raised</enum>\r\n        </property>\r\n        <layout class=\"QVBoxLayout\" name=\"verticalLayout_6\"/>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <widget class=\"Line\" name=\"line_3\">\r\n        <property name=\"orientation\">\r\n         <enum>Qt::Vertical</enum>\r\n        </property>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <layout class=\"QGridLayout\" name=\"gridLayout_4\">\r\n        <item row=\"1\" column=\"3\">\r\n         <widget class=\"QSlider\" name=\"horizontalSlider_transparency_GT\">\r\n          <property name=\"minimumSize\">\r\n           <size>\r\n            <width>60</width>\r\n            <height>0</height>\r\n           </size>\r\n          </property>\r\n          <property name=\"maximum\">\r\n           <number>100</number>\r\n          </property>\r\n          <property name=\"value\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"sliderPosition\">\r\n           <number>0</number>\r\n          </property>\r\n          <property name=\"orientation\">\r\n           <enum>Qt::Horizontal</enum>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"1\" column=\"2\">\r\n         <widget class=\"QLabel\" name=\"label_GT_3\">\r\n          <property name=\"text\">\r\n           <string>GT transparency</string>\r\n          </property>\r\n          <property name=\"alignment\">\r\n           <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"2\">\r\n         <widget class=\"QCheckBox\" name=\"live_cb\">\r\n          <property name=\"text\">\r\n           <string>Spectra visualization</string>\r\n          </property>\r\n          <property name=\"checked\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"3\" column=\"2\">\r\n         <widget class=\"QCheckBox\" name=\"checkBox_seeGTspectra\">\r\n          <property name=\"text\">\r\n           <string>See GT spectra</string>\r\n          </property>\r\n          <property name=\"checked\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"2\" column=\"3\">\r\n         <widget class=\"QCheckBox\" name=\"checkBox_see_selection_overlay\">\r\n          <property name=\"text\">\r\n           <string>See selection</string>\r\n          </property>\r\n          <property name=\"checked\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item row=\"3\" column=\"3\">\r\n         <widget class=\"QPushButton\" name=\"pushButton_band_selection\">\r\n          <property name=\"text\">\r\n           <string>Band selection</string>\r\n          </property>\r\n          <property name=\"checkable\">\r\n           <bool>true</bool>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n       </layout>\r\n      </item>\r\n      <item>\r\n       <widget class=\"Line\" name=\"line_5\">\r\n        <property name=\"orientation\">\r\n         <enum>Qt::Vertical</enum>\r\n        </property>\r\n       </widget>\r\n      </item>\r\n      <item>\r\n       <layout class=\"QVBoxLayout\" name=\"verticalLayout_3\" stretch=\"0,0,0\">\r\n        <item>\r\n         <widget class=\"QPushButton\" name=\"pushButton_merge\">\r\n          <property name=\"text\">\r\n           <string>Merge GT and select</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item>\r\n         <widget class=\"QPushButton\" name=\"pushButton_class_name_assign\">\r\n          <property name=\"text\">\r\n           <string>Class name assign</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n        <item>\r\n         <widget class=\"QPushButton\" name=\"pushButton_keep_GT\">\r\n          <property name=\"text\">\r\n           <string>Save GT map</string>\r\n          </property>\r\n         </widget>\r\n        </item>\r\n       </layout>\r\n      </item>\r\n     </layout>\r\n    </widget>\r\n   </item>\r\n   <item>\r\n    <widget class=\"QFrame\" name=\"frame_2\">\r\n     <property name=\"frameShape\">\r\n      <enum>QFrame::NoFrame</enum>\r\n     </property>\r\n     <property name=\"frameShadow\">\r\n      <enum>QFrame::Plain</enum>\r\n     </property>\r\n     <property name=\"lineWidth\">\r\n      <number>0</number>\r\n     </property>\r\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\r\n      <item>\r\n       <widget class=\"QSplitter\" name=\"splitter\">\r\n        <property name=\"styleSheet\">\r\n         <string notr=\"true\">border-color: rgb(100, 100, 100);</string>\r\n        </property>\r\n        <property name=\"frameShape\">\r\n         <enum>QFrame::NoFrame</enum>\r\n        </property>\r\n        <property name=\"frameShadow\">\r\n         <enum>QFrame::Raised</enum>\r\n        </property>\r\n        <property name=\"lineWidth\">\r\n         <number>2</number>\r\n        </property>\r\n        <property name=\"midLineWidth\">\r\n         <number>2</number>\r\n        </property>\r\n        <property name=\"orientation\">\r\n         <enum>Qt::Horizontal</enum>\r\n        </property>\r\n        <widget class=\"QFrame\" name=\"verticalFrame\">\r\n         <layout class=\"QVBoxLayout\" name=\"verticalLayout_2\">\r\n          <item>\r\n           <widget class=\"QSplitter\" name=\"splitter_2\">\r\n            <property name=\"orientation\">\r\n             <enum>Qt::Vertical</enum>\r\n            </property>\r\n            <widget class=\"QWidget\" name=\"viewer_left\" native=\"true\">\r\n             <property name=\"toolTip\">\r\n              <string>Promote to ZoomableGraphicsView</string>\r\n             </property>\r\n            </widget>\r\n            <widget class=\"QWidget\" name=\"viewer_right\" native=\"true\">\r\n             <property name=\"toolTip\">\r\n              <string>Promote to ZoomableGraphicsView</string>\r\n             </property>\r\n            </widget>\r\n           </widget>\r\n          </item>\r\n         </layout>\r\n        </widget>\r\n        <widget class=\"QWidget\" name=\"spec_canvas\" native=\"true\">\r\n         <property name=\"toolTip\">\r\n          <string>Promote to FigureCanvas</string>\r\n         </property>\r\n         <property name=\"autoFillBackground\">\r\n          <bool>false</bool>\r\n         </property>\r\n        </widget>\r\n       </widget>\r\n      </item>\r\n     </layout>\r\n    </widget>\r\n   </item>\r\n  </layout>\r\n </widget>\r\n <resources/>\r\n <connections/>\r\n</ui>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ground_truth/ground_truth_window.ui b/ground_truth/ground_truth_window.ui
--- a/ground_truth/ground_truth_window.ui	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/ground_truth/ground_truth_window.ui	(date 1752488320230)
@@ -6,7 +6,7 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>1327</width>
+    <width>1155</width>
     <height>609</height>
    </rect>
   </property>
@@ -31,7 +31,7 @@
      <property name="frameShadow">
       <enum>QFrame::Raised</enum>
      </property>
-     <layout class="QHBoxLayout" name="horizontalLayout_2" stretch="0,1,1,2,1,0,1,1,4,1,2">
+     <layout class="QHBoxLayout" name="horizontalLayout_2" stretch="1,4,1,0,0,1,1">
       <item>
        <layout class="QVBoxLayout" name="verticalLayout_7">
         <item>
@@ -54,499 +54,525 @@
        </layout>
       </item>
       <item>
-       <widget class="Line" name="line_4">
-        <property name="orientation">
-         <enum>Qt::Vertical</enum>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QGroupBox" name="groupBox_image_type">
-        <property name="title">
-         <string>Image Choice</string>
-        </property>
-        <layout class="QVBoxLayout" name="verticalLayout_5">
-         <item>
-          <widget class="QRadioButton" name="radioButton_rgb_default">
-           <property name="text">
-            <string>RGB default</string>
-           </property>
-           <property name="checked">
-            <bool>true</bool>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QRadioButton" name="radioButton_rgb_user">
-           <property name="enabled">
-            <bool>true</bool>
-           </property>
-           <property name="text">
-            <string>RGB user</string>
-           </property>
-           <property name="checked">
-            <bool>false</bool>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QRadioButton" name="radioButton_grayscale">
-           <property name="text">
-            <string>Grayscale</string>
-           </property>
-          </widget>
-         </item>
-        </layout>
-       </widget>
-      </item>
-      <item>
-       <layout class="QGridLayout" name="gridLayout_RGBchannels_3">
-        <item row="1" column="1">
-         <widget class="QSpinBox" name="spinBox_green_channel">
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="1">
-         <widget class="QSpinBox" name="spinBox_blue_channel">
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="1">
-         <widget class="QSpinBox" name="spinBox_red_channel">
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="singleStep">
-           <number>1</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="2">
-         <widget class="QSlider" name="horizontalSlider_blue_channel">
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </widget>
-        </item>
-        <item row="1" column="0">
-         <widget class="QLabel" name="label_green_channel">
-          <property name="text">
-           <string>Green</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="0">
-         <widget class="QLabel" name="label_blue_channel">
-          <property name="text">
-           <string>Blue</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="0">
-         <widget class="QLabel" name="label_red_channel">
-          <property name="text">
-           <string>Red</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="1" column="2">
-         <widget class="QSlider" name="horizontalSlider_green_channel">
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="2">
-         <widget class="QSlider" name="horizontalSlider_red_channel">
-          <property name="minimumSize">
-           <size>
-            <width>60</width>
-            <height>0</height>
-           </size>
-          </property>
-          <property name="maximum">
-           <number>149</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </item>
-      <item>
-       <widget class="Line" name="line">
-        <property name="orientation">
-         <enum>Qt::Vertical</enum>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <layout class="QGridLayout" name="gridLayout">
-        <item row="3" column="7" colspan="2">
-         <widget class="QCheckBox" name="checkBox_enable_segment">
-          <property name="text">
-           <string>Enable auto segmentation</string>
-          </property>
-          <property name="checked">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="6" rowspan="4">
-         <widget class="Line" name="line_2">
-          <property name="lineWidth">
-           <number>1</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Vertical</enum>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="4">
-         <widget class="QLabel" name="label_metric">
-          <property name="text">
-           <string>Spectral distance</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="7">
-         <widget class="QPushButton" name="pushButton_class_selection">
-          <property name="enabled">
-           <bool>true</bool>
-          </property>
-          <property name="styleSheet">
-           <string notr="true">background-color: rgba(186, 255, 112, 125);</string>
-          </property>
-          <property name="text">
-           <string>Start selection</string>
-          </property>
-          <property name="checkable">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="3" column="4">
-         <widget class="QPushButton" name="run_btn">
-          <property name="styleSheet">
-           <string notr="true">background-color: rgb(173, 173, 173);</string>
-          </property>
-          <property name="text">
-           <string>Segmentation</string>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="7">
-         <widget class="QPushButton" name="pushButton_erase_selected_pix">
-          <property name="styleSheet">
-           <string notr="true">background-color: rgb(255, 206, 206);</string>
-          </property>
-          <property name="text">
-           <string>Erase Selected</string>
-          </property>
-          <property name="checkable">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="2" colspan="2">
-         <widget class="QComboBox" name="comboBox_ClassifMode">
-          <item>
-           <property name="text">
-            <string>Supervised</string>
-           </property>
-          </item>
-          <item>
-           <property name="text">
-            <string>Unsupervised</string>
-           </property>
-          </item>
-         </widget>
-        </item>
-        <item row="0" column="2" colspan="2">
-         <widget class="QLabel" name="label_class_type">
-          <property name="text">
-           <string>Classification type</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="8">
-         <widget class="QLabel" name="label_selec_mode">
-          <property name="text">
-           <string>Select mode</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="3" column="2">
-         <widget class="QLabel" name="nclass_label">
-          <property name="text">
-           <string># Classes:</string>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="5" rowspan="2">
-         <widget class="QSlider" name="slider_class_thr">
-          <property name="minimum">
-           <number>0</number>
-          </property>
-          <property name="maximum">
-           <number>100</number>
-          </property>
-          <property name="value">
-           <number>100</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Vertical</enum>
-          </property>
-          <property name="tickPosition">
-           <enum>QSlider::NoTicks</enum>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="4">
-         <layout class="QVBoxLayout" name="verticalLayout_4">
+       <widget class="QTabWidget" name="tabWidget">
+        <property name="tabPosition">
+         <enum>QTabWidget::West</enum>
+        </property>
+        <property name="tabShape">
+         <enum>QTabWidget::Rounded</enum>
+        </property>
+        <property name="currentIndex">
+         <number>0</number>
+        </property>
+        <widget class="QWidget" name="tab_2_Segmentation">
+         <attribute name="title">
+          <string>Segment</string>
+         </attribute>
+         <layout class="QHBoxLayout" name="horizontalLayout_6">
+          <item>
+           <layout class="QGridLayout" name="gridLayout">
+            <item row="0" column="6" rowspan="4">
+             <widget class="Line" name="line_2">
+              <property name="lineWidth">
+               <number>1</number>
+              </property>
+              <property name="orientation">
+               <enum>Qt::Vertical</enum>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="5" rowspan="2">
+             <widget class="QSlider" name="slider_class_thr">
+              <property name="minimum">
+               <number>0</number>
+              </property>
+              <property name="maximum">
+               <number>100</number>
+              </property>
+              <property name="value">
+               <number>100</number>
+              </property>
+              <property name="orientation">
+               <enum>Qt::Vertical</enum>
+              </property>
+              <property name="tickPosition">
+               <enum>QSlider::NoTicks</enum>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="2" colspan="2">
+             <widget class="QComboBox" name="comboBox_ClassifMode">
+              <item>
+               <property name="text">
+                <string>Supervised</string>
+               </property>
+              </item>
+              <item>
+               <property name="text">
+                <string>Unsupervised</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+            <item row="0" column="2" colspan="2">
+             <widget class="QLabel" name="label_class_type">
+              <property name="text">
+               <string>Classification type</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="3" column="2">
+             <widget class="QLabel" name="nclass_label">
+              <property name="text">
+               <string># Classes:</string>
+              </property>
+             </widget>
+            </item>
+            <item row="3" column="3">
+             <widget class="QSpinBox" name="nclass_box">
+              <property name="minimum">
+               <number>2</number>
+              </property>
+              <property name="maximum">
+               <number>20</number>
+              </property>
+              <property name="value">
+               <number>3</number>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="4">
+             <layout class="QVBoxLayout" name="verticalLayout_4">
+              <item>
+               <widget class="QStackedWidget" name="stackedWidget">
+                <property name="currentIndex">
+                 <number>0</number>
+                </property>
+                <widget class="QWidget" name="page_distance">
+                 <layout class="QHBoxLayout" name="horizontalLayout">
+                  <item>
+                   <widget class="QComboBox" name="comboBox_distance">
+                    <property name="sizePolicy">
+                     <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+                      <horstretch>0</horstretch>
+                      <verstretch>0</verstretch>
+                     </sizepolicy>
+                    </property>
+                    <item>
+                     <property name="text">
+                      <string>cosine</string>
+                     </property>
+                    </item>
+                    <item>
+                     <property name="text">
+                      <string>sqeuclidean</string>
+                     </property>
+                    </item>
+                    <item>
+                     <property name="text">
+                      <string>correlation</string>
+                     </property>
+                    </item>
+                   </widget>
+                  </item>
+                 </layout>
+                </widget>
+                <widget class="QWidget" name="page_normalized">
+                 <layout class="QHBoxLayout" name="horizontalLayout_3">
+                  <item>
+                   <widget class="QComboBox" name="comboBox_normalized">
+                    <property name="sizePolicy">
+                     <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+                      <horstretch>0</horstretch>
+                      <verstretch>0</verstretch>
+                     </sizepolicy>
+                    </property>
+                    <item>
+                     <property name="text">
+                      <string>Raw</string>
+                     </property>
+                    </item>
+                    <item>
+                     <property name="text">
+                      <string>Normalize</string>
+                     </property>
+                    </item>
+                   </widget>
+                  </item>
+                 </layout>
+                </widget>
+               </widget>
+              </item>
+             </layout>
+            </item>
+            <item row="0" column="4">
+             <widget class="QLabel" name="label_metric">
+              <property name="text">
+               <string>Spectral distance</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="3" column="4">
+             <widget class="QPushButton" name="run_btn">
+              <property name="styleSheet">
+               <string notr="true">background-color: rgb(173, 173, 173);</string>
+              </property>
+              <property name="text">
+               <string>Segmentation</string>
+              </property>
+             </widget>
+            </item>
+            <item row="3" column="7" colspan="2">
+             <widget class="QCheckBox" name="checkBox_enable_segment">
+              <property name="text">
+               <string>Enable auto segmentation</string>
+              </property>
+              <property name="checked">
+               <bool>true</bool>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="5">
+             <widget class="QLabel" name="label_thr">
+              <property name="text">
+               <string>thr</string>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="7">
+             <widget class="QPushButton" name="pushButton_class_selection">
+              <property name="enabled">
+               <bool>true</bool>
+              </property>
+              <property name="styleSheet">
+               <string notr="true">background-color: rgba(186, 255, 112, 125);</string>
+              </property>
+              <property name="text">
+               <string>Start selection</string>
+              </property>
+              <property name="checkable">
+               <bool>true</bool>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="7">
+             <widget class="QPushButton" name="pushButton_erase_selected_pix">
+              <property name="styleSheet">
+               <string notr="true">background-color: rgb(255, 206, 206);</string>
+              </property>
+              <property name="text">
+               <string>Erase Selected</string>
+              </property>
+              <property name="checkable">
+               <bool>true</bool>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="8">
+             <widget class="QComboBox" name="comboBox_pixel_selection_mode">
+              <item>
+               <property name="text">
+                <string>rectangle</string>
+               </property>
+              </item>
+              <item>
+               <property name="text">
+                <string>ellipse</string>
+               </property>
+              </item>
+              <item>
+               <property name="text">
+                <string>pixel</string>
+               </property>
+              </item>
+             </widget>
+            </item>
+            <item row="0" column="8">
+             <widget class="QLabel" name="label_selec_mode">
+              <property name="text">
+               <string>Select mode</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+        <widget class="QWidget" name="tab_image_choice">
+         <attribute name="title">
+          <string>Cube</string>
+         </attribute>
+         <layout class="QHBoxLayout" name="horizontalLayout_5">
           <item>
-           <widget class="QStackedWidget" name="stackedWidget">
-            <property name="currentIndex">
-             <number>0</number>
+           <widget class="QGroupBox" name="groupBox_image_type">
+            <property name="title">
+             <string>Image Choice</string>
             </property>
-            <widget class="QWidget" name="page_distance">
-             <layout class="QHBoxLayout" name="horizontalLayout">
-              <item>
-               <widget class="QComboBox" name="comboBox_distance">
-                <property name="sizePolicy">
-                 <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
-                <item>
-                 <property name="text">
-                  <string>cosine</string>
-                 </property>
-                </item>
-                <item>
-                 <property name="text">
-                  <string>sqeuclidean</string>
-                 </property>
-                </item>
-                <item>
-                 <property name="text">
-                  <string>correlation</string>
-                 </property>
-                </item>
-               </widget>
-              </item>
-             </layout>
-            </widget>
-            <widget class="QWidget" name="page_normalized">
-             <layout class="QHBoxLayout" name="horizontalLayout_3">
-              <item>
-               <widget class="QComboBox" name="comboBox_normalized">
-                <property name="sizePolicy">
-                 <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
-                <item>
-                 <property name="text">
-                  <string>Raw</string>
-                 </property>
-                </item>
-                <item>
-                 <property name="text">
-                  <string>Normalize</string>
-                 </property>
-                </item>
-               </widget>
-              </item>
-             </layout>
-            </widget>
+            <layout class="QGridLayout" name="gridLayout_2">
+             <item row="1" column="0">
+              <widget class="QRadioButton" name="radioButton_rgb_user">
+               <property name="enabled">
+                <bool>true</bool>
+               </property>
+               <property name="text">
+                <string>RGB user</string>
+               </property>
+               <property name="checked">
+                <bool>false</bool>
+               </property>
+              </widget>
+             </item>
+             <item row="2" column="0">
+              <widget class="QRadioButton" name="radioButton_grayscale">
+               <property name="text">
+                <string>Grayscale</string>
+               </property>
+              </widget>
+             </item>
+             <item row="0" column="0">
+              <widget class="QRadioButton" name="radioButton_rgb_default">
+               <property name="text">
+                <string>RGB default</string>
+               </property>
+               <property name="checked">
+                <bool>true</bool>
+               </property>
+              </widget>
+             </item>
+            </layout>
            </widget>
           </item>
-         </layout>
-        </item>
-        <item row="2" column="8">
-         <widget class="QComboBox" name="comboBox_pixel_selection_mode">
           <item>
-           <property name="text">
-            <string>rectangle</string>
-           </property>
-          </item>
-          <item>
-           <property name="text">
-            <string>ellipse</string>
-           </property>
-          </item>
-          <item>
-           <property name="text">
-            <string>pixel</string>
-           </property>
-          </item>
-         </widget>
-        </item>
-        <item row="3" column="3">
-         <widget class="QSpinBox" name="nclass_box">
-          <property name="minimum">
-           <number>2</number>
-          </property>
-          <property name="maximum">
-           <number>20</number>
-          </property>
-          <property name="value">
-           <number>3</number>
-          </property>
-         </widget>
-        </item>
-        <item row="0" column="5">
-         <widget class="QLabel" name="label_thr">
-          <property name="text">
-           <string>thr</string>
-          </property>
-         </widget>
-        </item>
-       </layout>
-      </item>
-      <item>
-       <widget class="QFrame" name="frame_legend">
-        <property name="frameShape">
-         <enum>QFrame::StyledPanel</enum>
-        </property>
-        <property name="frameShadow">
-         <enum>QFrame::Raised</enum>
-        </property>
-        <layout class="QVBoxLayout" name="verticalLayout_6"/>
-       </widget>
-      </item>
-      <item>
-       <widget class="Line" name="line_3">
-        <property name="orientation">
-         <enum>Qt::Vertical</enum>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <layout class="QGridLayout" name="gridLayout_4">
-        <item row="1" column="3">
-         <widget class="QSlider" name="horizontalSlider_transparency_GT">
-          <property name="minimumSize">
-           <size>
-            <width>60</width>
-            <height>0</height>
-           </size>
-          </property>
-          <property name="maximum">
-           <number>100</number>
-          </property>
-          <property name="value">
-           <number>0</number>
-          </property>
-          <property name="sliderPosition">
-           <number>0</number>
-          </property>
-          <property name="orientation">
-           <enum>Qt::Horizontal</enum>
-          </property>
-         </widget>
-        </item>
-        <item row="1" column="2">
-         <widget class="QLabel" name="label_GT_3">
-          <property name="text">
-           <string>GT transparency</string>
-          </property>
-          <property name="alignment">
-           <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="2">
-         <widget class="QCheckBox" name="live_cb">
-          <property name="text">
-           <string>Spectra visualization</string>
-          </property>
-          <property name="checked">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="3" column="2">
-         <widget class="QCheckBox" name="checkBox_seeGTspectra">
-          <property name="text">
-           <string>See GT spectra</string>
-          </property>
-          <property name="checked">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="2" column="3">
-         <widget class="QCheckBox" name="checkBox_see_selection_overlay">
-          <property name="text">
-           <string>See selection</string>
-          </property>
-          <property name="checked">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-        <item row="3" column="3">
-         <widget class="QPushButton" name="pushButton_band_selection">
-          <property name="text">
-           <string>Band selection</string>
-          </property>
-          <property name="checkable">
-           <bool>true</bool>
-          </property>
-         </widget>
-        </item>
-       </layout>
+           <layout class="QGridLayout" name="gridLayout_RGBchannels_3">
+            <item row="1" column="1">
+             <widget class="QSpinBox" name="spinBox_green_channel">
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="1">
+             <widget class="QSpinBox" name="spinBox_blue_channel">
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="1">
+             <widget class="QSpinBox" name="spinBox_red_channel">
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="singleStep">
+               <number>1</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="2">
+             <widget class="QSlider" name="horizontalSlider_blue_channel">
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+              <property name="orientation">
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="0">
+             <widget class="QLabel" name="label_green_channel">
+              <property name="text">
+               <string>Green</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="0">
+             <widget class="QLabel" name="label_blue_channel">
+              <property name="text">
+               <string>Blue</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="0">
+             <widget class="QLabel" name="label_red_channel">
+              <property name="text">
+               <string>Red</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="2">
+             <widget class="QSlider" name="horizontalSlider_green_channel">
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+              <property name="orientation">
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="2">
+             <widget class="QSlider" name="horizontalSlider_red_channel">
+              <property name="minimumSize">
+               <size>
+                <width>60</width>
+                <height>0</height>
+               </size>
+              </property>
+              <property name="maximum">
+               <number>149</number>
+              </property>
+              <property name="value">
+               <number>0</number>
+              </property>
+              <property name="orientation">
+               <enum>Qt::Horizontal</enum>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </item>
+         </layout>
+        </widget>
+       </widget>
+      </item>
+      <item>
+       <widget class="QFrame" name="frame_legend">
+        <property name="frameShape">
+         <enum>QFrame::StyledPanel</enum>
+        </property>
+        <property name="frameShadow">
+         <enum>QFrame::Raised</enum>
+        </property>
+        <layout class="QVBoxLayout" name="verticalLayout_6"/>
+       </widget>
+      </item>
+      <item>
+       <widget class="QGroupBox" name="groupBox">
+        <property name="title">
+         <string>Spectra</string>
+        </property>
+        <layout class="QVBoxLayout" name="verticalLayout_8">
+         <item>
+          <widget class="QCheckBox" name="checkBox_live_spectra">
+           <property name="text">
+            <string>Live spectra</string>
+           </property>
+           <property name="checked">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="checkBox_seeGTspectra">
+           <property name="text">
+            <string>See GT spectra</string>
+           </property>
+           <property name="checked">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="pushButton_band_selection">
+           <property name="text">
+            <string>Band selection</string>
+           </property>
+           <property name="checkable">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </widget>
+      </item>
+      <item>
+       <widget class="QGroupBox" name="groupBox_2">
+        <property name="title">
+         <string>Overlay on Cube Image</string>
+        </property>
+        <layout class="QVBoxLayout" name="verticalLayout_9" stretch="0,0,0">
+         <item>
+          <widget class="QLabel" name="label_GT_overlay">
+           <property name="maximumSize">
+            <size>
+             <width>16777215</width>
+             <height>20</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>GT transparency</string>
+           </property>
+           <property name="alignment">
+            <set>Qt::AlignCenter</set>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QSlider" name="horizontalSlider_transparency_GT">
+           <property name="minimumSize">
+            <size>
+             <width>60</width>
+             <height>0</height>
+            </size>
+           </property>
+           <property name="maximum">
+            <number>100</number>
+           </property>
+           <property name="value">
+            <number>0</number>
+           </property>
+           <property name="sliderPosition">
+            <number>0</number>
+           </property>
+           <property name="orientation">
+            <enum>Qt::Horizontal</enum>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="checkBox_see_selection_overlay">
+           <property name="text">
+            <string>See manual selection</string>
+           </property>
+           <property name="checked">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </widget>
       </item>
       <item>
        <widget class="Line" name="line_5">
@@ -572,7 +598,7 @@
          </widget>
         </item>
         <item>
-         <widget class="QPushButton" name="pushButton_keep_GT">
+         <widget class="QPushButton" name="pushButton_save_GT">
           <property name="text">
            <string>Save GT map</string>
           </property>
@@ -637,6 +663,12 @@
          </layout>
         </widget>
         <widget class="QWidget" name="spec_canvas" native="true">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
          <property name="toolTip">
           <string>Promote to FigureCanvas</string>
          </property>
Index: .idea/Hypertool.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module version=\"4\">\r\n  <component name=\"PyDocumentationSettings\">\r\n    <option name=\"format\" value=\"PLAIN\" />\r\n    <option name=\"myDocStringFormat\" value=\"Plain\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Hypertool.iml b/.idea/Hypertool.iml
--- a/.idea/Hypertool.iml	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/.idea/Hypertool.iml	(date 1752477803567)
@@ -4,4 +4,7 @@
     <option name="format" value="PLAIN" />
     <option name="myDocStringFormat" value="Plain" />
   </component>
+  <component name="TestRunnerService">
+    <option name="PROJECT_TEST_RUNNER" value="py.test" />
+  </component>
 </module>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"d582d865-26c1-4224-a66c-1fa3811218c4\" name=\"Changes\" comment=\"Lot of things but most of all matlab.engine\">\r\n      <change afterPath=\"$PROJECT_DIR$/hypercubes/matlab_engine_control.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/hypercubes/matlab_subprocess.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Hypertool.xmind\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/MainWindow.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/MainWindow.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/MainWindow.spec\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/MainWindow.spec\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/data_vizualisation/data_vizualisation_tool.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/data_vizualisation/data_vizualisation_tool.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/get_requirement.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/ground_truth/ground_truth_tool.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/ground_truth/ground_truth_tool.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/hypercubes/hypercube.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/hypercubes/hypercube.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/hypercubes/matlab_engine_search.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/hypercubes/matlab_env_path.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/hypercubes/matlab_loader.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/install_requirements.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/install_requirements.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/log/error.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/log/error.log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/metadata/metadata_tool.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/metadata/metadata_tool.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/registration/register_tool.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/registration/register_tool.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test.py\" beforeDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Merge.Settings\">\r\n    <option name=\"BRANCH\" value=\"Registration\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <excluded-from-favorite>\r\n      <branch-storage>\r\n        <map>\r\n          <entry type=\"LOCAL\">\r\n            <value>\r\n              <list>\r\n                <branch-info repo=\"$PROJECT_DIR$\" source=\"main\" />\r\n              </list>\r\n            </value>\r\n          </entry>\r\n        </map>\r\n      </branch-storage>\r\n    </excluded-from-favorite>\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"main\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Llanik&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/Llanik/Hypertool.git&quot;,\r\n    &quot;accountId&quot;: &quot;95914ee3-b677-444b-a964-a8ed5b3dc5fa&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 4\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2vOfG8M05x0ynYq0zGaG55is8F1\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.HyperdocApp_core_v3.5.1.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.HyperdocApp_main_.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Hyperdoc_GUI_design.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Run in console.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Test_update.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Unnamed.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.hypercube_app_v26.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.open.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.register_images.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;feature/ground__truth__tool&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/Usuario/Documents/GitHub/Hypertool&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.keymap&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\hypercubes\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\registration\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\hypercubes\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\data_vizualisation\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\metadata\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\registration\" />\r\n      <recent name=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"Run in console\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"Hypertool\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"SDK_NAME\" value=\"Python 3.12\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$FilePath$\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-a5bc9544c897-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.23654.177\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"d582d865-26c1-4224-a66c-1fa3811218c4\" name=\"Changes\" comment=\"\" />\r\n      <created>1744020944801</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1744020944801</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"Load in VizTool OK\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746610626729</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746610626729</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"Dockable window started.&#10;First test OK but widget not connected\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746628584567</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746628584567</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"Dockable window started.&#10;toolbar ok\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746724499042</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746724499042</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"Registration saving OK&#10;look metadata size problem with .h5\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746783057446</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746783057446</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\"Save H5% en new dataset OK\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747045822102</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747045822102</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\"Manager with filepath OK&#10;Get path of Registered cube in Main OK&#10;send to Register and File Browser OK\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747145526456</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747145526456</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00021\" summary=\"Added size column in FileBrowser\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747146781655</created>\r\n      <option name=\"number\" value=\"00021\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747146781655</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00022\" summary=\"Gestion par CubeInfoTemp des infos des cubes pseudo chargés\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747225537795</created>\r\n      <option name=\"number\" value=\"00022\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747225537795</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00023\" summary=\"Gestion par CubeInfoTemp des infos des cubes pseudo chargés - extension au MainWindow\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747228825039</created>\r\n      <option name=\"number\" value=\"00023\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747228825039</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00024\" summary=\"Outils Metadata OK en lecture.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747241902458</created>\r\n      <option name=\"number\" value=\"00024\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747241902458</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00025\" summary=\"On avance sur le metada. OK pour alidation str et numpy 1D\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747320353703</created>\r\n      <option name=\"number\" value=\"00025\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747320353703</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00026\" summary=\"le register_tool envoie un cube_info dans le signal\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747664241381</created>\r\n      <option name=\"number\" value=\"00026\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747664241381</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00027\" summary=\"metadata not editable from metadata tool blocked\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747665666661</created>\r\n      <option name=\"number\" value=\"00027\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747665666661</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00028\" summary=\"Ground truth tool : ok for rgb visualisation + live spectrum\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1747924637084</created>\r\n      <option name=\"number\" value=\"00028\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1747924637084</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00029\" summary=\"Added GT spectrum to live spectrum + std deviation.&#10;Resolve conflict between pixel selction and draggable.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748011389316</created>\r\n      <option name=\"number\" value=\"00029\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748011389316</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00030\" summary=\"OK for selection rectangle and pixel of different color, multiple distance.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748275387089</created>\r\n      <option name=\"number\" value=\"00030\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00030\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748275387089</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00031\" summary=\"selection with pixel drag OK (with inside path in option)\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748351774202</created>\r\n      <option name=\"number\" value=\"00031\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00031\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748351774202</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00032\" summary=\"Erase Mode OK .. .BUT .. no se vee la selction anterior en pixel mode when drag\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748356760842</created>\r\n      <option name=\"number\" value=\"00032\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748356760842</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00033\" summary=\"Erase all right&#10;correction of overlays supperposition in drag mode\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748430071616</created>\r\n      <option name=\"number\" value=\"00033\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00033\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748430071616</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00034\" summary=\"Overlay transparency separate for for selection and GT&#10;GT and hyp image in QSplitter&#10;Supervised mode with thr\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748438511282</created>\r\n      <option name=\"number\" value=\"00034\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00034\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748438511282</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00035\" summary=\"doublons de selection gerer\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748439385139</created>\r\n      <option name=\"number\" value=\"00035\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00035\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748439385139</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00036\" summary=\"Merging GT and manual added&#10;add legend of color class when selecting\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748488219203</created>\r\n      <option name=\"number\" value=\"00036\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00036\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748488219203</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00037\" summary=\"QSplitter OK&#10;Loading cube with reste state OK\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748517410329</created>\r\n      <option name=\"number\" value=\"00037\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00037\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748517410329</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00038\" summary=\"GT_table_viz works now very nice. To be inserted in GT tool.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748618417812</created>\r\n      <option name=\"number\" value=\"00038\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00038\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748618417812</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00039\" summary=\"Supression of .ui previous try of class assignment\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748618728900</created>\r\n      <option name=\"number\" value=\"00039\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00039\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748618728900</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00040\" summary=\"Connection table and GT tools. &#10;right click interaction added on table.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748866354558</created>\r\n      <option name=\"number\" value=\"00040\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00040\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748866354558</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00041\" summary=\"handle of classe suppresion ok\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748866959279</created>\r\n      <option name=\"number\" value=\"00041\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00041\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748866959279</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00042\" summary=\"Add, suppres and reset bands working (on the graph)\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748944467930</created>\r\n      <option name=\"number\" value=\"00042\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00042\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748944467930</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00043\" summary=\"Added normalizarion for Unsupervised\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1748964150591</created>\r\n      <option name=\"number\" value=\"00043\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00043\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1748964150591</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00044\" summary=\"pixel_averaged added + saving GT started\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1749819042738</created>\r\n      <option name=\"number\" value=\"00044\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00044\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1749819042738</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00045\" summary=\"Bugg of metadata loading finally fixed :-p\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750075741719</created>\r\n      <option name=\"number\" value=\"00045\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00045\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750075741719</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00046\" summary=\"Loading GT_tool with cubeInfo&#10;GT tool inserted in main\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750081807480</created>\r\n      <option name=\"number\" value=\"00046\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00046\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750081807480</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00047\" summary=\"Back to main organisation&#10;Ground Truth tool operationnel\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750774362538</created>\r\n      <option name=\"number\" value=\"00047\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00047\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750774362538</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00048\" summary=\"added\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750774382912</created>\r\n      <option name=\"number\" value=\"00048\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00048\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750774382912</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00049\" summary=\"added\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750778641386</created>\r\n      <option name=\"number\" value=\"00049\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00049\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750778641386</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00050\" summary=\"fixed bugg meta wl with register cube&#10;fixed rgb save bugg register\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1750844767242</created>\r\n      <option name=\"number\" value=\"00050\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00050\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1750844767242</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00051\" summary=\"plein de trucs :-p\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751039617101</created>\r\n      <option name=\"number\" value=\"00051\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00051\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751039617101</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00052\" summary=\"ouverture des cubes dans data_viz elargie en format, ajout de la hash_up table pour association de cube, depandance UV differentes\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751284917961</created>\r\n      <option name=\"number\" value=\"00052\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00052\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751284917961</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00053\" summary=\"ouverture des cubes dans data_viz elargie en format, ajout de la hash_up table pour association de cube, depandance UV differentes\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751372677413</created>\r\n      <option name=\"number\" value=\"00053\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00053\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751372677413</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00054\" summary=\"ouverture des cubes dans data_viz elargie en format, ajout de la hash_up table pour association de cube, depandance UV differentes\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751372738567</created>\r\n      <option name=\"number\" value=\"00054\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00054\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751372738567</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00055\" summary=\"syncronize Drag and scroll for images and GT&#10;Open non h5&#10;live spectrum initiate if no GT\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751572928997</created>\r\n      <option name=\"number\" value=\"00055\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00055\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751572928997</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00056\" summary=\"Main added all tools and open cube with dialog\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751621833902</created>\r\n      <option name=\"number\" value=\"00056\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00056\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751621833902</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00057\" summary=\"Metadata tool with generate meta first step.&#10;Much robust for lokking at changes keep save etc...\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751732511279</created>\r\n      <option name=\"number\" value=\"00057\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00057\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751732511281</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00058\" summary=\"Metadata tool copy from other cube et add/remove metadatum\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751836389143</created>\r\n      <option name=\"number\" value=\"00058\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00058\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751836389143</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00059\" summary=\"[Metadata] copy from other cube -&gt; type keep for non editable like numpy&#10;open cube possibility&#10;[Registration] all metadata seems OK. Gestion des croped parent etc....\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751917857950</created>\r\n      <option name=\"number\" value=\"00059\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00059\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751917857950</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00060\" summary=\"Cube info loading and saving are syncronized with all tools (except visualize)&#10;[registration] manual features supression\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751934056860</created>\r\n      <option name=\"number\" value=\"00060\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00060\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751934056862</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00061\" summary=\"[main] correction of suggestions suprresion\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1751935369122</created>\r\n      <option name=\"number\" value=\"00061\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00061\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1751935369122</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00062\" summary=\"[main] open all bugg fixed&#10;[register] modif features, sliders bugg and labels and groups, click to select, auto load other, progress bar reset all, cubeinfo unique and parent cube editable at save.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1752005647626</created>\r\n      <option name=\"number\" value=\"00062\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00062\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1752005647626</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00063\" summary=\"Lot of things but most of all matlab.engine\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1752109688328</created>\r\n      <option name=\"number\" value=\"00063\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00063\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1752109688330</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"64\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"OPEN_GENERIC_TABS\">\r\n      <map>\r\n        <entry key=\"7f1e1158-91c7-4541-9680-4cc89c9a3c6a\" value=\"TOOL_WINDOW\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_FILTERS\">\r\n      <map>\r\n        <entry key=\"Branch\">\r\n          <value>\r\n            <list>\r\n              <RecentGroup>\r\n                <option name=\"FILTER_VALUES\">\r\n                  <option value=\"main\" />\r\n                </option>\r\n              </RecentGroup>\r\n            </list>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"7f1e1158-91c7-4541-9680-4cc89c9a3c6a\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"origin/feature/only-cube-in-main\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"GT_table_viz works now very nice. To be inserted in GT tool.\" />\r\n    <MESSAGE value=\"Supression of .ui previous try of class assignment\" />\r\n    <MESSAGE value=\"Connection table and GT tools. &#10;right click interaction added on table.\" />\r\n    <MESSAGE value=\"handle of classe suppresion ok\" />\r\n    <MESSAGE value=\"Add, suppres and reset bands working (on the graph)\" />\r\n    <MESSAGE value=\"Added normalizarion for Unsupervised\" />\r\n    <MESSAGE value=\"pixel_averaged added + saving GT started\" />\r\n    <MESSAGE value=\"Bugg of metadata loading finally fixed :-p\" />\r\n    <MESSAGE value=\"Loading GT_tool with cubeInfo&#10;GT tool inserted in main\" />\r\n    <MESSAGE value=\"Back to main organisation&#10;Ground Truth tool operationnel\" />\r\n    <MESSAGE value=\"added\" />\r\n    <MESSAGE value=\"fixed bugg meta wl with register cube&#10;fixed rgb save bugg register\" />\r\n    <MESSAGE value=\"plein de trucs :-p\" />\r\n    <MESSAGE value=\"data_viz : &#10;- all metadata pop up OK&#10;- live spectrum ok&#10;- resize graph ok&#10;- 3 imeges same size OK\" />\r\n    <MESSAGE value=\"ouverture des cubes dans data_viz elargie en format, ajout de la hash_up table pour association de cube, depandance UV differentes\" />\r\n    <MESSAGE value=\"syncronize Drag and scroll for images and GT&#10;Open non h5&#10;live spectrum initiate if no GT\" />\r\n    <MESSAGE value=\"Main added all tools and open cube with dialog\" />\r\n    <MESSAGE value=\"Metadata tool with generate meta first step.&#10;Much robust for lokking at changes keep save etc...\" />\r\n    <MESSAGE value=\"Metadata tool copy from other cube et add/remove metadatum\" />\r\n    <MESSAGE value=\"Metadata tool copy from other cube -&gt; type keep for non editable like numpy&#10;open cube possibility\" />\r\n    <MESSAGE value=\"[Metadata] copy from other cube -&gt; type keep for non editable like numpy&#10;open cube possibility&#10;[Registration] all metadata seems OK. Gestion des croped parent etc....\" />\r\n    <MESSAGE value=\"Cube info loading and saving are syncronized with all tools (except visualize)&#10;[registration] manual features supression\" />\r\n    <MESSAGE value=\"[main] correction of suggestions suprresion\" />\r\n    <MESSAGE value=\"[main] open all bugg fixed&#10;[register] modif features, sliders bugg and labels and groups, click to select, auto load other, progress bar reset all, cubeinfo unique and parent cube editable at save.\" />\r\n    <MESSAGE value=\"Lot of things but most of all matlab.engine\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Lot of things but most of all matlab.engine\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/MainWindow.py</url>\r\n          <line>8</line>\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/.idea/workspace.xml	(date 1752499303443)
@@ -4,25 +4,16 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="d582d865-26c1-4224-a66c-1fa3811218c4" name="Changes" comment="Lot of things but most of all matlab.engine">
-      <change afterPath="$PROJECT_DIR$/hypercubes/matlab_engine_control.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/hypercubes/matlab_subprocess.py" afterDir="false" />
+    <list default="true" id="d582d865-26c1-4224-a66c-1fa3811218c4" name="Changes" comment="Added matlab open from subprocess">
+      <change beforePath="$PROJECT_DIR$/.idea/Hypertool.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/Hypertool.iml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Hypertool.xmind" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/MainWindow.py" beforeDir="false" afterPath="$PROJECT_DIR$/MainWindow.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/MainWindow.spec" beforeDir="false" afterPath="$PROJECT_DIR$/MainWindow.spec" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/data_vizualisation/data_vizualisation_tool.py" beforeDir="false" afterPath="$PROJECT_DIR$/data_vizualisation/data_vizualisation_tool.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/get_requirement.py" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/ground_truth/ground_truth_tool.py" beforeDir="false" afterPath="$PROJECT_DIR$/ground_truth/ground_truth_tool.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/hypercubes/hypercube.py" beforeDir="false" afterPath="$PROJECT_DIR$/hypercubes/hypercube.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/hypercubes/matlab_engine_search.py" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/hypercubes/matlab_env_path.py" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/hypercubes/matlab_loader.py" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/install_requirements.py" beforeDir="false" afterPath="$PROJECT_DIR$/install_requirements.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ground_truth/ground_truth_window.py" beforeDir="false" afterPath="$PROJECT_DIR$/ground_truth/ground_truth_window.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ground_truth/ground_truth_window.ui" beforeDir="false" afterPath="$PROJECT_DIR$/ground_truth/ground_truth_window.ui" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hypercubes/matlab_subprocess.py" beforeDir="false" afterPath="$PROJECT_DIR$/hypercubes/matlab_subprocess.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/log/error.log" beforeDir="false" afterPath="$PROJECT_DIR$/log/error.log" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/metadata/metadata_tool.py" beforeDir="false" afterPath="$PROJECT_DIR$/metadata/metadata_tool.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/registration/register_tool.py" beforeDir="false" afterPath="$PROJECT_DIR$/registration/register_tool.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test.py" beforeDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -118,6 +109,9 @@
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
       <option name="SDK_HOME" value="" />
       <option name="SDK_NAME" value="Python 3.12" />
       <option name="WORKING_DIRECTORY" value="C:\Users\Usuario\Documents\GitHub\Hypertool" />
@@ -149,14 +143,6 @@
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
       <updated>1744020944801</updated>
-    </task>
-    <task id="LOCAL-00015" summary="Load in VizTool OK">
-      <option name="closed" value="true" />
-      <created>1746610626729</created>
-      <option name="number" value="00015" />
-      <option name="presentableId" value="LOCAL-00015" />
-      <option name="project" value="LOCAL" />
-      <updated>1746610626729</updated>
     </task>
     <task id="LOCAL-00016" summary="Dockable window started.&#10;First test OK but widget not connected">
       <option name="closed" value="true" />
@@ -542,7 +528,15 @@
       <option name="project" value="LOCAL" />
       <updated>1752109688330</updated>
     </task>
-    <option name="localTasksCounter" value="64" />
+    <task id="LOCAL-00064" summary="Added matlab open from subprocess">
+      <option name="closed" value="true" />
+      <created>1752252926899</created>
+      <option name="number" value="00064" />
+      <option name="presentableId" value="LOCAL-00064" />
+      <option name="project" value="LOCAL" />
+      <updated>1752252926899</updated>
+    </task>
+    <option name="localTasksCounter" value="65" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -594,7 +588,6 @@
     </option>
   </component>
   <component name="VcsManagerConfiguration">
-    <MESSAGE value="GT_table_viz works now very nice. To be inserted in GT tool." />
     <MESSAGE value="Supression of .ui previous try of class assignment" />
     <MESSAGE value="Connection table and GT tools. &#10;right click interaction added on table." />
     <MESSAGE value="handle of classe suppresion ok" />
@@ -619,14 +612,15 @@
     <MESSAGE value="[main] correction of suggestions suprresion" />
     <MESSAGE value="[main] open all bugg fixed&#10;[register] modif features, sliders bugg and labels and groups, click to select, auto load other, progress bar reset all, cubeinfo unique and parent cube editable at save." />
     <MESSAGE value="Lot of things but most of all matlab.engine" />
-    <option name="LAST_COMMIT_MESSAGE" value="Lot of things but most of all matlab.engine" />
+    <MESSAGE value="Added matlab open from subprocess" />
+    <option name="LAST_COMMIT_MESSAGE" value="Added matlab open from subprocess" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/MainWindow.py</url>
-          <line>8</line>
+          <line>7</line>
           <option name="timeStamp" value="1" />
         </line-breakpoint>
       </breakpoints>
Index: hypercubes/matlab_subprocess.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport subprocess\r\nimport tempfile\r\nimport scipy.io\r\nimport numpy as np\r\nimport glob\r\n\r\ndef find_matlab_executable():\r\n    base_dir = r\"C:\\Program Files\\MATLAB\"\r\n    if not os.path.isdir(base_dir):\r\n        return None\r\n\r\n    # Recherche toutes les versions installées\r\n    versions = sorted(\r\n        glob.glob(os.path.join(base_dir, \"R20*\", \"bin\", \"matlab.exe\")),\r\n        reverse=True\r\n    )\r\n\r\n    if versions:\r\n        return versions[0]  # la version la plus récente\r\n    return None\r\n\r\n\r\ndef load_mat_file_with_matlab_obj(filepath, debug=False):\r\n    \"\"\"\r\n    Charge un fichier .mat contenant un objet `cube` depuis MATLAB sans utiliser matlab.engine,\r\n    en accédant à cube.DataCube, cube.Wavelength et Metadata, et en exportant dans un .mat lisible.\r\n    \"\"\"\r\n    if not os.path.isfile(filepath):\r\n        raise FileNotFoundError(f\"File not found: {filepath}\")\r\n\r\n    tmp_dir = tempfile.mkdtemp()\r\n    script_path = os.path.join(tmp_dir, \"extract_cube_fields.m\")\r\n    output_path = os.path.join(tmp_dir, \"cube_fields_output.mat\")\r\n\r\n    filepath_matlab = filepath.replace(\"\\\\\", \"/\")\r\n    output_path_matlab = output_path.replace(\"\\\\\", \"/\")\r\n\r\n    # Création du script MATLAB\r\n    with open(script_path, \"w\") as f:\r\n        f.write(f\"\"\"\r\n        try\r\n            disp('Trying to load you cube .mat from Matlab environment.');\r\n            disp('This may take one minute. Please wait.');\r\n\r\n            load('{filepath_matlab}');\r\n\r\n            disp('Getting from cube : DataCube, Wavelength, Metadata...');\r\n            data = cube.DataCube;\r\n\r\n            try\r\n                wl = cube.Wavelength;\r\n            catch\r\n                wl = [];\r\n                disp(' [ !!! ] Wavelength not found');\r\n            end\r\n\r\n            try\r\n                meta = Metadata;\r\n            catch\r\n                meta = [];\r\n                disp(' [ !!! ] Metadata not found');\r\n            end\r\n\r\n            disp('Sending cube to python...');\r\n            save('{output_path_matlab}', 'data', 'wl', 'meta');\r\n\r\n            disp('[ :-) ]Sended to python with succes.');\r\n        catch ME\r\n            disp('[ !!!] An errror occured :');\r\n            disp(getReport(ME));\r\n            exit(1);\r\n        end\r\n        exit;\r\n        \"\"\")\r\n\r\n    # Exécution de MATLAB\r\n    try:\r\n        matlab_cmd = find_matlab_executable() or \"matlab\"\r\n        result = subprocess.run(\r\n            [matlab_cmd, \"-batch\", f\"run('{script_path.replace('\\\\\\\\', '/')}')\"],\r\n            stdout=subprocess.PIPE,\r\n            stderr=subprocess.PIPE,\r\n            text=True,\r\n            timeout=300\r\n        )\r\n        if result.returncode != 0:\r\n            print(\"❌ MATLAB error\")\r\n            print(\"STDOUT:\", result.stdout)\r\n            print(\"STDERR:\", result.stderr)\r\n            raise RuntimeError(\"MATLAB returned an error\")\r\n    except Exception as e:\r\n        raise RuntimeError(f\"MATLAB batch execution failed: {e}\")\r\n\r\n    if not os.path.exists(output_path):\r\n        raise FileNotFoundError(\"MATLAB did not produce expected output\")\r\n\r\n    # Lecture finale en Python\r\n    out = scipy.io.loadmat(output_path)\r\n    data = np.array(out.get(\"data\"))\r\n    wl = np.array(out.get(\"wl\")).squeeze() if \"wl\" in out else None\r\n    meta_raw = out.get(\"meta\", None)\r\n\r\n    # Conversion de meta MATLAB struct → dict Python\r\n    meta = None\r\n    if meta_raw is not None and meta_raw.dtype.names:\r\n        meta = {field: meta_raw[field][0, 0] for field in meta_raw.dtype.names}\r\n\r\n    # Nettoyage\r\n    if not debug:\r\n        try:\r\n            os.remove(script_path)\r\n            os.remove(output_path)\r\n            os.rmdir(tmp_dir)\r\n        except Exception:\r\n            pass\r\n\r\n    return data, wl, meta
===================================================================
diff --git a/hypercubes/matlab_subprocess.py b/hypercubes/matlab_subprocess.py
--- a/hypercubes/matlab_subprocess.py	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/hypercubes/matlab_subprocess.py	(date 1752253558552)
@@ -10,14 +10,14 @@
     if not os.path.isdir(base_dir):
         return None
 
-    # Recherche toutes les versions installées
+    # Look for matlab > 2000
     versions = sorted(
         glob.glob(os.path.join(base_dir, "R20*", "bin", "matlab.exe")),
         reverse=True
     )
 
     if versions:
-        return versions[0]  # la version la plus récente
+        return versions[0]  # last version
     return None
 
 
Index: log/error.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>2025-07-11 17:37:28,972 - ERROR - Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\\ground_truth_tool.py\", line 1098, in load_cube\r\n    if self.wl[-1] < 1100 and self.wl[0] > 350:\r\nTypeError: 'NoneType' object is not subscriptable\r\n\r\n2025-07-11 18:06:38,628 - ERROR - Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\\ground_truth_tool.py\", line 1098, in load_cube\r\n    if self.wl[-1] < 1100 and self.wl[0] > 350:\r\n       ~~~~~~~^^^^\r\nTypeError: 'NoneType' object is not subscriptable\r\n\r\n2025-07-11 18:08:36,729 - ERROR - Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\\ground_truth_tool.py\", line 1098, in load_cube\r\n    if self.wl[-1] < 1100 and self.wl[0] > 350:\r\n       ~~~~~~~^^^^\r\nTypeError: 'NoneType' object is not subscriptable\r\n\r\n2025-07-11 18:25:02,986 - ERROR - Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\\ground_truth_tool.py\", line 1098, in load_cube\r\n    if self.wl[-1] < 1100 and self.wl[0] > 350:\r\n       ~~~~~~~^^^^\r\nTypeError: 'NoneType' object is not subscriptable\r\n\r\n2025-07-11 18:27:03,891 - ERROR - Uncaught exception:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Usuario\\Documents\\GitHub\\Hypertool\\ground_truth\\ground_truth_tool.py\", line 1098, in load_cube\r\n    if self.wl[-1] < 1100 and self.wl[0] > 350:\r\n       ~~~~~~~^^^^\r\nTypeError: 'NoneType' object is not subscriptable\r\n\r\n
===================================================================
diff --git a/log/error.log b/log/error.log
--- a/log/error.log	(revision 7501d3e3099590354d559ab7259647154c3f18c5)
+++ b/log/error.log	(date 1752480509640)
@@ -32,3 +32,17 @@
        ~~~~~~~^^^^
 TypeError: 'NoneType' object is not subscriptable
 
+2025-07-14 10:08:23,851 - ERROR - Uncaught exception:
+Traceback (most recent call last):
+  File "C:\Users\Usuario\Documents\GitHub\Hypertool\ground_truth\ground_truth_tool.py", line 738, in modif_sliders
+    max_wl = int(self.wl[-1])
+                 ~~~~~~~^^^^
+TypeError: 'NoneType' object is not subscriptable
+
+2025-07-14 10:08:29,640 - ERROR - Uncaught exception:
+Traceback (most recent call last):
+  File "C:\Users\Usuario\Documents\GitHub\Hypertool\ground_truth\ground_truth_tool.py", line 738, in modif_sliders
+    max_wl = int(self.wl[-1])
+                 ~~~~~~~^^^^
+TypeError: 'NoneType' object is not subscriptable
+
